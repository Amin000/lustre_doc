
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Lustre Architecture · Lustre doc</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-pageview-count/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-atoc/atoc.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-auto-scroll-table/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-theme-comscore/test.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Understanding-Lustre-Internals-中文翻译.html" />
    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                        <b>1.1.</b>
                    
                    介绍
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="./">
            
                <a href="./">
            
                    
                        <b>1.2.</b>
                    
                    Understanding Lustre Internals 中文翻译
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#lustre-architecture">
            
                    
                        <b>1.2.1.</b>
                    
                    Lustre Architecture
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1.1" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#what-is-lustre">
            
                    
                        <b>1.2.1.1.</b>
                    
                    What is Lustre?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.2" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#lustre-features">
            
                    
                        <b>1.2.1.2.</b>
                    
                    Lustre Features
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.3" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#lustre-components">
            
                    
                        <b>1.2.1.3.</b>
                    
                    Lustre Components
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.4" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#lustre-file-layouts">
            
                    
                        <b>1.2.1.4.</b>
                    
                    Lustre File Layouts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1.4.1" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#normal-raid0-layouts">
            
                    
                        <b>1.2.1.4.1.</b>
                    
                    Normal (RAID0) Layouts
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#test">
            
                    
                        <b>1.2.2.</b>
                    
                    TEST
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#utils">
            
                    
                        <b>1.2.3.</b>
                    
                    UTILS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#mgc">
            
                    
                        <b>1.2.4.</b>
                    
                    MGC
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.4.1" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#mgc-introduction">
            
                    
                        <b>1.2.4.1.</b>
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4.2" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#mgc-module-initialization">
            
                    
                        <b>1.2.4.2.</b>
                    
                    MGC Module Initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4.3" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#mgc-obd-operations">
            
                    
                        <b>1.2.4.3.</b>
                    
                    MGC obd Operations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4.4" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#mgcsetup">
            
                    
                        <b>1.2.4.4.</b>
                    
                    mgc_setup()
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.4.4.1" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#operation">
            
                    
                        <b>1.2.4.4.1.</b>
                    
                    Operation
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.4.5" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#lustre-log-handling">
            
                    
                        <b>1.2.4.5.</b>
                    
                    Lustre Log Handling
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.4.5.1" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#log-processing-in-mgc">
            
                    
                        <b>1.2.4.5.1.</b>
                    
                    Log Processing in MGC
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.4.6" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#mgcprecleanup-and-mgccleanup">
            
                    
                        <b>1.2.4.6.</b>
                    
                    mgc_precleanup() and mgc_cleanup()
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4.7" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#mgcimportevent">
            
                    
                        <b>1.2.4.7.</b>
                    
                    mgc_import_event()
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#obdclass">
            
                    
                        <b>1.2.5.</b>
                    
                    OBDCLASS
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.5.1" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#obdclass-introduction">
            
                    
                        <b>1.2.5.1.</b>
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5.2" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#obddevice-structure">
            
                    
                        <b>1.2.5.2.</b>
                    
                    obd_device Structure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5.3" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#mgc-life-cycle">
            
                    
                        <b>1.2.5.3.</b>
                    
                    MGC Life Cycle
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5.4" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#obd-device-life-cycle">
            
                    
                        <b>1.2.5.4.</b>
                    
                    Obd Device Life Cycle
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.5.4.1" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#classattach">
            
                    
                        <b>1.2.5.4.1.</b>
                    
                    class_attach()
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5.4.2" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#obdexport-structure">
            
                    
                        <b>1.2.5.4.2.</b>
                    
                    obd_export Structure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5.4.3" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#classsetup">
            
                    
                        <b>1.2.5.4.3.</b>
                    
                    class_setup()
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5.4.4" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#classprecleanup-and-classcleanup">
            
                    
                        <b>1.2.5.4.4.</b>
                    
                    class_precleanup() and class_cleanup()
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.5.5" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#imports-and-exports">
            
                    
                        <b>1.2.5.5.</b>
                    
                    Imports and Exports
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5.6" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#useful-apis-in-obdclass">
            
                    
                        <b>1.2.5.6.</b>
                    
                    Useful APIs in Obdclass
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#libcfs">
            
                    
                        <b>1.2.6.</b>
                    
                    LIBCFS
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.6.1" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#libcfs-introduction">
            
                    
                        <b>1.2.6.1.</b>
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6.2" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#data-encryption-support-in-libcfs">
            
                    
                        <b>1.2.6.2.</b>
                    
                    Data Encryption Support in Libcfs
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6.3" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#cpu-partition-table-management">
            
                    
                        <b>1.2.6.3.</b>
                    
                    CPU Partition Table Management
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6.4" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#debugging-support-and-failure-injection">
            
                    
                        <b>1.2.6.4.</b>
                    
                    Debugging Support and Failure Injection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6.5" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#additional-supporting-software-in-libcfs">
            
                    
                        <b>1.2.6.5.</b>
                    
                    Additional Supporting Software in Libcfs
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#file-identifiers-fid-location-database-and-object-index">
            
                    
                        <b>1.2.7.</b>
                    
                    File Identifiers, FID Location Database, and Object Index
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.7.1" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#file-identifier-fid">
            
                    
                        <b>1.2.7.1.</b>
                    
                    File Identifier (FID)
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.7.1.1" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#reserved-sequence-numbers-and-object-ids">
            
                    
                        <b>1.2.7.1.1.</b>
                    
                    Reserved Sequence Numbers and Object IDs
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7.1.2" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#fid-kernel-module">
            
                    
                        <b>1.2.7.1.2.</b>
                    
                    fid Kernel Module
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.7.2" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#fid-location-database-fld">
            
                    
                        <b>1.2.7.2.</b>
                    
                    FID Location Database (FLD)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7.3" data-path="Understanding-Lustre-Internals-中文翻译.html">
            
                <a href="Understanding-Lustre-Internals-中文翻译.html#object-index-oi">
            
                    
                        <b>1.2.7.3.</b>
                    
                    Object Index (OI)
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            本书使用 GitBook 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Lustre Architecture</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="lustre-architecture"><a name="lustre-architecture" class="plugin-anchor" href="#lustre-architecture"><i class="fa fa-link" aria-hidden="true"></i></a>Lustre Architecture</h1>
<h2 id="what-is-lustre"><a name="what-is-lustre" class="plugin-anchor" href="#what-is-lustre"><i class="fa fa-link" aria-hidden="true"></i></a>What is Lustre?</h2>
<p>Lustre is a GNU General Public licensed, open-source distributed parallel file system developed and maintained by DataDirect Networks (DDN). Due to the extremely scalable architecture of the Lustre file system, Lustre deployments are popular in scientific supercomputing, as well as in the oil and gas, manufacturing, rich media, and finance sectors. Lustre presents a POSIX interface to its clients with parallel access capabilities to the shared file objects. As of this writing, Lustre is the most widely used file system on the top 500 fastest computers in the world. Lustre is the file system of choice on 7 out of the top 10 fastest computers in the world today, over 70% of the top 100, and also for over 60% of the top 500&#x3002;</p>
<blockquote>
<p>Lustre &#x662F;&#x4E00;&#x4E2A;&#x7531; DDN &#x5F00;&#x53D1;&#x548C;&#x7EF4;&#x62A4;&#x7684;&#x3001;&#x5F00;&#x6E90;&#x7684;&#x3001;GPL&#x534F;&#x8BAE;&#x4E0B;&#x7684;&#x5206;&#x5E03;&#x5F0F;&#x5E76;&#x884C;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x3002;Lustre &#x67B6;&#x6784;&#x5177;&#x6709;&#x6781;&#x5F3A;&#x7684;&#x6269;&#x5C55;&#x6027;&#xFF0C;&#x5728;&#x8D85;&#x7B97;&#xFF0C;&#x77F3;&#x6CB9;&#xFF0C;&#x5929;&#x7136;&#x6C14;&#xFF0C;&#x5236;&#x9020;&#x4E1A;&#xFF0C;&#x5BCC;&#x5A92;&#x4F53;&#xFF0C;&#x91D1;&#x878D;&#x884C;&#x4E1A;&#x7B49;&#x9886;&#x57DF;&#x5927;&#x91CF;&#x90E8;&#x7F72;&#x3002;Lustre &#x5411;&#x5176;&#x5BA2;&#x6237;&#x7AEF;&#x63D0;&#x4F9B;&#x5177;&#x6709;&#x5E76;&#x884C;&#x8BBF;&#x95EE;&#x5171;&#x4EAB;&#x6587;&#x4EF6;&#x5BF9;&#x8C61;&#x7684; POSIX &#x63A5;&#x53E3;&#x3002;&#x622A;&#x81F3;&#x76EE;&#x524D;&#xFF0C;Lustre &#x662F;&#x5168;&#x7403;&#x6700;&#x5FEB;&#x8BA1;&#x7B97;&#x673A; TOP 500&#x699C;&#x5355;&#x4E2D;&#x4F7F;&#x7528;&#x6700;&#x591A;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x3002;&#x5728;&#x524D;&#x5341;&#x540D;&#x4E2D;&#xFF0C;&#x6709;7&#x53F0;&#x9009;&#x62E9; Lustre &#x4F5C;&#x4E3A;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF0C;&#x5E76;&#x4E14;&#x5728;&#x524D;100&#x540D;&#x4E2D;&#xFF0C;&#x8D85;&#x8FC7;70%&#x7684;&#x4F7F;&#x7528;&#x7387;&#xFF1B;&#x5728;&#x524D;500&#x540D;&#x4E2D;&#xFF0C;&#x4E5F;&#x8D85;&#x8FC7;60%&#x7684;&#x4F7F;&#x7528;&#x7387;&#x3002;</p>
</blockquote>
<h2 id="lustre-features"><a name="lustre-features" class="plugin-anchor" href="#lustre-features"><i class="fa fa-link" aria-hidden="true"></i></a>Lustre Features</h2>
<p>Lustre is designed for scalability and performance. The aggregate storage capacity and file system bandwidth can be scaled up by adding more servers to the file system, and performance for parallel applications can often be increased by utilizing more Lustre clients. Some practical limits are shown in Table 1 along with values from known production file systems.</p>
<blockquote>
<p>Lustre &#x4E3A;&#x4E86;&#x6269;&#x5C55;&#x6027;&#x548C;&#x6027;&#x80FD;&#x7684;&#x76EE;&#x5F55;&#x800C;&#x8BBE;&#x8BA1;&#x3002;&#x5B83;&#x7684;&#x5B58;&#x50A8;&#x5BB9;&#x91CF;&#x548C;&#x805A;&#x5408;&#x6027;&#x80FD;&#x968F;&#x7740;&#x670D;&#x52A1;&#x5668;&#x589E;&#x52A0;&#x4E0D;&#x65AD;&#x6269;&#x5C55;&#xFF0C;&#x5E76;&#x4E14;&#x63D0;&#x4F9B;&#x7ED9;&#x5E76;&#x884C;&#x5E94;&#x7528;&#x7684;&#x6027;&#x80FD;&#x53EF;&#x4EE5;&#x968F;&#x7740;&#x5BA2;&#x6237;&#x7AEF;&#x7684;&#x589E;&#x52A0;&#x800C;&#x589E;&#x957F;&#x3002;&#x4E0B;&#x8868;&#x5C55;&#x793A;&#x4E00;&#x4E9B;&#x5F53;&#x524D;&#x7684;&#x7406;&#x8BBA;&#x9650;&#x5236;&#x8303;&#x56F4;&#x548C;&#x5728;&#x5DF2;&#x77E5;&#x751F;&#x4EA7;&#x7CFB;&#x7EDF;&#x4E2D;&#x7684;&#x5B9E;&#x8DF5;&#x503C;&#x3002;</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">&#x7279;&#x6027;</th>
<th style="text-align:left">&#x7406;&#x8BBA;&#x9650;&#x5236;&#x8303;&#x56F4;</th>
<th style="text-align:left">&#x5DF2;&#x77E5;&#x751F;&#x4EA7;&#x7CFB;&#x7EDF;&#x7684;&#x5B9E;&#x8DF5;&#x503C;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&#x5BA2;&#x6237;&#x7AEF;&#x6269;&#x5C55;&#x6027;</td>
<td style="text-align:left">100 - 100,000&#x4E2A;</td>
<td style="text-align:left">50,000+ &#x5BA2;&#x6237;&#x7AEF;, &#x5927;&#x591A;&#x6570;&#x5728;10,000&#x5230;20,000&#x4E4B;&#x95F4;</td>
</tr>
<tr>
<td style="text-align:left">&#x5BA2;&#x6237;&#x7AEF;&#x6027;&#x80FD;</td>
<td style="text-align:left">&#x5355;&#x5BA2;&#x6237;&#x7AEF;&#xFF1A;90%&#x7684;&#x7F51;&#x7EDC;&#x5E26;&#x5BBD; <br> &#x805A;&#x5408;&#xFF1A;10TB/s</td>
<td style="text-align:left">&#x5355;&#x5BA2;&#x6237;&#x7AEF;&#x5E26;&#x5BBD;&#xFF1A;4.5GB/s(FDR IB, OPA1), &#x5143;&#x6570;&#x636E;&#x6027;&#x80FD;&#xFF1A;1000 ops/s <br> &#x805A;&#x5408;&#xFF1A;2.5TB/s</td>
</tr>
<tr>
<td style="text-align:left">OSS &#x6269;&#x5C55;&#x6027;</td>
<td style="text-align:left">OSS&#xFF1A;&#x6BCF;&#x4E2A;OSS&#x53EF;&#x62E5;&#x6709;1-32&#x4E2A; OST <br> OST&#xFF08;ldiskfs&#xFF09;&#xFF1A;300M &#x4E2A;&#x5BF9;&#x8C61;&#xFF0C;&#x6BCF;&#x4E2A; OST &#x53EF;&#x8FBE;256TiB  <br> OST&#xFF08;ZFS&#xFF09;&#xFF1A;500M&#x4E2A;&#x5BF9;&#x8C61;&#xFF0C;&#x6BCF;&#x4E2A; OST &#x53EF;&#x8FBE;256TiB <br> OSS &#x6570;&#x91CF;&#xFF1A;&#x6700;&#x591A;1000&#x4E2A; OSS&#xFF0C;&#x6BCF;&#x4E2A; OSS&#x6700;&#x591A;&#x62E5;&#x6709;4000&#x4E2A; OST</td>
<td style="text-align:left">OSS&#xFF08;ldiskfs&#xFF09;&#xFF1A;&#x6BCF;&#x4E2A; OSS &#x53EF;&#x62E5;&#x6709;32&#x4E2A;8TiB OST&#xFF0C;&#x6216;&#x8005;&#x6BCF;&#x4E2A;OSS&#x53EF;&#x62E5;&#x6709;8&#x4E2A;32TiB OST <br> OSS&#xFF08;ZFS&#xFF09;&#xFF1A;&#x6BCF;&#x4E2A;OSS&#x53EF;&#x62E5;&#x6709;1&#x4E2A;72TiB OST <br> OSS&#x6570;&#x91CF;&#xFF1A;&#x6709;450&#x4E2A; OSS&#xFF0C;&#x6BCF;&#x4E2A;OSS&#x6709;1000&#x4E2A;4TiB OST&#xFF1B;&#x6216;&#x8005;&#x6709;192&#x4E2A; OSS&#xFF0C;&#x6BCF;&#x4E2A; OSS &#x6709;1344&#x4E2A;8TiB OST&#xFF1B;&#x6216;&#x8005;&#x6709;768&#x4E2A;OSS&#xFF0C;&#x6BCF;&#x4E2A;OSS&#x6709;768&#x4E2A;72TiB OST</td>
</tr>
<tr>
<td style="text-align:left">OSS &#x6027;&#x80FD;</td>
<td style="text-align:left">&#x5355;&#x4E2A;OSS&#xFF1A;15GB/s <br> &#x805A;&#x5408;&#xFF1A;10TB/s</td>
<td style="text-align:left">&#x5355;&#x4E2A; OSS: 10 GB/s <br> &#x805A;&#x5408;: 2.5 TB/s</td>
</tr>
<tr>
<td style="text-align:left">MDS &#x6269;&#x5C55;&#x6027;</td>
<td style="text-align:left">MDS&#xFF1A;&#x6BCF;&#x4E2A; MDS &#x53EF;&#x62E5;&#x6709; 1-4&#x4E2A; MDT <br> MDT&#xFF08;ldiskfs&#xFF09;&#xFF1A;&#x6BCF;&#x4E2A;MDT&#x53EF;&#x62E5;&#x6709;40&#x4EBF;&#x4E2A;&#x6587;&#x4EF6;&#xFF0C;8 TiB&#x5BB9;&#x91CF; <br> MDT&#xFF08;ZFS&#xFF09;&#xFF1A;&#x6BCF;&#x4E2A; MDT &#x53EF;&#x62E5;&#x6709;640&#x4EBF;&#x4E2A;&#x6587;&#x4EF6;&#xFF0C;64 TiB&#x5BB9;&#x91CF; <br> MDS&#x6570;&#x91CF;&#xFF1A;&#x6709;256&#x4E2A; MDS&#xFF0C;&#x6BCF;&#x4E2A; MDS &#x6700;&#x591A;&#x62E5;&#x6709;265&#x4E2A; MDT</td>
<td style="text-align:left">MDS&#xFF1A;&#x6BCF;&#x4E2A; MDS &#x53EF;&#x62E5;&#x6709;30&#x4EBF;&#x4E2A;&#x6587;&#x4EF6; <br> MDS&#x6570;&#x91CF;&#xFF1A;&#x5728;&#x751F;&#x4EA7;&#x73AF;&#x5883;&#x4E2D;&#x6709;7&#x4E2A; MDS&#xFF0C;&#x6BCF;&#x4E2A; MDS &#x62E5;&#x6709;7&#x4E2A;2 TiB&#x7684; MDT&#xFF08;&#x5728;&#x6D4B;&#x8BD5;&#x73AF;&#x5883;&#x4E2D;&#x6709;256&#x4E2A; MDS&#xFF0C;&#x6BCF;&#x4E2A; MDS &#x62E5;&#x6709;256&#x4E2A;64 GiB &#x7684; MDT&#xFF09;</td>
</tr>
<tr>
<td style="text-align:left">MDS &#x6027;&#x80FD;</td>
<td style="text-align:left">create&#xFF1A; 50,000 ops/s <br> stats&#xFF1A;200,000 ops/s</td>
<td style="text-align:left">create&#xFF1A; 15,000 ops/s <br> stats&#xFF1A;50,000 ops/s</td>
</tr>
<tr>
<td style="text-align:left">&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6269;&#x5C55;&#x6027;</td>
<td style="text-align:left">&#x5355;&#x4E2A;&#x6587;&#x4EF6;&#xFF08;&#x6700;&#x5927;&#x5927;&#x5C0F;&#xFF09;&#xFF1A;32 PiB&#xFF08;ldiskfs&#xFF09;&#x6216; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>6</mn><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex"> 2^{63} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">6</span><span class="mord mathrm mtight">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span> bytes&#xFF08;ZFS&#xFF09; <br> &#x603B;&#x4F53;&#xFF1A;512 PiB &#x7684;&#x603B;&#x5BB9;&#x91CF;&#xFF0C;1&#x4E07;&#x4EBF;&#x4E2A;&#x6587;&#x4EF6;</td>
<td style="text-align:left">&#x5355;&#x4E2A;&#x6587;&#x4EF6;&#xFF08;&#x6700;&#x5927;&#x5927;&#x5C0F;&#xFF09;&#xFF1A;TiB &#x7EA7; <br> &#x603B;&#x4F53;&#xFF1A;55 PiB &#x7684;&#x603B;&#x5BB9;&#x91CF;&#xFF0C;80&#x4EBF;&#x4E2A;&#x6587;&#x4EF6;</td>
</tr>
</tbody>
</table>
<p>Lustre has several features that enhance performance, usability, and stability. Some of these features include:</p>
<p>Lustre &#x5177;&#x6709;&#x591A;&#x79CD;&#x7279;&#x6027;&#xFF0C;&#x4EE5;&#x7528;&#x4E8E;&#x6027;&#x80FD;&#x63D0;&#x5347;&#x3001;&#x53EF;&#x7528;&#x6027;&#x548C;&#x7A33;&#x5B9A;&#x6027;&#x7684;&#x9700;&#x6C42;&#x3002;&#x4E00;&#x4E9B;&#x7279;&#x6027;&#x603B;&#x7ED3;&#x5982;&#x4E0B;&#xFF1A;</p>
<ul>
<li>POSIX Compliance: With few exceptions, Lustre passes the full POSIX test suite. Most operations are atomic to ensure that clients do not see stale data or metadata. Lustre also supports mmap() file IO.</li>
</ul>
<blockquote>
<p>POSIX &#x517C;&#x5BB9;&#x6027;&#xFF1A;Lustre &#x51E0;&#x4E4E;&#x901A;&#x8FC7;&#x4E86; POSIX &#x7684;&#x517C;&#x5BB9;&#x6027;&#x6D4B;&#x8BD5;&#x3002;&#x5176;&#x5927;&#x90E8;&#x5206;&#x64CD;&#x4F5C;&#x662F;&#x539F;&#x5B50;&#x6027;&#xFF0C;&#x4EE5;&#x786E;&#x4FDD;&#x5BF9;&#x5BA2;&#x6237;&#x7AEF;&#x7684;&#x900F;&#x660E;&#x6027;&#x3002;&#x53E6;&#x5916; Lustre &#x652F;&#x6301; mmap &#x6587;&#x4EF6; IO&#x3002;</p>
</blockquote>
<ul>
<li>Online file system checking: Lustre provides a file system checker (LFSCK) to detect and correct file system inconsistencies. LFSCK can be run while the file system in online and in production, minimizing potential downtime.</li>
</ul>
<blockquote>
<p>&#x6570;&#x636E;&#x5728;&#x7EBF;&#x6821;&#x9A8C;&#xFF1A;Lustre &#x4F7F;&#x7528; LFSCK &#x5DE5;&#x5177;&#x68C0;&#x67E5;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;&#x6570;&#x636E;&#x4E00;&#x81F4;&#x6027;&#x3002;LFSCK &#x53EF;&#x4EE5;&#x5728;&#x751F;&#x4EA7;&#x73AF;&#x5883;&#x4E2D;&#x5728;&#x7EBF;&#x8FD0;&#x884C;&#xFF0C;&#x51CF;&#x5C11;&#x6F5C;&#x5728;&#x7684;&#x5B58;&#x50A8;&#x670D;&#x52A1;&#x4E0B;&#x7EBF;&#x65F6;&#x95F4;&#x3002;</p>
</blockquote>
<ul>
<li>Controlled file layouts: The file layouts that determine how data is placed across the Lustre servers can be customized on a per-file basis. This allows users to optimize the layout to best fit their specific use case.</li>
</ul>
<blockquote>
<p>&#x53EF;&#x63A7;&#x7684;&#x6587;&#x4EF6;&#x5E03;&#x5C40;&#xFF1A;&#x6587;&#x4EF6;&#x5E03;&#x5C40;&#x51B3;&#x5B9A;&#x6570;&#x636E;&#x7684;&#x5B58;&#x653E;&#x4F4D;&#x7F6E;&#x3002;Lustre &#x5E03;&#x5C40;&#x65B9;&#x5F0F;&#x53EF;&#x4EE5;&#x57FA;&#x4E8E;&#x6587;&#x4EF6;&#x7684;&#x7C92;&#x5EA6;&#x3002;&#x7528;&#x6237;&#x53EF;&#x6839;&#x636E;&#x5176;&#x4F7F;&#x7528;&#x573A;&#x666F;&#x4F18;&#x5316;&#x6587;&#x4EF6;&#x5E03;&#x5C40;&#x65B9;&#x5F0F;&#x3002;</p>
</blockquote>
<ul>
<li>Support for multiple backend file systems: When formatting a Lustre file system, the underlying storage can be formatted as either ldiskfs (a performance-enhanced version of ext4) or ZFS.</li>
</ul>
<blockquote>
<p>&#x540E;&#x7AEF;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF1A;Lustre &#x73B0;&#x652F;&#x6301;&#x4E24;&#x79CD;&#x540E;&#x7AEF;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF1A;ldiskfs &#x548C; zfs&#x3002;</p>
</blockquote>
<ul>
<li>Support for high-performance and heterogeneous networks: Lustre can utilize RDMA over low latency networks such as Infiniband or Intel OmniPath in addition to supporting TCP over commodity networks. The Lustre networking layer provides the ability to route traffic between multiple networks making it feasible to run a single site-wide Lustre file system.</li>
</ul>
<blockquote>
<p>&#x5F02;&#x6784;&#x7F51;&#x7EDC;&#x548C;&#x9AD8;&#x6027;&#x80FD;&#x7F51;&#x7EDC;&#xFF1A;Lustre &#x4E0D;&#x4EC5;&#x652F;&#x6301;&#x5728;&#x4F4E;&#x5EF6;&#x65F6;&#x7684; IB &#x548C; OmniPath &#x7F51;&#x7EDC;&#x4F7F;&#x7528; RDMA&#xFF0C;&#x4E5F;&#x652F;&#x6301;&#x666E;&#x901A;&#x7684; TCP &#x7F51;&#x7EDC;&#x3002;Lustre &#x7684;&#x7F51;&#x7EDC;&#x5C42;&#x9002;&#x914D;&#x4E0D;&#x540C;&#x7F51;&#x7EDC;&#xFF0C;&#x6240;&#x4EE5;&#x5728;&#x4E0D;&#x540C;&#x7F51;&#x7EDC;&#x73AF;&#x5883;&#x4E2D;&#x53EF;&#x4EE5;&#x90E8;&#x7F72;&#x4E00;&#x5957; Lustre &#x7CFB;&#x7EDF;&#x3002;</p>
</blockquote>
<ul>
<li>High-availability: Lustre supports active/active failover of storage resources and multiple mount protection (MMP) to guard against errors that may results from mounting the storage simultaneously on multiple servers. High availability software such as Pacemaker/Corosync can be used to provide automatic failover capabilities.</li>
</ul>
<blockquote>
<p>&#x9AD8;&#x53EF;&#x7528;&#x6027;&#xFF1A;&#x63D0;&#x4F9B; active/active &#x5B58;&#x50A8;&#x8D44;&#x6E90;&#x7684; failover &#x673A;&#x5236;&#x548C; MMP &#x673A;&#x5236;&#xFF0C;&#x9632;&#x6B62;&#x4E0D;&#x540C;&#x670D;&#x52A1;&#x5668;&#x540C;&#x65F6;&#x6302;&#x8F7D;&#x540C;&#x4E00;&#x4E2A;&#x5B58;&#x50A8;&#x4ECB;&#x8D28;&#x7684;&#x95EE;&#x9898;&#x3002;Pcs &#x7B49;&#x9AD8;&#x53EF;&#x7528;&#x8F6F;&#x4EF6;&#x63D0;&#x4F9B;&#x81EA;&#x52A8;&#x6302;&#x8F7D;&#x7684;&#x6545;&#x969C;&#x6062;&#x590D;&#x529F;&#x80FD;&#x3002;</p>
</blockquote>
<ul>
<li><p>Security features: Lustre follows the normal UNIX file system security model enhanced with POSIX ACLs. The root squash feature limits the ability of Lustre clients to perform privileged operations. Lustre also supports the configuration of Shared-Secret Key (SSK) security.</p>
</li>
<li><p>&#x6570;&#x636E;&#x5B89;&#x5168;&#xFF1A;Lustre &#x9075;&#x5FAA; UNIX &#x6587;&#x4EF6;&#x5B89;&#x5168;&#x6807;&#x51C6;&#xFF1A;ACLs&#x3002;root squash &#x7279;&#x6027;&#x9650;&#x5236;&#x5BA2;&#x6237;&#x7AEF;&#x6267;&#x884C;&#x7279;&#x6743;&#x64CD;&#x4F5C;&#x3002;Lustre &#x4E5F;&#x652F;&#x6301; SSK&#x3002;</p>
</li>
<li><p>Capacity growth: File system capacity can be increased by adding additional storage for data and metadata while the file system in online.</p>
</li>
<li><p>&#x5BB9;&#x91CF;&#x6269;&#x5BB9;&#xFF1A;&#x5728;&#x7EBF;&#x6269;&#x5BB9;&#x3002;&#x901A;&#x8FC7;&#x589E;&#x52A0;&#x5B58;&#x50A8;&#x7684;&#x65B9;&#x5F0F;&#x589E;&#x52A0;&#x6570;&#x636E;&#x6216;&#x5143;&#x6570;&#x636E;&#x7684;&#x5BB9;&#x91CF;&#x3002;</p>
</li>
</ul>
<h2 id="lustre-components"><a name="lustre-components" class="plugin-anchor" href="#lustre-components"><i class="fa fa-link" aria-hidden="true"></i></a>Lustre Components</h2>
<p>Lustre is an object-based file system that consists of several components:</p>
<blockquote>
<p>Lustre &#x662F;&#x4E00;&#x4E2A;&#x57FA;&#x4E8E;&#x5BF9;&#x8C61;&#x7684;&#x5B58;&#x50A8;&#xFF0C;&#x5305;&#x542B;&#x4EE5;&#x4E0B;&#x51E0;&#x4E2A;&#x7EC4;&#x4EF6;&#xFF1A;</p>
</blockquote>
<ul>
<li>Management Server (MGS) - Provides configuration information for the file system. When mounting the file system, the Lustre clients will contact the MGS to retrieve details on how the file system is configured (what servers are part of the file system, failover information, etc.). The MGS can also proactively notify clients about changes in the file system configuration and plays a role in the Lustre recovery process.</li>
</ul>
<blockquote>
<p>&#x7BA1;&#x7406;&#x670D;&#x52A1;&#x5668;&#xFF08;MGS&#xFF09;&#xFF1A;&#x63D0;&#x4F9B;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;&#x914D;&#x7F6E;&#x4FE1;&#x606F;&#x3002;Lustre &#x5BA2;&#x6237;&#x7AEF;&#x6302;&#x8F7D;&#x65F6;&#xFF0C;&#x4F1A;&#x548C; MGS &#x8BF7;&#x6C42;&#x68C0;&#x7D22;&#x8BE6;&#x7EC6;&#x7684;&#x914D;&#x7F6E;&#x4FE1;&#x606F;&#xFF0C;&#x5982;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x4E2D;&#x670D;&#x52A1;&#x5668;&#x90E8;&#x5206;&#xFF0C;&#x6545;&#x969C;&#x5BF9;&#x4FE1;&#x606F;&#x7B49;&#x7B49;&#x3002;&#x5F53;&#x914D;&#x7F6E;&#x66F4;&#x6539;&#x65F6;&#xFF0C;MGS &#x4E3B;&#x52A8;&#x901A;&#x77E5;&#x5BA2;&#x6237;&#x7AEF;&#x3002;&#x53E6;&#x5916;&#x62C5;&#x4EFB;&#x6062;&#x590D;&#x5904;&#x7406;&#x7684;&#x89D2;&#x8272;&#x3002;</p>
</blockquote>
<ul>
<li>Management Target (MGT) - Block device used by the MGS to persistently store Lustre file system configuration information. It typically only requires a relatively small amount of space (on the order to 100 MB).</li>
</ul>
<blockquote>
<p>&#x7BA1;&#x7406;&#x5668;&#x76EE;&#x6807;&#xFF08;MGT&#xFF09;&#xFF1A;MGS &#x5B58;&#x50A8; Lustre &#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x914D;&#x7F6E;&#x4FE1;&#x606F;&#x7684;&#x5757;&#x8BBE;&#x5907;&#x3002;&#x5BB9;&#x91CF;&#x9700;&#x6C42;&#x4E0D;&#x5927;&#xFF0C;&#x4E00;&#x822C;&#x4E3A;100MB&#x3002;</p>
</blockquote>
<ul>
<li>Metadata Server (MDS) - Manages the file system namespace and provides metadata services to clients such as filename lookup, directory information, file layouts, and access permissions. The file system will contain at least one MDS but may contain more.</li>
</ul>
<blockquote>
<p>&#x5143;&#x6570;&#x636E;&#x670D;&#x52A1;&#x5668;&#xFF08;MDS&#xFF09;&#xFF1A;&#x7BA1;&#x7406;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x547D;&#x540D;&#x7A7A;&#x95F4;&#x548C;&#x63D0;&#x4F9B;&#x5143;&#x6570;&#x636E;&#x670D;&#x52A1;&#xFF0C;&#x4F8B;&#x5982;&#x67E5;&#x627E;&#x6587;&#x4EF6;&#x540D;&#xFF0C;&#x76EE;&#x5F55;&#x4FE1;&#x606F;&#xFF0C;&#x6587;&#x4EF6;&#x5E03;&#x5C40;&#x548C;&#x8BBF;&#x95EE;&#x6743;&#x9650;&#x3002;Lustre &#x81F3;&#x5C11;&#x5305;&#x542B;&#x4E00;&#x4E2A; MDS&#x3002;</p>
</blockquote>
<ul>
<li>Metadata Target (MDT) - Block device used by an MDS to store metadata information. A Lustre file system will contain at least one MDT which holds the root of the file system, but it may contain multiple MDTs. Common configurations will use one MDT per MDS server, but it is possible for an MDS to host multiple MDTs. MDTs can be shared among multiple MDSs to support failover, but each MDT can only be mounted by one MDS at any given time.</li>
</ul>
<blockquote>
<p>&#x5143;&#x6570;&#x636E;&#x76EE;&#x6807;&#xFF08;MDT&#xFF09;&#xFF1A;MDS &#x5B58;&#x50A8;&#x5143;&#x6570;&#x636E;&#x7684;&#x5757;&#x8BBE;&#x5907;&#x3002;Lustre &#x81F3;&#x5C11;&#x5305;&#x542B;&#x4E00;&#x4E2A; MDT &#x63D0;&#x4F9B;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;&#x6839;&#x3002;&#x4E00;&#x822C;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x6BCF;&#x4E2A; MDS &#x4E0A;&#x914D;&#x7F6E;&#x4E00;&#x4E2A; MDT&#xFF0C;&#x4F46;&#x4E5F;&#x6709;&#x53EF;&#x80FD;&#x4E00;&#x4E2A; MDS &#x5305;&#x542B;&#x591A;&#x4E2A; MDT&#x3002;&#x6545;&#x969C;&#x5BF9;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x591A;&#x4E2A; MDS &#x5171;&#x4EAB;&#x540C;&#x4E00;&#x4E2A; MDT&#x7684;&#x65B9;&#x5F0F;&#x5B9E;&#x73B0;&#xFF0C;&#x4F46;&#x5728;&#x540C;&#x4E00;&#x4E2A;&#x65F6;&#x523B;&#xFF0C;&#x4E00;&#x4E2A; MDT &#x53EA;&#x80FD;&#x88AB;&#x4E00;&#x4E2A; MDS &#x6302;&#x8F7D;&#x3002;</p>
</blockquote>
<ul>
<li>Object Storage Server (OSS) - Stores file data objects and makes the file contents available to Lustre clients. A file system will typically have many OSS nodes to provide a higher aggregate capacity and network bandwidth.</li>
</ul>
<blockquote>
<p>&#x5BF9;&#x8C61;&#x5B58;&#x50A8;&#x670D;&#x52A1;&#x5668;&#xFF1A;&#x5B58;&#x50A8;&#x6587;&#x4EF6;&#x6570;&#x636E;&#x5BF9;&#x8C61;&#xFF0C;&#x63D0;&#x4F9B;&#x6587;&#x4EF6;&#x6570;&#x636E;&#x7684;&#x8BBF;&#x95EE;&#x7ED9;&#x5BA2;&#x6237;&#x7AEF;&#x3002;&#x901A;&#x5E38; Lustre &#x4F1A;&#x914D;&#x7F6E;&#x591A;&#x4E2A; OSS &#x6765;&#x589E;&#x52A0;&#x5BB9;&#x91CF;&#x548C;&#x63D0;&#x9AD8;&#x7F51;&#x7EDC;&#x5E26;&#x5BBD;&#x3002;</p>
</blockquote>
<ul>
<li>Object Storage Target (OST) - Block device used by an OSS node to store the contents of user files. An OSS node will often host several OSTs. These OSTs may be shared among multiple hosts, but just like MDTs, each OST can only be mounted on a single OSS at any given time. The total capacity of the file system is the sum of all the individual OST capacities.</li>
</ul>
<blockquote>
<p>&#x5BF9;&#x8C61;&#x5B58;&#x50A8;&#x76EE;&#x5F55;&#xFF1A;OSS &#x5B58;&#x50A8;&#x7528;&#x6237;&#x6587;&#x4EF6;&#x6570;&#x636E;&#x7684;&#x5757;&#x8BBE;&#x5907;&#x3002;OSS &#x8282;&#x70B9;&#x6302;&#x8F7D;&#x591A;&#x4E2A; OST&#xFF0C;&#x53E6;&#x5916;&#xFF0C;&#x6BCF;&#x4E00;&#x4E2A; OST &#x4E5F;&#x88AB;&#x591A;&#x4E2A; OSS &#x5171;&#x4EAB;&#x3002;&#x548C; MDT &#x76F8;&#x540C;&#xFF0C;&#x540C;&#x4E00;&#x65F6;&#x523B;&#xFF0C;&#x6BCF;&#x4E2A; OST &#x53EA;&#x80FD;&#x88AB;&#x4E00;&#x4E2A; OSS &#x6302;&#x8F7D;&#x3002;Lustre &#x7CFB;&#x7EDF;&#x7684;&#x603B;&#x5BB9;&#x91CF;&#x4E3A;&#x6240;&#x6709; OST &#x5BB9;&#x91CF;&#x4E4B;&#x548C;&#x3002;</p>
</blockquote>
<ul>
<li>Lustre Client - Mounts the Lustre file system and makes the contents of the namespace visible to the users. There may be hundreds or even thousands of clients accessing a single Lustre file system. Each client can also mount more than one Lustre file system at a time.</li>
</ul>
<blockquote>
<p>Lustre &#x5BA2;&#x6237;&#x7AEF;&#xFF1A;&#x6302;&#x8F7D; Lustre &#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF0C;&#x63D0;&#x4F9B;&#x7ED9;&#x7528;&#x6237;&#x7EDF;&#x4E00;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x547D;&#x540D;&#x7A7A;&#x95F4;&#x3002;Lustre &#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x53EF;&#x4EE5;&#x540C;&#x65F6;&#x5B58;&#x5728;&#x6210;&#x767E;&#x4E0A;&#x5343;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x3002;&#x53E6;&#x5916;&#xFF0C;&#x5BA2;&#x6237;&#x7AEF;&#x4E5F;&#x53EF;&#x4EE5;&#x540C;&#x65F6;&#x6302;&#x8F7D;&#x4E0D;&#x540C;&#x7684; Lustre &#x7CFB;&#x7EDF;&#x3002;</p>
</blockquote>
<ul>
<li>Lustre Networking (LNet) - Network protocol used for communication between Lustre clients and servers. Supports RDMA on low-latency networks and routing between heterogeneous networks.</li>
</ul>
<blockquote>
<p>Lustre &#x7F51;&#x7EDC;&#xFF08;LNet&#xFF09;&#xFF1A;LNet &#x7528;&#x4E8E;&#x5BA2;&#x6237;&#x7AEF;&#x548C;&#x670D;&#x52A1;&#x7AEF;&#x4E4B;&#x95F4;&#x7684;&#x901A;&#x4FE1;&#xFF0C;&#x652F;&#x6301;&#x5728;&#x5F02;&#x6784;&#x7684;&#x4F4E;&#x5EF6;&#x65F6;&#x7F51;&#x7EDC;&#x548C;&#x8DEF;&#x7531;&#x4E0A;&#x4F7F;&#x7528; RDMA&#x3002;</p>
</blockquote>
<p>The collection of MGS, MDS, and OSS nodes are sometimes referred to as the &#x201C;frontend&#x201D;. The individual OSTs and MDTs must be formatted with a local file system in order for Lustre to store data and metadata on those block devices. Currently, only ldiskfs (a modified version of ext4) and ZFS are supported for this purpose. The choice of ldiskfs or ZFS if often referred to as the &#x201C;backend file system&#x201D;. Lustre provides an abstraction layer for these backend file systems to allow for the possibility of including other types of backend file systems in the future.</p>
<blockquote>
<p>MGS&#x3001;MDS &#x548C; OSS &#x8282;&#x70B9;&#x88AB;&#x79F0;&#x4E3A;&#x201C;&#x524D;&#x7AEF;&#x201D;&#xFF0C;ldiskfs &#x6216; ZFS &#x79F0;&#x4E3A;&#x201C;&#x540E;&#x7AEF;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x201D;&#x3002;&#x5728; Lustre &#x4E2D;&#xFF0C;OST &#x548C; MDT &#x5BF9;&#x5E94;&#x7684;&#x5757;&#x8BBE;&#x5907;&#x5FC5;&#x987B;&#x683C;&#x5F0F;&#x5316;&#x4E3A;&#x672C;&#x5730;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF1A;ldiskfs&#xFF08;ext4 &#x7684;&#x4FEE;&#x6539;&#x7248;&#xFF09; &#x6216; ZFS&#xFF0C;&#x4EE5;&#x7528;&#x4E8E;&#x5B58;&#x653E;&#x6570;&#x636E;&#x3002;Lustre &#x4E3A;&#x4E0D;&#x540C;&#x7684;&#x540E;&#x7AEF;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x63D0;&#x4F9B;&#x4E00;&#x4E2A;&#x62BD;&#x8C61;&#x5C42;&#x3002;&#x672A;&#x6765;&#x4E5F;&#x652F;&#x6301;&#x5176;&#x4ED6;&#x7684;&#x7C7B;&#x578B;&#x7684;&#x540E;&#x7AEF;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF08;&#x57FA;&#x672C;&#x6CA1;&#x52A8;&#x529B;&#x7684;&#xFF09;&#x3002;</p>
</blockquote>
<p>Figure 1 shows a simplified version of the Lustre file system components in a basic cluster. In this figure, the MGS server is distinct from the MDS servers, but for small file systems, the MGS and MDS may be combined into a single server and the MGT may coexist on the same block device as the primary MDT.</p>
<blockquote>
<p>&#x56FE;1&#x5C55;&#x793A;&#x4E00;&#x4E2A;&#x7B80;&#x5316;&#x7684; Lustre &#x7EC4;&#x4EF6;&#x56FE;&#x3002;&#x5728;&#x8FD9;&#x5F20;&#x56FE;&#x4E2D;&#xFF0C;MGS &#x548C; MDS &#x5728;&#x4E0D;&#x540C;&#x7684;&#x670D;&#x52A1;&#x5668;&#x4E0A;&#x3002;&#x4E0D;&#x8FC7;&#x5728;&#x5C0F;&#x578B;&#x7684; Lustre&#x96C6;&#x7FA4;&#x4E0A;&#xFF0C;MGS &#x548C; MDS &#x4F7F;&#x7528;&#x540C;&#x4E00;&#x4E2A;&#x5757;&#x8BBE;&#x5907;&#x4F5C;&#x4E3A; MGT &#x548C; MDT&#x3002;</p>
</blockquote>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/Lustre_components.png" alt="Figure 1. Lustre file system components in a basic cluster.">
    <figcaption style="font-size:12px">Figure 1. Lustre file system components in a basic cluster.</figcaption>
</div>

<h2 id="lustre-file-layouts"><a name="lustre-file-layouts" class="plugin-anchor" href="#lustre-file-layouts"><i class="fa fa-link" aria-hidden="true"></i></a>Lustre File Layouts</h2>
<p>Lustre stores file data by splitting the file contents into chunks and then storing those chunks across the storage targets. By spreading the file across multiple targets, the file size can exceed the capacity of any one storage target. It also allows clients to access parts of the file from multiple Lustre servers simultaneously, effectively scaling up the bandwidth of the file system. Users have the ability to control many aspects of the file&#x2019;s layout by means of the lfs setstripe command, and they can query the layout for an existing file using the lfs getstripe command.</p>
<p>File layouts fall into one of two categories:</p>
<ol>
<li><p>Normal / RAID0 - File data is striped across multiple OSTs in a round-robin manner.</p>
</li>
<li><p>Composite - Complex layouts that involve several components with potentially different striping patterns.</p>
</li>
</ol>
<h3 id="normal-raid0-layouts"><a name="normal-raid0-layouts" class="plugin-anchor" href="#normal-raid0-layouts"><i class="fa fa-link" aria-hidden="true"></i></a>Normal (RAID0) Layouts</h3>
<p>A normal layout is characterized by a stripe count and a stripe size. The stripe count determines how many OSTs will be used to store the file data, while the stripe size determines how much data will be written to an OST before moving to the next OST in the layout. As an example, consider the file layouts shown in Figure 2 for a simple file system with 3 OSTs residing on 3 different OSS nodes. Note that Lustre indexes the OSTs starting at zero.</p>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/File_striping.png" alt="Figure 2. Normal RAID0 file striping in Lustre.">
    <figcaption style="font-size:12px">Figure 2. Normal RAID0 file striping in Lustre.</figcaption>
</div>

<p>File A has a stripe count of three, so it will utilize all OSTs in the file system. We will assume that it uses the default Lustre stripe size of 1MB. When File A is written, the first 1MB chunk gets written to OST0. Lustre then writes the second 1MB chunk of the file to OST1 and the third chunk to OST2. When the file exceeds 3 MB in size, Lustre will round-robin back to the first allocated OST and write the fourth 1MB chunk to OST0, followed by OST1, etc. This illustrates how Lustre writes data in a RAID0 manner for a file. It should be noted that although File A has three chunks of data on OST0 (chunks #1, #4, and #7), all these chunks reside in a single object on the backend file system. From Lustre&#x2019;s point of view, File A consists of three objects, one per OST. Files B and C show layouts with the default Lustre stripe count of one, but only File B uses the default stripe size of 1MB. The layout for File C has been modified to use a larger stripe size of 2MB. If both File B and File C are 2MB in size, File B will be treated as two consecutive chunks written to the same OST whereas File C will be treated as a single chunk. However, this difference is mostly irrelevant since both files will still consist of a single 2MB object on their respective OSTs.</p>
<h1 id="test"><a name="test" class="plugin-anchor" href="#test"><i class="fa fa-link" aria-hidden="true"></i></a>TEST</h1>
<p>&#x7565;</p>
<h1 id="utils"><a name="utils" class="plugin-anchor" href="#utils"><i class="fa fa-link" aria-hidden="true"></i></a>UTILS</h1>
<p>&#x7565;</p>
<h1 id="mgc"><a name="mgc" class="plugin-anchor" href="#mgc"><i class="fa fa-link" aria-hidden="true"></i></a>MGC</h1>
<h2 id="mgc-introduction"><a name="mgc-introduction" class="plugin-anchor" href="#mgc-introduction"><i class="fa fa-link" aria-hidden="true"></i></a>Introduction</h2>

<p>The Lustre client software involves primarily three components, management client (MGC), a metadata client (MDC), and multiple object storage clients (OSCs), one corresponding to each OST in the file system. Among this, the management client acts as an interface between Lustre virtual file system layer and Lustre management server (MGS). MGS stores and provides information about all Lustre file systems in a cluster. Lustre targets register with MGS to provide information to MGS while Lustre clients contact MGS to retrieve information from it.</p>
<blockquote>
<p>Lustre &#x5BA2;&#x6237;&#x7AEF;&#x8F6F;&#x4EF6;&#x4E3B;&#x8981;&#x6D89;&#x53CA;&#x4E09;&#x4E2A;&#x7EC4;&#x4EF6;&#xFF0C;&#x7BA1;&#x7406;&#x5BA2;&#x6237;&#x7AEF;&#xFF08;MGC&#xFF09;&#x3001;&#x5143;&#x6570;&#x636E;&#x5BA2;&#x6237;&#x7AEF;&#xFF08;MDC&#xFF09;&#x548C;&#x591A;&#x4E2A;&#x5BF9;&#x8C61;&#x5B58;&#x50A8;&#x5BA2;&#x6237;&#x7AEF;&#xFF08;OSC&#xFF09;<sup><a href="#fn_1" id="reffn_1">1</a></sup>&#xFF0C;&#x6BCF;&#x4E2A; OSC &#x5BF9;&#x5E94;&#x4E00;&#x4E2A; OST&#x3002; MGC &#x8FDE;&#x63A5;&#x4E86; Lustre &#x865A;&#x62DF;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x5C42;&#x4E0E; Lustre &#x7BA1;&#x7406;&#x670D;&#x52A1;&#x5668;&#xFF08;MGS&#xFF09;&#x3002;MGS &#x5B58;&#x50A8;&#x5E76;&#x63D0;&#x4F9B;&#x6709;&#x5173;&#x96C6;&#x7FA4;&#x4E2D;&#x6240;&#x6709; Lustre &#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;&#x914D;&#x7F6E;&#x4FE1;&#x606F;&#x3002;Lustre &#x76EE;&#x6807;&#x901A;&#x8FC7;&#x5411; MGS &#x6CE8;&#x518C;&#x7684;&#x65B9;&#x5F0F;&#x5411; MGS &#x63D0;&#x4F9B;&#x4FE1;&#x606F;&#xFF0C;&#x800C; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x5411; MGS &#x83B7;&#x53D6;&#x914D;&#x7F6E;&#x4FE1;&#x606F;&#x3002;</p>
</blockquote>
<p>The major functionalities of MGC are Lustre log handling, Lustre distributed lock management and file system setup. MGC is the first obd device created in Lustre obd device life cycle. An obd device in Lustre provides a level of abstraction on Lustre components such that generic operations can be applied without knowing the specific devices you are dealing with. The remaining Sections describe MGC module initialization, various MGC obd operations and log handling in detail. In the following Sections we will be using the terms clients and servers to represent service clients and servers created to communicate between various components in Lustre. Whereas the physical nodes representing Lustre&#x2019;s clients and servers will be explicitly mentioned as &#x2018;Lustre clients&#x2019; and &#x2018;Lustre servers&#x2019;.</p>
<blockquote>
<p>MGC &#x7684;&#x4E3B;&#x8981;&#x529F;&#x80FD;&#x5305;&#x62EC; Lustre &#x65E5;&#x5FD7;&#x5904;&#x7406;&#x3001;Lustre &#x5206;&#x5E03;&#x5F0F;&#x9501;&#x7BA1;&#x7406;&#x548C;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;&#x521D;&#x59CB;&#x5316;&#x3002;MGC &#x662F;&#x5728; Lustre obd &#x8BBE;&#x5907;&#x751F;&#x547D;&#x5468;&#x671F;&#x4E2D;&#x7B2C;&#x4E00;&#x4E2A;&#x88AB;&#x521B;&#x5EFA;&#x7684; obd &#x8BBE;&#x5907;<sup><a href="#fn_2" id="reffn_2">2</a></sup>&#x3002;Lustre &#x4E2D;&#x7684; obd &#x8BBE;&#x5907;&#x4E3A; Lustre &#x7EC4;&#x4EF6;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x5C42;&#x62BD;&#x8C61;&#xFF0C;&#x4F7F;&#x5F97;&#x7EC4;&#x4EF6;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x901A;&#x7528;&#x64CD;&#x4F5C;&#xFF0C;&#x800C;&#x65E0;&#x9700;&#x4E86;&#x89E3;&#x6B63;&#x5728;&#x5904;&#x7406;&#x7684;&#x5177;&#x4F53;&#x8BBE;&#x5907;&#x3002;&#x5176;&#x4F59;&#x90E8;&#x5206;&#x8BE6;&#x7EC6;&#x63CF;&#x8FF0;&#x4E86; MGC &#x6A21;&#x5757;&#x7684;&#x521D;&#x59CB;&#x5316;&#x3001;&#x5404;&#x79CD; MGC obd &#x64CD;&#x4F5C;&#x4EE5;&#x53CA;&#x65E5;&#x5FD7;&#x5904;&#x7406;&#x3002;&#x5728;&#x63A5;&#x4E0B;&#x6765;&#x7684;&#x90E8;&#x5206;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x4F7F;&#x7528;&quot;clients&quot;&#x548C;&quot;servers&quot;&#x8FD9;&#x4E9B;&#x672F;&#x8BED;&#x6765;&#x4EE3;&#x8868;&#x4E3A;&#x4E86;&#x5728; Lustre &#x7684;&#x5404;&#x4E2A;&#x7EC4;&#x4EF6;&#x4E4B;&#x95F4;&#x8FDB;&#x884C;&#x901A;&#x4FE1;&#x800C;&#x88AB;&#x521B;&#x5EFA;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x548C;&#x670D;&#x52A1;&#x7AEF;&#x7684;&#x670D;&#x52A1;&#x3002;&#x800C;&#x8868;&#x793A;Lustre&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x548C;&#x670D;&#x52A1;&#x7AEF;&#x7684;&#x7269;&#x7406;&#x8282;&#x70B9;&#x5C06;&#x660E;&#x786E;&#x6807;&#x6CE8;&#x4E3A;&quot;Lustre clients&quot;&#x548C;&quot;Lustre servers&quot;&#x3002;</p>
</blockquote>
<h2 id="mgc-module-initialization"><a name="mgc-module-initialization" class="plugin-anchor" href="#mgc-module-initialization"><i class="fa fa-link" aria-hidden="true"></i></a>MGC Module Initialization</h2>
<p>When the MGC module initializes, it registers MGC as an obd device type with Lustre using class_register_type() as shown in Source Code 1. Obd device data and metadata operations are defined using the obd_ops and md_ops structures respectively. Since MGC deals with metadata in Lustre, it has only obd_ops operations defined. However the metadata client (MDC) has both metadata and data operations defined since the data operations are used to implement Data on Metadata (DoM) functionality in Lustre. The class_register_type() function passes &amp;mgc_obd_ops, NULL, false, LUSTRE_MGC _NAME, and NULL as its arguments. LUSTRE_MGC_NAME is defined as &#x201C;mgc&#x201D; in include/obd.h.</p>
<blockquote>
<p>&#x5F53; MGC &#x6A21;&#x5757;&#x521D;&#x59CB;&#x5316;&#x65F6;&#xFF0C;&#x5B83;&#x4F7F;&#x7528; class_register_type() &#x5C06; MGC &#x6CE8;&#x518C;&#x4E3A;&#x4E00;&#x79CD; obd &#x8BBE;&#x5907;&#x7C7B;&#x578B;&#xFF0C;&#x5982;&#x6E90;&#x4EE3;&#x7801;1&#x6240;&#x793A;&#x3002;obd_ops &#x548C; md_ops &#x7ED3;&#x6784;&#x5206;&#x522B;&#x5B9A;&#x4E49;&#x4E86; obd &#x8BBE;&#x5907;&#x7684;&#x6570;&#x636E;&#x548C;&#x5143;&#x6570;&#x636E;&#x64CD;&#x4F5C;&#x3002;&#x7531;&#x4E8E; MGC &#x53EA;&#x5904;&#x7406;Lustre&#x4E2D;&#x7684;&#x5143;&#x6570;&#x636E;&#xFF0C;&#x53EA;&#x5B9A;&#x4E49;&#x4E86;obd_ops&#x64CD;&#x4F5C;&#x3002;&#x7136;&#x800C;&#xFF0C;&#x5143;&#x6570;&#x636E;&#x5BA2;&#x6237;&#x7AEF;&#xFF08;MDC&#xFF09;&#x65E2;&#x6709;&#x5143;&#x6570;&#x636E;&#x64CD;&#x4F5C;&#xFF0C;&#x53C8;&#x6709;&#x6570;&#x636E;&#x64CD;&#x4F5C;&#xFF0C;&#x56E0;&#x4E3A;&#x6570;&#x636E;&#x64CD;&#x4F5C;&#x7528;&#x4E8E;&#x5B9E;&#x73B0; Lustre &#x4E2D;DoM &#x529F;&#x80FD;&#x3002;class_register_type() &#x7684;&#x53C2;&#x6570;&#x4E3A; &amp;mgc_obd_ops&#x3001;NULL&#x3001;false&#x3001;LUSTRE_MGC_NAME &#x548C; NULL&#x3002;&#x5728; include/obd.h &#x4E2D;&#xFF0C;LUSTRE_MGC_NAME &#x88AB;&#x5B9A;&#x4E49;&#x4E3A;&quot;mgc&quot;&#x3002;</p>
</blockquote>
<h2 id="mgc-obd-operations"><a name="mgc-obd-operations" class="plugin-anchor" href="#mgc-obd-operations"><i class="fa fa-link" aria-hidden="true"></i></a>MGC obd Operations</h2>
<p>MGC obd operations are defined by mgc_obd_ops structure as shown in Source Code 2. Note that all MGC obd operations are defined as function pointers. This type of programming style avoids complex switch cases and provides a level of abstraction on Lustre components such that the generic operations can be applied without knowing the details of specific obd devices.</p>
<blockquote>
<p>MGC obd &#x64CD;&#x4F5C;&#x7531; mgc_obd_ops &#x7ED3;&#x6784;&#x5B9A;&#x4E49;&#xFF0C;&#x5982;&#x6E90;&#x4EE3;&#x7801;2&#x6240;&#x793A;&#x3002;&#x8BF7;&#x6CE8;&#x610F;&#xFF0C;&#x6240;&#x6709; MGC obd &#x64CD;&#x4F5C;&#x90FD;&#x88AB;&#x5B9A;&#x4E49;&#x4E3A;&#x51FD;&#x6570;&#x6307;&#x9488;&#x3002;&#x8FD9;&#x79CD;&#x7F16;&#x7A0B;&#x98CE;&#x683C;&#x907F;&#x514D;&#x4E86;&#x590D;&#x6742;&#x7684; switch &#x8BED;&#x53E5;&#xFF0C;&#x5E76;&#x4E3A; Lustre &#x7EC4;&#x4EF6;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x5C42;&#x62BD;&#x8C61;&#xFF0C;&#x4F7F;&#x5F97;&#x53EF;&#x4EE5;&#x8FDB;&#x884C;&#x901A;&#x7528;&#x64CD;&#x4F5C;&#xFF0C;&#x800C;&#x65E0;&#x9700;&#x4E86;&#x89E3;&#x7279;&#x5B9A; obd &#x8BBE;&#x5907;&#x7684;&#x8BE6;&#x7EC6;&#x4FE1;&#x606F;&#x3002;</p>
</blockquote>
<p>Source Code 2: mgc_obd_ops structure defined in mgc/mgc_request.c</p>
<pre><code class="lang-c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> obd_ops mgc_obd_ops = {
        .o_owner        = THIS_MODULE,
        .o_setup        = mgc_setup,
        .o_precleanup   = mgc_precleanup,
        .o_cleanup      = mgc_cleanup,
        .o_add_conn     = client_import_add_conn,
        .o_del_conn     = client_import_del_conn,
        .o_connect      = client_connect_import,
        .o_disconnect   = client_disconnect_export,
        .o_set_info_async = mgc_set_info_async,
        .o_get_info       = mgc_get_info,
        .o_import_event = mgc_import_event,
        .o_process_config = mgc_process_config,
};
</code></pre>
<p>In Lustre one of the ways two subsystems share data is with the help of obd_ops structure. To understand how the communication between two subsystems work let us take an example of mgc_get_info() from the mgc_obd_ops structure. The subsystem llite makes a call to mgc_get_info() (in llite/llite_lib.c) by passing a key (KEY_CONN_DATA) as an argument. But notice that llite invokes obd_get_info() instead of mgc_get_info(). obd_get_info() is defined in include/obd_class.h as shown in Figure 6. We can see that this function invokes an OBP macro by passing an obd_export device structure and a get_info operation. The definition of this macro concatenates o with op (operation) so that the resulting function call becomes o_get_info().</p>
<blockquote>
<p>&#x5728; Lustre &#x4E2D;&#xFF0C;&#x4E24;&#x4E2A;&#x5B50;&#x7CFB;&#x7EDF;&#x4E4B;&#x95F4;&#x5171;&#x4EAB;&#x6570;&#x636E;&#x7684;&#x4E00;&#x79CD;&#x65B9;&#x5F0F;&#x662F;&#x901A;&#x8FC7; obd_ops &#x7ED3;&#x6784;&#x3002;&#x4E3A;&#x4E86;&#x7406;&#x89E3;&#x4E24;&#x4E2A;&#x5B50;&#x7CFB;&#x7EDF;&#x4E4B;&#x95F4;&#x7684;&#x901A;&#x4FE1;&#x662F;&#x5982;&#x4F55;&#x5DE5;&#x4F5C;&#x7684;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x4EE5; mgc_obd_ops &#x7ED3;&#x6784;&#x4E2D;&#x7684; mgc_get_info() &#x4E3A;&#x4F8B;&#x3002;&#x5B50;&#x7CFB;&#x7EDF; llite &#x901A;&#x8FC7;&#x5C06;&#x4E00;&#x4E2A;&#x5B8F;&#xFF08;KEY_CONN_DATA&#xFF09;&#x4F5C;&#x4E3A;&#x53C2;&#x6570;&#x8C03;&#x7528; mgc_get_info()&#xFF08;llite/llite_lib.c&#xFF09;&#x3002;&#x6CE8;&#x610F;&#xFF0C;llite &#x8C03;&#x7528;&#x7684;&#x662F; obd_get_info() &#x800C;&#x4E0D;&#x662F;&#x76F4;&#x63A5;&#x8C03;&#x7528; mgc_get_info()&#x3002;obd_get_info()&#xFF08;include/obd_class.h&#xFF09;&#xFF0C;&#x5982;&#x56FE;6&#x6240;&#x793A;&#x3002;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#xFF0C;&#x51FD;&#x6570;&#x8C03;&#x7528;&#x4E00;&#x4E2A; OBP &#x5B8F;&#xFF0C;&#x5B83;&#x7684;&#x53C2;&#x6570;&#x662F; obd_export &#x548C; get_info&#x3002;OBP &#x5B8F;&#x5C06; o&#xFF08;obd_export &#x8BBE;&#x5907;&#x7ED3;&#x6784;&#xFF09;&#x548C; op&#xFF08;&#x64CD;&#x4F5C;&#xFF09;&#x8FDE;&#x63A5;&#x5728;&#x4E00;&#x8D77;&#xFF0C;&#x5B8F;&#x66FF;&#x6362;&#x4E3A;&#x51FD;&#x6570;&#x8C03;&#x7528; o_get_info()&#x3002;</p>
</blockquote>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/Mgc_llite_comm_1.png" alt="Figure 6. Communication between llite and mgc through obdclass.">
    <figcaption style="font-size:12px">Figure 6. Communication between llite and mgc through obdclass.</figcaption>
</div>

<p>So how does llite make sure that this operation is directed specifically towards MGC obd device? obd_get_info() from llite/llite_lib.c has an argument called sbi-&gt;ll_md_exp. The sbi structure is a type of ll_sb_info defined in llite/llite_internal.h (refer Figure 7). And the ll_md_exp field from ll_sb_info is a type of obd_export structure defined in include/lustre_export.h. obd_export structure has a field *exp_obd which is an obd_device structure (defined in include/obd.h). Another MGC obd operation obd_connect() retrieves export using the obd_device structure. Two functions involved in this process are class_name2obd() and class_num2obd() defined in obdclass/genops.c.</p>
<blockquote>
<p>&#x90A3;&#x4E48;&#xFF0C;llite &#x5982;&#x4F55;&#x786E;&#x4FDD;&#x4EE5;&#x4E0A;&#x7684;&#x64CD;&#x4F5C;&#x662F;&#x9488;&#x5BF9; MGC obd &#x8BBE;&#x5907;&#x7684;&#xFF1F;llite/llite_lib.c &#x4E2D;&#x7684; obd_get_info() &#x6709;&#x4E00;&#x4E2A;&#x540D;&#x4E3A; sbi-&gt;ll_md_exp &#x7684;&#x53C2;&#x6570;&#x3002;sbi &#x7684;&#x7C7B;&#x578B;&#x662F; ll_sb_info&#xFF0C;&#x5B83;&#x5728; llite/llite_internal.h &#x4E2D;&#x5B9A;&#x4E49;&#xFF08;&#x56FE;7&#xFF09;&#x3002;&#x800C; ll_sb_info &#x4E2D;&#x7684; ll_md_exp &#x5B57;&#x6BB5;&#x5728; include/lustre_export.h &#x4E2D;&#x5B9A;&#x4E49;&#xFF0C;&#x7C7B;&#x578B;&#x4E3A; obd_export&#x3002;obd_export &#x4E2D;&#x7684; *exp_obd &#x6210;&#x5458;&#xFF0C;&#x5B83;&#x662F;&#x4E00;&#x4E2A; obd_device &#x7ED3;&#x6784;&#xFF08;&#x5728;include/obd.h&#x4E2D;&#x5B9A;&#x4E49;&#xFF09;&#x3002;&#x53E6;&#x4E00;&#x4E2A; MGC obd &#x64CD;&#x4F5C; obd_connect() &#x4F7F;&#x7528;obd_device &#x68C0;&#x67E5;&#x83B7;&#x53D6;&#x5BFC;&#x51FA;&#x9879;&#x3002;&#x53C2;&#x4E0E;&#x6B64;&#x6D41;&#x7A0B;&#x7684;&#x4E24;&#x4E2A;&#x51FD;&#x6570;&#x5206;&#x522B;&#x4E3A; class_name2obd() &#x548C; class_num2obd()&#xFF0C;&#x5B83;&#x4EEC;&#x90FD;&#x5728; obdclass/genops.c &#x4E2D;&#x5B9A;&#x4E49;&#x3002;</p>
</blockquote>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/Mgc_llite_comm_2.png" alt="Figure 7. Data structures involved in the communication between mgc and llite subsystems.">
    <figcaption style="font-size:12px">Figure 7. Data structures involved in the communication between mgc and llite subsystems.</figcaption>
</div>

<p>In the following Sections we describe some of the important MGC obd operations in detail.</p>
<blockquote>
<p>&#x5728;&#x63A5;&#x4E0B;&#x6765;&#x7684;&#x90E8;&#x5206;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x8BE6;&#x7EC6;&#x63CF;&#x8FF0;&#x4E00;&#x4E9B;&#x91CD;&#x8981;&#x7684; MGC obd &#x64CD;&#x4F5C;&#x3002;</p>
</blockquote>
<h2 id="mgcsetup"><a name="mgcsetup" class="plugin-anchor" href="#mgcsetup"><i class="fa fa-link" aria-hidden="true"></i></a>mgc_setup()</h2>
<p>mgc_setup() is the initial routine that gets executed to start and setup the MGC obd device. In Lustre MGC is the first obd device that is being setup as part of the obd device life cycle process. To understand when mgc_setup() gets invoked in the obd device life cycle, let us explore the workflow from the Lustre module initialization.</p>
<blockquote>
<p>mgc_setup() &#x662F;&#x542F;&#x52A8;&#x548C;&#x914D;&#x7F6E; MGC obd &#x8BBE;&#x5907;&#x7684;&#x521D;&#x59CB;&#x5316;&#x51FD;&#x6570;&#x3002;&#x5728; Lustre &#x4E2D;&#xFF0C;&#x4F5C;&#x4E3A; obd &#x8BBE;&#x5907;&#x751F;&#x547D;&#x5468;&#x671F;&#x8FC7;&#x7A0B;&#x7684;&#x4E00;&#x90E8;&#x5206;&#xFF0C;MGC &#x662F;&#x7B2C;&#x4E00;&#x4E2A;&#x8FDB;&#x884C;&#x914D;&#x7F6E;&#x7684; obd &#x8BBE;&#x5907;&#x3002;&#x4E3A;&#x4E86;&#x7406;&#x89E3; mgc_setup() &#x5728; obd &#x8BBE;&#x5907;&#x751F;&#x547D;&#x5468;&#x671F;&#x4E2D;&#x4F55;&#x65F6;&#x88AB;&#x8C03;&#x7528;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x4ECE; Lustre &#x6A21;&#x5757;&#x521D;&#x59CB;&#x5316;&#x7684;&#x5DE5;&#x4F5C;&#x6D41;&#x7A0B;&#x5165;&#x624B;&#x3002;</p>
</blockquote>
<p>The Lustre module initialization begins from the lustre_init() routine defined in llite/super25.c (shown in Figure 8). This routine is invoked when the &#x2018;lustre&#x2019; module gets loaded. lustre_init() invokes register_filesystem(\&amp;lustre_fs_type) which registers &#x2018;lustre&#x2019; as the file system and adds it to the list of file systems the kernel is aware of for mount and other syscalls. lustre_fs_type structure is defined in the same file as shown in Source Code 3.</p>
<blockquote>
<p>Lustre &#x6A21;&#x5757;&#x521D;&#x59CB;&#x5316;&#x4ECE; llite/super25.c&#x4E2D;&#x7684; lustre_init() &#x5F00;&#x59CB;&#x3002;&#x5F53; &#x2018;lustre&#x2019; &#x5185;&#x6838;&#x6A21;&#x5757;&#x88AB;&#x52A0;&#x8F7D;&#x65F6;&#xFF0C;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x5C31;&#x88AB;&#x8C03;&#x7528;&#x3002;lustre_init &#x8C03;&#x7528; register_filesystem(\&amp;lustre_fs_type)&#xFF0C;&#x6CE8;&#x518C;&#x2018;lustre&#x2019;&#x5230;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x4E2D;&#xFF0C;&#x5E76;&#x628A;&#x5B83;&#x52A0;&#x5165;&#x5185;&#x6838;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;&#x94FE;&#x8868;&#x4E2D;&#xFF0C;&#x8FD9;&#x4E2A;&#x94FE;&#x8868;&#x88AB;&#x7528;&#x4E8E;&#x6302;&#x8F7D;&#x7B49;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x3002;lustre_fs_type &#x4E5F;&#x5728;&#x540C;&#x4E2A;&#x6587;&#x4EF6;&#x8FDB;&#x884C;&#x5B9A;&#x4E49;&#xFF08;&#x6E90;&#x7801;3&#xFF09;&#x3002;</p>
</blockquote>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/Mgc_setup.png" alt="Figure 8. mgc_setup() call graph starting from Lustre file system mounting.">
    <figcaption style="font-size:12px">Figure 8. mgc_setup() call graph starting from Lustre file system mounting.</figcaption>
</div>

<p>Source code 3: lustre_fs_type structure defined in llite/super25.c</p>
<pre><code class="lang-c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> file_system_type lustre_fs_type = {
        .owner          = THIS_MODULE,
        .name           = <span class="hljs-string">&quot;lustre&quot;</span>,
        .mount          = lustre_mount,
        .kill_sb        = lustre_kill_super,
        .fs_flags       = FS_RENAME_DOES_D_MOVE,
};
</code></pre>
<p>When a user mounts Lustre, the lustre_mount() gets invoked as evident from this structure. lustre_mount() is defined in the same file and which in turn calls mount_nodev() routine. The mount_nodev() invokes its call back function lustre_fill_super() which is also defined in llite/super25.c. lustre_fill_super() is the entry point for the mount call from the Lustre client into Lustre.</p>
<blockquote>
<p>&#x5F53;&#x7528;&#x6237;&#x6302;&#x8F7D; Lustre &#x65F6;&#xFF0C;lustre_mount() &#x5C31;&#x88AB;&#x8C03;&#x7528;&#xFF08;llite/super25.c&#xFF09;&#xFF0C;&#x4E4B;&#x540E;&#x8C03;&#x7528; mount_nodev()&#x3002;mount_nodev() &#x8C03;&#x7528;&#x5176;&#x56DE;&#x8C03;&#x51FD;&#x6570; lustre_fill_super()&#xFF08;llite/super25.c &#x4E2D;&#x5B9A;&#x4E49;&#xFF09;&#xFF0C;lustre_fill_super() &#x6302;&#x8F7D;&#x8C03;&#x7528;&#x662F; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x8FDB;&#x5165; Lustre &#x7684;&#x5165;&#x53E3;&#x70B9;&#x3002;</p>
</blockquote>
<p>lustre_fill_super() invokes lustre_start_mgc() defined in obdclass/obd_mount.c. This sets up the MGC obd device to start processing startup logs. The lustre_start_simple() routine called here starts the MGC obd device (defined in obdclass/obd_mount.c). lustre_start_simple() eventually leads to the invocation of obdclass specific routines class_attach() and class_setup() (described in detail in the Section 5) with the help of a do_lcfg() routine that takes obd device name and a lustre configuration command (lcfg_command) as arguments. Various lustre configuration commands are LCFG_ATTACH, LCFG_DETACH, LCFG_SETUP, LCFG_CLEANUP and so on. These are defined in include/uapi/linux/lustre/lustre_cfg.h as shown in Source Code 4.</p>
<blockquote>
<p>lustre_fill_super() &#x8C03;&#x7528;&#x5728; obdclass/obd_mount.c &#x4E2D;&#x5B9A;&#x4E49;&#x7684; lustre_start_mgc()&#x3002;&#x8FD9;&#x5C06;&#x8BBE;&#x7F6E; MGC obd &#x8BBE;&#x5907;&#x548C;&#x5F00;&#x59CB;&#x5904;&#x7406;&#x542F;&#x52A8;&#x65E5;&#x5FD7;&#x3002;&#x5728;&#x8FD9;&#x91CC;&#x8C03;&#x7528;&#x7684; lustre_start_simple() &#x542F;&#x52A8; MGC obd&#x8BBE;&#x5907;&#xFF08;&#x5728;obdclass/obd_mount.c&#x4E2D;&#x5B9A;&#x4E49;&#xFF09;&#x3002;lustre_start_simple() &#x6700;&#x7EC8;&#x4F1A;&#x901A;&#x8FC7; do_lcfg() &#x8C03;&#x7528; obdclass &#x7279;&#x5B9A;&#x7684; class_attach() &#x548C; class_setup()&#xFF08;&#x5728;&#x7B2C;5&#x8282;&#x4E2D;&#x8BE6;&#x7EC6;&#x63CF;&#x8FF0;&#xFF09;&#xFF0C;do_lcfg() &#x4EE5; obd &#x8BBE;&#x5907;&#x540D;&#x79F0;&#x548C; Lustre &#x914D;&#x7F6E;&#x547D;&#x4EE4;&#xFF08;lcfg_command&#xFF09;&#x4F5C;&#x4E3A;&#x53C2;&#x6570;&#x3002;Lustre &#x914D;&#x7F6E;&#x547D;&#x4EE4;&#x5982; LCFG_ATTACH&#x3001;LCFG_DETACH&#x3001;LCFG_SETUP&#x3001;LCFG_CLEANUP &#x7B49;&#x5728; include/uapi/linux/lustre/lustre_cfg.h &#x4E2D;&#x5B9A;&#x4E49;&#xFF0C;&#x5982;&#x6E90;&#x4EE3;&#x7801;4&#x6240;&#x793A;&#x3002;</p>
</blockquote>
<p>Source code 4: Lustre configuration commands defined in include/uapi/linux/lustre/lustre_cfg.h</p>
<pre><code class="lang-c"><span class="hljs-keyword">enum</span> lcfg_command_type {
        LCFG_ATTACH               = <span class="hljs-number">0x00cf001</span>, <span class="hljs-comment">/**&lt; create a new obd instance */</span>
        LCFG_DETACH               = <span class="hljs-number">0x00cf002</span>, <span class="hljs-comment">/**&lt; destroy obd instance */</span>
        LCFG_SETUP                = <span class="hljs-number">0x00cf003</span>, <span class="hljs-comment">/**&lt; call type-specific setup */</span>
        LCFG_CLEANUP              = <span class="hljs-number">0x00cf004</span>, <span class="hljs-comment">/**&lt; call type-specific cleanup
                                                    */</span>
        LCFG_ADD_UUID             = <span class="hljs-number">0x00cf005</span>, <span class="hljs-comment">/**&lt; add a nid to a niduuid */</span>
        . . . . .
};
</code></pre>
<p>The first lcfg_command that is being passed to do_lcfg() routine is LCFG_ATTACH which will result in the invocation of obdclass function class_attach(). We will describe class_attach() in detail in Section 5. The second lcfg_command passed to do_lcfg() function is LCFG_SETUP which will result in the invocation of mgc_setup() eventually. do_lcfg() calls class_process_config() (defined in obdclass/obd_config.c) and passes the lcfg_command that it received. In case of LCFG_SETUP command the class_setup() routine gets invoked. This is defined in the same file and its primary duty is to create hashes and self export and call obd device specific setup. The device specific setup call is in turn invoked through another routine called obd_setup(). obd_setup() is defined in include/obd_class.h as an inline function in the same way obd_get_info() is defined. obd_setup() calls the device specific setup routine with the help of the OBP macro (refer Section 4.3 and Figure 6). Here, in case of MGC obd device mgc_setup() defined as part of the mgc_obd_ops structure (shown in Source Code 2) gets invoked by the obd_setup() routine. Note that the yellow colored blocks in Figure 8 will be referenced again in Section 5 to illustrate the lifecycle of the MGC obd device.</p>
<blockquote>
<p>&#x7B2C;&#x4E00;&#x4E2A;&#x88AB;&#x4F5C;&#x4E3A; do_lcfg() &#x53C2;&#x6570;&#x7684; lcfg_command &#x662F; LCFG_ATTACH&#xFF0C;&#x5E76;&#x6700;&#x7EC8;&#x8C03;&#x7528; obdclass &#x7684;&#x51FD;&#x6570; class_attach()&#x3002;&#x6211;&#x4EEC;&#x5C06;&#x5728;&#x7B2C;5&#x8282;&#x8BE6;&#x7EC6;&#x4ECB;&#x7ECD;class_attach()&#x3002;&#x7B2C;&#x4E8C;&#x4E2A;&#x4F5C;&#x4E3A; do_lcfg()&#x7684; lcfg_command &#x662F; LCFG_SETUP&#xFF0C;&#x5E76;&#x6700;&#x7EC8;&#x8C03;&#x7528; mgc_setup()&#x3002;do_lcfg() &#x8C03;&#x7528; class_process_config()&#xFF08;&#x5728;obdclass/obd_config.c&#x4E2D;&#x5B9A;&#x4E49;&#xFF09;&#x5E76;&#x4F20;&#x9012;&#x63A5;&#x6536;&#x5230;&#x7684; lcfg_command&#x3002;&#x5BF9;&#x4E8E; LCFG_SETUP &#x5B8F;&#xFF0C;&#x5C06;&#x8C03;&#x7528; class_setup()&#x3002;&#x8BE5;&#x51FD;&#x6570;&#x5728;&#x76F8;&#x540C;&#x7684;&#x6587;&#x4EF6;&#x4E2D;&#x5B9A;&#x4E49;&#xFF0C;&#x5176;&#x4E3B;&#x8981;&#x4EFB;&#x52A1;&#x662F;&#x521B;&#x5EFA;&#x6563;&#x5217;&#x548C;&#x81EA;&#x5BFC;&#x51FA;&#xFF08;self export&#xFF09;&#xFF0C;&#x7136;&#x540E;&#x8C03;&#x7528; obd &#x8BBE;&#x5907;&#x7279;&#x5B9A;&#x7684;&#x8BBE;&#x7F6E;&#x6D41;&#x7A0B;&#x3002;&#x8BBE;&#x5907;&#x7279;&#x5B9A;&#x7684;&#x8BBE;&#x7F6E;&#x6D41;&#x7A0B;&#x88AB;&#x53E6;&#x4E00;&#x4E2A; obd_setup() &#x8C03;&#x7528;&#x3002;obd_setup()&#x5728; include/obd_class.h &#x4E2D;&#x5B9A;&#x4E49;&#x4E3A;&#x5185;&#x8054;&#x51FD;&#x6570;&#xFF0C;&#x5C31;&#x50CF; obd_get_info() &#x4E00;&#x6837;&#x3002;obd_setup() &#x901A;&#x8FC7; OBP &#x5B8F;&#x7684;&#x5E2E;&#x52A9;&#x8C03;&#x7528;&#x8BBE;&#x5907;&#x7279;&#x5B9A;&#x7684;&#x8BBE;&#x7F6E;&#x6D41;&#x7A0B;&#xFF08;&#x53C2;&#x89C1;&#x7B2C;4.3&#x8282;&#x548C;&#x56FE;6&#xFF09;&#x3002;&#x5728;&#x8FD9;&#x91CC;&#xFF0C;&#x5BF9;&#x4E8E; MGC obd &#x8BBE;&#x5907;&#xFF0C;obd_setup() &#x4F1A;&#x8C03;&#x7528; mgc_setup()&#xFF0C;&#x800C; mgc_setup() &#x662F; mgc_obd_ops &#x7ED3;&#x6784;&#x7684;&#x4E00;&#x90E8;&#x5206;&#xFF08;&#x5982;&#x6E90;&#x4EE3;&#x7801;2&#x6240;&#x793A;&#xFF09;&#x3002;&#x6CE8;&#x610F;&#xFF0C;&#x56FE;8&#x4E2D;&#x7684;&#x9EC4;&#x8272;&#x5757;&#x5C06;&#x5728;&#x7B2C;5&#x8282;&#x4E2D;&#x518D;&#x6B21;&#x88AB;&#x5F15;&#x7528;&#xFF0C;&#x4EE5;&#x8BF4;&#x660E; MGC obd &#x8BBE;&#x5907;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;&#x3002;</p>
</blockquote>
<h3 id="operation"><a name="operation" class="plugin-anchor" href="#operation"><i class="fa fa-link" aria-hidden="true"></i></a>Operation</h3>
<p>mgc_setup() first adds a reference to the underlying Lustre PTL-RPC layer. Then it sets up an RPC client for the obd device using client_obd_setup() (defined in ldlm/ldlm_lib.c). Next mgc_llog_init() initializes Lustre logs which will be processed by MGC at the MGS server. These logs are also sent to the Lustre client and the client side MGC mirrors these logs to process the data. The tunable parameters persistently set at MGS are sent to MGC and Lustre logs processed at the MGC initializes these parameters. In Lustre the tunables have to be set before Lustre logs are processed and mgc_tunables_init() helps to initialize these tunables. Few examples of the tunables set by this function are conn_uuid, uuid, ping and dynamic_nids and can be viewed in /sys/fs/lustre/mgc directory by logging into any Lustre client. kthread_run() starts an mgc_requeue_thread which keeps reading the lustre logs as the entries come in. A flowchart showing the mgc_setup() workflow is shown in Figure 10.</p>
<blockquote>
<p>mgc_setup()&#x9996;&#x5148;&#x6DFB;&#x52A0;&#x5BF9;&#x5E95;&#x5C42; Lustre PTL-RPC &#x7684;&#x5F15;&#x7528;&#x3002;&#x7136;&#x540E;&#xFF0C;&#x5B83;&#x4F7F;&#x7528; client_obd_setup()&#xFF08;&#x5728;ldlm/ldlm_lib.c&#x4E2D;&#x5B9A;&#x4E49;&#xFF09;&#x4E3A; obd &#x8BBE;&#x5907;&#x8BBE;&#x7F6E;&#x4E00;&#x4E2A; RPC &#x5BA2;&#x6237;&#x7AEF;&#x3002;&#x63A5;&#x4E0B;&#x6765;&#xFF0C;MGC &#x8C03;&#x7528; mgc_llog_init() &#x521D;&#x59CB;&#x5316; Lustre &#x65E5;&#x5FD7;&#xFF0C;&#x8FD9;&#x4E9B;&#x65E5;&#x5FD7;&#x5C06;&#x5728; MGS &#x670D;&#x52A1;&#x5668;&#x4E0A;&#x8FDB;&#x884C;&#x5904;&#x7406;&#x3002;&#x8FD9;&#x4E9B;&#x65E5;&#x5FD7;&#x4E5F;&#x4F1A;&#x53D1;&#x9001;&#x5230; Lustre &#x5BA2;&#x6237;&#x7AEF;&#xFF0C;&#x5BA2;&#x6237;&#x7AEF;&#x7AEF;&#x7684; MGC &#x4F1A;&#x590D;&#x5236;&#x8FD9;&#x4E9B;&#x65E5;&#x5FD7;&#x4EE5;&#x5904;&#x7406;&#x6570;&#x636E;&#x3002;&#x5728; MGS &#x4E0A;&#x53EF;&#x8C03;&#x7684;&#x6301;&#x4E45;&#x6027;&#x53C2;&#x6570;&#x88AB;&#x53D1;&#x9001;&#x5230; MGC&#xFF0C;&#x5E76;&#x4E14;&#x5728; MGC &#x4E0A;&#x7684; Lustre &#x65E5;&#x5FD7;&#x5904;&#x7406;&#x521D;&#x59CB;&#x5316;&#x8FD9;&#x4E9B;&#x53C2;&#x6570;&#x3002;&#x5728; Lustre &#x4E2D;&#xFF0C;&#x5FC5;&#x987B;&#x5728;&#x5904;&#x7406; Lustre &#x65E5;&#x5FD7;&#x4E4B;&#x524D;&#x8BBE;&#x7F6E;&#x8FD9;&#x4E9B;&#x53EF;&#x8C03;&#x53C2;&#x6570;&#xFF0C;&#x800C; mgc_tunables_init() &#x5E2E;&#x52A9;&#x521D;&#x59CB;&#x5316;&#x8FD9;&#x4E9B;&#x53EF;&#x8C03;&#x53C2;&#x6570;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x8BE5;&#x51FD;&#x6570;&#x8BBE;&#x7F6E;&#x5305;&#x62EC; conn_uuid&#x3001;uuid&#x3001;ping &#x548C; dynamic_nids&#xFF0C;&#x8FD9;&#x4E9B;&#x90FD;&#x53EF;&#x4EE5;&#x5728;&#x4EFB;&#x4F55; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x4E0A;&#x7684; /sys/fs/lustre/mgc &#x76EE;&#x5F55;&#x8FDB;&#x884C;&#x67E5;&#x770B;&#x3002;kthread_run() &#x542F;&#x52A8;&#x4E00;&#x4E2A;mgc_requeue_thread&#xFF0C;&#x5B83;&#x4F1A;&#x4E0D;&#x65AD;&#x5730;&#x8BFB;&#x53D6; Lustre &#x65E5;&#x5FD7;&#x6761;&#x76EE;&#x3002;&#x56FE;10&#x663E;&#x793A;&#x4E86; mgc_setup() &#x7684;&#x6D41;&#x7A0B;&#x56FE;&#x3002;</p>
</blockquote>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/Mgc_setup_vs_cleanup.png" alt="Figure 10. mgc_setup() vs. mgc_cleanup()">
    <figcaption style="font-size:12px">Figure 10. mgc_setup() vs. mgc_cleanup()</figcaption>
</div>

<h2 id="lustre-log-handling"><a name="lustre-log-handling" class="plugin-anchor" href="#lustre-log-handling"><i class="fa fa-link" aria-hidden="true"></i></a>Lustre Log Handling</h2>
<p>Lustre extensively makes use of logging for recovery and distributed transaction commits. The logs associated with Lustre are called &#x2018;llogs&#x2019; and config logs, startup logs and change logs correspond to various kinds of llogs. As described in Section 3.2.4, the llog_reader utility can be used to read these Lustre logs. When a Lustre target registers with MGS, the MGS constructs a log for the target. Similarly, a lustre-client log is created for the Lustre client when it is mounted. When a user mounts the Lustre client, it triggers to download the Lustre config logs on the client. As described earlier MGC subsystem is responsible for reading and processing the logs and sending them to Lustre clients and Lustre servers.</p>
<blockquote>
<p>Lustre &#x5927;&#x91CF;&#x4F7F;&#x7528;&#x65E5;&#x5FD7;&#xFF08;logging&#xFF09;&#x8FDB;&#x884C;&#x6062;&#x590D;&#x548C;&#x5206;&#x5E03;&#x5F0F;&#x4E8B;&#x52A1;&#x63D0;&#x4EA4;&#x3002;&#x4E0E; Lustre &#x76F8;&#x5173;&#x7684;&#x65E5;&#x5FD7;&#x79F0;&#x4E3A; &#x201C;llogs&#x201D;&#xFF0C;&#x5176;&#x4E2D;&#x201C;&#x914D;&#x7F6E;&#x201D;&#x3001;&#x201C;&#x542F;&#x52A8;&#x201D;&#x548C;&#x201C;&#x66F4;&#x6539;&#x201D;&#x5BF9;&#x5E94;&#x4E0D;&#x540C;&#x7C7B;&#x578B;&#x7684; llogs&#x3002;&#x5982;&#x7B2C;3.2.4&#x8282;&#x6240;&#x8FF0;&#xFF0C;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;llog_reader &#x5DE5;&#x5177;&#x6765;&#x8BFB;&#x53D6;&#x8FD9;&#x4E9B; Lustre &#x65E5;&#x5FD7;&#x3002;&#x5F53; Lustre &#x76EE;&#x6807;&#xFF08;lustre target&#xFF09;&#x6CE8;&#x518C;&#x5230; MGS &#x65F6;&#xFF0C;MGS&#x4F1A;&#x4E3A;&#x76EE;&#x6807;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65E5;&#x5FD7;&#x3002;&#x7C7B;&#x4F3C;&#x5730;&#xFF0C;&#x5F53;&#x6302;&#x8F7D; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x65F6;&#xFF0C;&#x4F1A;&#x4E3A;&#x8BE5;&#x5BA2;&#x6237;&#x7AEF;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;lustre-client &#x65E5;&#x5FD7;&#x3002;&#x5F53;&#x7528;&#x6237;&#x6302;&#x8F7D; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x65F6;&#xFF0C;&#x5B83;&#x4F1A;&#x89E6;&#x53D1;&#x5728;&#x5BA2;&#x6237;&#x7AEF;&#x4E0A;&#x4E0B;&#x8F7D; Lustre &#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x3002;&#x6B63;&#x5982;&#x524D;&#x9762;&#x6240;&#x8FF0;&#xFF0C;MGC &#x5B50;&#x7CFB;&#x7EDF;&#x8D1F;&#x8D23;&#x8BFB;&#x53D6;&#x548C;&#x5904;&#x7406;&#x8FD9;&#x4E9B;&#x65E5;&#x5FD7;&#xFF0C;&#x5E76;&#x5C06;&#x5176;&#x53D1;&#x9001;&#x5230; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x548C; Lustre &#x670D;&#x52A1;&#x5668;&#x3002;</p>
</blockquote>
<h3 id="log-processing-in-mgc"><a name="log-processing-in-mgc" class="plugin-anchor" href="#log-processing-in-mgc"><i class="fa fa-link" aria-hidden="true"></i></a>Log Processing in MGC</h3>
<p>The lustre_fill_super() routine described in Section 4.4 makes a call to ll_fill_super() function defined in llite/llite_lib.c. This function initializes a config log instance specific to the super block passed from lustre_fill_super(). Since the same MGC may be used to follow multiple config logs (e.g. ost1, ost2, Lustre client), the config log instance is used to keep the state for a specific log. Afterwards lustre_fill_super() invokes lustre_process_log() which gets a config log from MGS and starts processing it. lustre_process_log() gets called for both Lustre clients and Lustre servers and it continues to process new statements appended to the logs. It first resets and allocates lustre_cfg_bufs (which temporarily store log data) and calls obd_process_config() which eventually invokes the obd device specific mgc_process_config() (as shown in Figure 9) with the help of OBP macro. The lcfg_command passed to mgc_process_config() is LCFG_LOG_START which gets the config log from MGC, starts processing it and adds the log to list of logs to follow. config_log_add() defined in the same file accomplishes the task of adding the log to the list of active logs watched for updates by MGC. Few other important log processing functions in MGC are - mgc_process_log (that gets a configuration log from the MGS and processes it), mgc_process_recover_nodemap_log (called if the Lustre client was notified for target restarting by the MGS), and mgc_apply_recover_logs (applies the logs after recovery).</p>
<blockquote>
<p>&#x5728;&#x7B2C;4.4&#x8282;&#x4E2D;&#x63CF;&#x8FF0;&#x7684; lustre_fill_super() &#x8C03;&#x7528;ll_fill_super()&#xFF0C;&#x8BE5;&#x51FD;&#x6570;&#x5B9A;&#x4E49;&#x5728;llite/llite_lib.c&#x4E2D;&#x3002;&#x8BE5;&#x51FD;&#x6570;&#x4F7F;&#x7528; lustre_fill_super() &#x7684;&#x8D85;&#x7EA7;&#x5757;&#x53C2;&#x6570;&#x521D;&#x59CB;&#x5316;&#x4E86;&#x4E00;&#x4E2A;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x5B9E;&#x4F8B;&#x3002;&#x7531;&#x4E8E;&#x540C;&#x4E00;&#x4E2A; MGC &#x53EF;&#x80FD;&#x7528;&#x4E8E;&#x8DDF;&#x8E2A;&#x591A;&#x4E2A;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#xFF08;&#x4F8B;&#x5982;ost1&#x3001;ost2&#x3001;Lustre &#x5BA2;&#x6237;&#x7AEF;&#xFF09;&#xFF0C;&#x56E0;&#x6B64;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#xFF08;config log&#xFF09;&#x5B9E;&#x4F8B;&#x7528;&#x4E8E;&#x7EF4;&#x62A4;&#x6307;&#x5B9A;&#x7684;&#x65E5;&#x5FD7;&#x7684;&#x72B6;&#x6001;&#x3002;&#x7136;&#x540E;&#xFF0C;lustre_fill_super() &#x8C03;&#x7528;lustre_process_log()&#xFF0C;&#x8BE5;&#x51FD;&#x6570;&#x4ECE;MGS&#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x5E76;&#x5F00;&#x59CB;&#x5904;&#x7406;&#x5B83;&#x3002;lustre_process_log()&#x88AB; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x548C; Lustre &#x670D;&#x52A1;&#x7AEF;&#xFF0C;&#x5E76;&#x4E14;&#x5B83;&#x7EE7;&#x7EED;&#x5904;&#x7406;&#x8FFD;&#x52A0;&#x5230;&#x65E5;&#x5FD7;&#x4E2D;&#x7684;&#x65B0;&#x8BED;&#x53E5;&#x3002;&#x5B83;&#x9996;&#x5148;&#x91CD;&#x7F6E;&#x5E76;&#x5206;&#x914D; lustre_cfg_bufs&#xFF08;&#x4E34;&#x65F6;&#x5B58;&#x50A8;&#x65E5;&#x5FD7;&#x6570;&#x636E;&#xFF09;&#xFF0C;&#x7136;&#x540E;&#x8C03;&#x7528; obd_process_config()&#xFF0C;&#x6700;&#x7EC8;&#x4F7F;&#x7528; OBP &#x5B8F;&#x8C03;&#x7528; obd &#x8BBE;&#x5907;&#x7279;&#x5B9A;&#x7684; mgc_process_config()&#xFF08;&#x56FE;9&#xFF09;&#x3002;&#x4F20;&#x9012;&#x7ED9; mgc_process_config() &#x7684; lcfg_command &#x662F; LCFG_LOG_START&#xFF0C;&#x5B83;&#x4ECE; MGC &#x83B7;&#x53D6;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#xFF0C;&#x5E76;&#x5F00;&#x59CB;&#x5904;&#x7406;&#x5B83;&#xFF0C;&#x5E76;&#x5C06;&#x65E5;&#x5FD7;&#x6DFB;&#x52A0;&#x5230;&#x8981;&#x8DDF;&#x8E2A;&#x7684;&#x65E5;&#x5FD7;&#x5217;&#x8868;&#x4E2D;&#x3002;&#x5728;&#x540C;&#x4E00;&#x6587;&#x4EF6;&#x4E2D;&#x5B9A;&#x4E49;&#x7684; config_log_add() &#x5B8C;&#x6210;&#x4E86;&#x5C06;&#x65E5;&#x5FD7;&#x6DFB;&#x52A0;&#x5230; MGC &#x76D1;&#x89C6;&#x6D3B;&#x52A8;&#x65E5;&#x5FD7;&#x66F4;&#x65B0;&#x5217;&#x8868;&#x7684;&#x4EFB;&#x52A1;&#x3002;MGC &#x4E2D;&#x7684;&#x5176;&#x4ED6;&#x91CD;&#x8981;&#x65E5;&#x5FD7;&#x5904;&#x7406;&#x51FD;&#x6570;&#x5305;&#x62EC; mgc_process_log&#xFF08;&#x4ECE; MGS &#x83B7;&#x53D6;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x5E76;&#x5904;&#x7406;&#x5B83;&#xFF09;&#x3001;mgc_process_recover_nodemap_log&#xFF08;&#x5982;&#x679C; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x6536;&#x5230; MGS &#x7684;&#x76EE;&#x6807;&#x91CD;&#x65B0;&#x542F;&#x52A8;&#x901A;&#x77E5;&#x5C31;&#x88AB;&#x8C03;&#x7528;&#xFF09;&#x3001;mgc_apply_recover_logs&#xFF08;&#x5728;&#x6062;&#x590D;&#x540E;&#x5E94;&#x7528;&#x65E5;&#x5FD7;&#xFF09;&#x3002;</p>
</blockquote>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/Mgc_process_config.png" alt="Figure 9. mgc_process_config() call graph">
    <figcaption style="font-size:12px">Figure 9. mgc_process_config() call graph.</figcaption>
</div>

<h2 id="mgcprecleanup-and-mgccleanup"><a name="mgcprecleanup-and-mgccleanup" class="plugin-anchor" href="#mgcprecleanup-and-mgccleanup"><i class="fa fa-link" aria-hidden="true"></i></a>mgc_precleanup() and mgc_cleanup()</h2>
<p>Cleanup functions are important in Lustre in case of file system unmounting or any unexpected errors during file system setup. The class_cleanup() routine defined in obdclass/obd_config.c starts the process of shutting down an obd device. This invokes mgc_precleanup() (through obd_precleanup()) which makes sure that all the exports are destroyed before shutting down the obd device. mgc_precleanup() first decrements the mgc_count that was incremented during mgc_setup(). The mgc_count keeps the count of the running MGC threads and makes sure not to shut down any threads prematurely. Next it waits for any requeue thread to gets completed and calls obd_cleanup_client_import(). obd_cleanup_client_import() destroys client side import interface of the obd device. Finally mgc_precleanup() invokes mgc_llog_fini() which cleans up the lustre logs associated with the MGC. The log cleaning is accomplished by llog_cleanup() routine defined in obdclass/llog_obd.c.</p>
<blockquote>
<p>cleanup &#x51FD;&#x6570;&#x5728; Lustre &#x4E2D;&#x975E;&#x5E38;&#x91CD;&#x8981;&#xFF0C;&#x7528;&#x4E8E;&#x5904;&#x7406;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x5378;&#x8F7D;&#x6216;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x8BBE;&#x7F6E;&#x671F;&#x95F4;&#x7684;&#x610F;&#x5916;&#x9519;&#x8BEF;&#x3002;class_cleanup()&#xFF08;obdclass/obd_config.c&#xFF09; &#x5F00;&#x59CB;&#x5173;&#x95ED; obd &#x8BBE;&#x5907;&#x7684;&#x6D41;&#x7A0B;&#x3002;&#x8FD9;&#x4F1A;&#x901A;&#x8FC7; obd_precleanup()&#xFF08;&#x901A;&#x8FC7; obd_precleanup()&#xFF09;&#x8C03;&#x7528; mgc_precleanup()&#xFF0C;&#x786E;&#x4FDD;&#x5728;&#x5173;&#x95ED; obd &#x8BBE;&#x5907;&#x4E4B;&#x524D;&#x9500;&#x6BC1;&#x6240;&#x6709;&#x5BFC;&#x51FA;&#x3002;mgc_precleanup()&#x9996;&#x5148;&#x9012;&#x51CF;&#x4E86;&#x5728; mgc_setup() &#x671F;&#x95F4;&#x589E;&#x52A0;&#x7684; mgc_count&#x3002;mgc_count &#x662F; MGC &#x7EBF;&#x7A0B;&#x8BA1;&#x6570;&#xFF0C;&#x786E;&#x4FDD;&#x4E0D;&#x4F1A;&#x8FC7;&#x65E9;&#x5173;&#x95ED;&#x4EFB;&#x4F55;&#x7EBF;&#x7A0B;&#x3002;&#x63A5;&#x4E0B;&#x6765;&#xFF0C;&#x5B83;&#x7B49;&#x5F85;&#x91CD;&#x65B0;&#x6392;&#x961F;&#x7684;&#x7EBF;&#x7A0B;&#x5B8C;&#x6210;&#xFF0C;&#x5E76;&#x8C03;&#x7528; obd_cleanup_client_import()&#x3002;obd_cleanup_client_import()&#x9500;&#x6BC1; obd &#x8BBE;&#x5907;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x5BFC;&#x5165;&#x63A5;&#x53E3;&#x3002;&#x6700;&#x540E;&#xFF0C;mgc_precleanup()&#x8C03;&#x7528; mgc_llog_fini()&#xFF0C;&#x6E05;&#x7406;&#x4E0E; MGC &#x76F8;&#x5173;&#x7684; Lustre &#x65E5;&#x5FD7;&#x3002;&#x65E5;&#x5FD7;&#x6E05;&#x7406;&#x7531; llog_cleanup()&#xFF08;obdclass/llog_obd.c&#xFF09; &#x5904;&#x7406;&#x3002;</p>
</blockquote>
<p>mgc_cleanup() function deletes the profiles for the last MGC obd using class_del_profiles() defined in obdclass/obd_config.c. When MGS sends a buffer of data to MGC, the lustre profiles helps to identify the intended recipients of the data. Next the lprocfs_obd_cleanup() routine (defined in obdclass/lprocfs_status.c) removes sysfs and debugfs entries for the obd device. It then decrements the reference to PTL-RPC layer and finally calls client_obd_cleanup(). This function (defined in ldlm/ldlm_lib.c) makes the obd namespace point to NULL, destroys the client side import interface and finally frees up the obd device using OBD_FREE macro. Figure 10 shows the workflows for both setup and cleanup routines in MGC parallely. The class_cleanup() routine defined in obd_config.c starts the MGC shut down process. Note that after the obd_precleanup(), uuid-export and nid-export hashtables are freed up and destroyed. uuid-export HT stores uuids for different obd devices where as nid-export HT stores ptl-rpc network connection information.</p>
<blockquote>
<p>mgc_cleanup() &#x51FD;&#x6570;&#x4F7F;&#x7528;&#x5728; obdclass/obd_config.c &#x4E2D;&#x5B9A;&#x4E49;&#x7684; class_del_profiles() &#x5220;&#x9664;&#x6700;&#x540E;&#x4E00;&#x4E2A; MGC obd &#x7684;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#xFF08;profiles&#xFF09;&#x3002;&#x5F53; MGS &#x5411; MGC &#x53D1;&#x9001;&#x7F13;&#x51B2;&#x6570;&#x636E;&#x65F6;&#xFF0C;Lustre &#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x7528;&#x4E8E;&#x533A;&#x5206;&#x6570;&#x636E;&#x7684;&#x9884;&#x671F;&#x63A5;&#x6536;&#x8005;&#x3002;&#x63A5;&#x4E0B;&#x6765;&#xFF0C;lprocfs_obd_cleanup()&#xFF08;obdclass/lprocfs_status.c&#xFF09;&#x5220;&#x9664; obd &#x8BBE;&#x5907;&#x7684; sysfs &#x548C; debugfs &#x6761;&#x76EE;&#x3002;&#x7136;&#x540E;&#xFF0C;&#x5B83;&#x9012;&#x51CF;&#x5BF9; PTL-RPC &#x5C42;&#x7684;&#x5F15;&#x7528;&#xFF0C;&#x5E76;&#x6700;&#x540E;&#x8C03;&#x7528; client_obd_cleanup()&#x3002;&#x6B64;&#x51FD;&#x6570;&#xFF08;ldlm/ldlm_lib.c&#xFF09;&#x4F7F; obd &#x547D;&#x540D;&#x7A7A;&#x95F4;&#x6307;&#x5411;NULL&#xFF0C;&#x9500;&#x6BC1;&#x5BA2;&#x6237;&#x7AEF;&#x5BFC;&#x5165;&#x63A5;&#x53E3;&#xFF0C;&#x6700;&#x540E;&#x4F7F;&#x7528; OBD_FREE &#x5B8F;&#x91CA;&#x653E; obd &#x8BBE;&#x5907;&#x3002;&#x56FE;10&#x663E;&#x793A;&#x4E86; MGC &#x4E2D;&#x8BBE;&#x7F6E;&#x548C;&#x6E05;&#x7406;&#x7684;&#x5E76;&#x884C;&#x5DE5;&#x4F5C;&#x6D41;&#x7A0B;&#x3002;&#x9700;&#x8981;&#x6CE8;&#x610F;&#x7684;&#x662F;&#xFF0C;&#x5728; obd_precleanup() &#x4E4B;&#x540E;&#xFF0C;uuid-export &#x548C; nid-export &#x54C8;&#x5E0C;&#x8868;&#x4E5F;&#x88AB;&#x91CA;&#x653E;&#x548C;&#x9500;&#x6BC1;&#x3002;uuid-export HT &#x5B58;&#x50A8;&#x4E0D;&#x540C; obd &#x8BBE;&#x5907;&#x7684; UUID&#xFF0C;&#x800C; nid-export HT &#x5B58;&#x50A8; ptl-rpc &#x7F51;&#x7EDC;&#x8FDE;&#x63A5;&#x4FE1;&#x606F;&#x3002;</p>
</blockquote>
<h2 id="mgcimportevent"><a name="mgcimportevent" class="plugin-anchor" href="#mgcimportevent"><i class="fa fa-link" aria-hidden="true"></i></a>mgc_import_event()</h2>
<p>The mgc_import_event() function handles the events reported at the MGC import interface. The type of import events identified by MGC are listed in obd_import_event enum defined in include/lustre_import.h as shown in Source Code 5. Client side imports are used by the clients to communicate with the exports on the server (for instance if MDS wants to communicate with MGS, MDS will be using its client import to communicate with MGS&#x2019; server side export). More detailed description of import and export interfaces on obd device is given in Section 5.</p>
<blockquote>
<p>mgc_import_event() &#x51FD;&#x6570;&#x5904;&#x7406;&#x5728; MGC &#x5BFC;&#x5165;&#x63A5;&#x53E3;&#x4E0A;&#x4E0A;&#x62A5;&#x62A5;&#x7684;&#x4E8B;&#x4EF6;&#x3002;MGC &#x7684;&#x4E0D;&#x540C;&#x5BFC;&#x5165;&#x4E8B;&#x4EF6;&#x7C7B;&#x578B;&#x5728; obd_import_event &#x5B9A;&#x4E49;&#xFF08;include/lustre_import.h&#xFF09;&#xFF0C;&#x5982; Source Code 5&#x6240;&#x793A;&#x3002;&#x5BA2;&#x6237;&#x7AEF;&#x4FA7;&#x5BFC;&#x5165;&#x7528;&#x4E8E;&#x5BA2;&#x6237;&#x7AEF;&#x4E0E;&#x670D;&#x52A1;&#x7AEF;&#x4E0A;&#x7684;&#x5BFC;&#x51FA;&#x8FDB;&#x884C;&#x901A;&#x4FE1;&#xFF08;&#x4F8B;&#x5982;&#xFF0C;&#x5982;&#x679C; MDS &#x60F3;&#x8981;&#x4E0E; MGS &#x901A;&#x4FE1;&#xFF0C;MDS &#x5C06;&#x4F7F;&#x7528;&#x5176;&#x5BA2;&#x6237;&#x7AEF;&#x5BFC;&#x5165;&#x4E0E; MGS &#x7684;&#x670D;&#x52A1;&#x7AEF;&#x5BFC;&#x51FA;&#x8FDB;&#x884C;&#x901A;&#x4FE1;&#xFF09;&#x3002;&#x6709;&#x5173; obd &#x8BBE;&#x5907;&#x4E0A;&#x5BFC;&#x5165;&#x548C;&#x5BFC;&#x51FA;&#x63A5;&#x53E3;&#x7684;&#x66F4;&#x8BE6;&#x7EC6;&#x63CF;&#x8FF0;&#xFF0C;&#x8BF7;&#x53C2;&#x9605;&#x7B2C;5&#x8282;&#x3002;</p>
</blockquote>
<p>Source code 5: obd_import_event enum defined in include/lustre_import.h</p>
<pre><code class="lang-c"><span class="hljs-keyword">enum</span> obd_import_event {
        IMP_EVENT_DISCON     = <span class="hljs-number">0x808001</span>,
        IMP_EVENT_INACTIVE   = <span class="hljs-number">0x808002</span>,
        IMP_EVENT_INVALIDATE = <span class="hljs-number">0x808003</span>,
        IMP_EVENT_ACTIVE     = <span class="hljs-number">0x808004</span>,
        IMP_EVENT_OCD        = <span class="hljs-number">0x808005</span>,
        IMP_EVENT_DEACTIVATE = <span class="hljs-number">0x808006</span>,
        IMP_EVENT_ACTIVATE   = <span class="hljs-number">0x808007</span>,
};
</code></pre>
<p>Some of the remaining obd operations for MGC such as client_import_add_conn(), client_import_del_conn(), client_connect_import() and client_disconnect_export() will be explained in obdclass and ldlm Sections.</p>
<blockquote>
<p>&#x5728; obdclass &#x548C; ldlm &#x90E8;&#x5206;&#x5C06;&#x89E3;&#x91CA; MGC &#x7684;&#x4E00;&#x4E9B;&#x5269;&#x4F59;&#x7684; obd &#x64CD;&#x4F5C;&#xFF0C;&#x4F8B;&#x5982; client_import_add_conn()&#x3001;client_import_del_conn()&#x3001;client_connect_import() &#x548C;client_disconnect_export()&#x3002;</p>
</blockquote>
<h1 id="obdclass"><a name="obdclass" class="plugin-anchor" href="#obdclass"><i class="fa fa-link" aria-hidden="true"></i></a>OBDCLASS</h1>
<h2 id="obdclass-introduction"><a name="obdclass-introduction" class="plugin-anchor" href="#obdclass-introduction"><i class="fa fa-link" aria-hidden="true"></i></a>Introduction</h2>

<p>The obdclass subsystem in Lustre provides an abstraction layer that allows generic operations to be applied on Lustre components without having the knowledge of specific components. MGC, MDC, OSC, LOV, LMV are examples of obd devices in Lustre that make use of the obdclass generic abstraction layer. The obd devices can be connected in different ways to form client-server pairs for internal communication and data exchange in Lustre. Note that the client and server referred here are service clients and servers roles temporarily assumed by the obd devices but not physical nodes representing Lustre clients and Lustre servers.</p>
<blockquote>
<p>Lustre &#x4E2D;&#x7684; OBDCLASS &#x5B50;&#x7CFB;&#x7EDF;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x4E2A;&#x62BD;&#x8C61;&#x5C42;&#xFF0C;&#x5141;&#x8BB8;&#x5728;&#x4E0D;&#x4E86;&#x89E3;&#x5177;&#x4F53;&#x7EC4;&#x4EF6;&#x7EC6;&#x8282;&#x5BF9; Lustre &#x7EC4;&#x4EF6;&#x8FDB;&#x884C;&#x901A;&#x7528;&#x64CD;&#x4F5C;&#x3002;MGC&#x3001;MDC&#x3001;OSC&#x3001;LOV&#x3001;LMV &#x662F; Lustre &#x4E2D;&#x4F7F;&#x7528; OBDCLASS &#x901A;&#x7528;&#x62BD;&#x8C61;&#x5C42;&#x7684; OBD &#x8BBE;&#x5907;&#x7684;&#x4F8B;&#x5B50;&#x3002;OBD &#x8BBE;&#x5907;&#x53EF;&#x4EE5;&#x4EE5;&#x4E0D;&#x540C;&#x7684;&#x65B9;&#x5F0F;&#x8FDE;&#x63A5;&#x5728;&#x4E00;&#x8D77;&#xFF0C;&#x5F62;&#x6210; Lustre &#x5185;&#x90E8;&#x901A;&#x4FE1;&#x548C;&#x6570;&#x636E;&#x4EA4;&#x6362;&#x7684;&#x5BA2;&#x6237;&#x7AEF;-&#x670D;&#x52A1;&#x7AEF;&#x5BF9;&#x3002;&#x9700;&#x8981;&#x6CE8;&#x610F;&#x7684;&#x662F;&#xFF0C;&#x8FD9;&#x91CC;&#x6240;&#x6307;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x548C;&#x670D;&#x52A1;&#x7AEF;&#x662F; OBD &#x8BBE;&#x5907;&#x6682;&#x65F6;&#x626E;&#x6F14;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x670D;&#x52A1;&#x548C;&#x670D;&#x52A1;&#x7AEF;&#x89D2;&#x8272;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x4EE3;&#x8868; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x548C; Lustre &#x670D;&#x52A1;&#x7AEF;&#x7684;&#x7269;&#x7406;&#x8282;&#x70B9;</p>
</blockquote>
<p>Obd devices in Lustre are stored internally in an array defined in obdclass/genops.c as shown in Source Code 6. The maximum number of obd devices in Lustre per node is limited by MAX_OBD_DEVICES defined in include/obd.h (shown in Source Code 7). The obd devices in the obd_devs array are indexed using an obd_minor number (see Source Code 8). An obd device can be identified using its minor number, name or uuid. A uuid is a unique identifier that Lustre assigns for obd devices. lctl dl utility (described in Section 3.2.3) can be used to view all local obd devices and their uuids on Lustre clients and Lustre servers.</p>
<blockquote>
<p>Lustre &#x4E2D;&#x7684; OBD &#x8BBE;&#x5907;&#x5B58;&#x50A8;&#x4E00;&#x4E2A;&#x6570;&#x7EC4;&#x4E2D;&#xFF08;obdclass/genops.c&#xFF09;&#xFF0C;&#x5982;&#x6E90;&#x4EE3;&#x7801;6&#x6240;&#x793A;&#x3002;&#x6BCF;&#x4E2A;&#x8282;&#x70B9;&#x4E0A; Lustre &#x4E2D;&#x7684; OBD &#x8BBE;&#x5907;&#x6700;&#x5927;&#x6570;&#x91CF;&#x4E3A;  MAX_OBD_DEVICES&#xFF08;include/obd.h&#xFF0C;&#x6E90;&#x4EE3;&#x7801;7&#xFF09;&#x3002;obd_devs &#x6570;&#x7EC4;&#x4E2D;&#x7684; OBD &#x8BBE;&#x5907;&#x4F7F;&#x7528; OBD_MINOR &#x7F16;&#x53F7;&#x8FDB;&#x884C;&#x7D22;&#x5F15;&#xFF08;&#x6E90;&#x4EE3;&#x7801;8&#xFF09;&#x3002;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x5176;&#x6B21;&#x8BBE;&#x5907;&#x7F16;&#x53F7;&#x3001;&#x540D;&#x79F0;&#x6216; UUID &#x6765;&#x8BC6;&#x522B; OBD &#x8BBE;&#x5907;&#x3002;UUID &#x662F; Lustre &#x4E3A; OBD &#x8BBE;&#x5907;&#x5206;&#x914D;&#x7684;&#x552F;&#x4E00;&#x6807;&#x8BC6;&#x7B26;&#x3002;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;lctl dl &#x7A0B;&#x5E8F;&#xFF08;&#x5728;&#x7B2C;3.2.3&#x8282;&#x4E2D;&#x4ECB;&#x7ECD;&#xFF09;&#x6765;&#x67E5;&#x770B; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x8282;&#x70B9;&#x548C; Lustre &#x670D;&#x52A1;&#x7AEF;&#x8282;&#x70B9;&#x4E0A;&#x7684;&#x6240;&#x6709;&#x672C;&#x5730; OBD &#x8BBE;&#x5907;&#x53CA;&#x5176; UUID&#x3002;</p>
</blockquote>
<p>Source code 6: obd_devs array defined in obdclass/genops.c</p>
<pre><code class="lang-c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> obd_device *obd_devs[MAX_OBD_DEVICES];
</code></pre>
<p>Source code 7: MAX_OBD_DEVICES defined in include/obd.h</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_OBD_DEVICES 8192</span>
</code></pre>
<h2 id="obddevice-structure"><a name="obddevice-structure" class="plugin-anchor" href="#obddevice-structure"><i class="fa fa-link" aria-hidden="true"></i></a>obd_device Structure</h2>
<p>The structure that defines an obd device is shown in Source Code 8.</p>
<p>Source Code 8: obd_device structure defined in include/obd.h</p>
<pre><code class="lang-c"><span class="hljs-keyword">struct</span> obd_device {
        <span class="hljs-keyword">struct</span> obd_type                 *obd_type;
        __u32                            obd_magic;
        <span class="hljs-keyword">int</span>                              obd_minor;
        <span class="hljs-keyword">struct</span> lu_device                *obd_lu_dev;
        <span class="hljs-keyword">struct</span> obd_uuid                  obd_uuid;
        <span class="hljs-keyword">char</span>                             obd_name[MAX_OBD_NAME];
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>
                obd_attached:<span class="hljs-number">1</span>,
                obd_set_up:<span class="hljs-number">1</span>,
                . . . . .
                obd_stopping:<span class="hljs-number">1</span>,
                obd_starting:<span class="hljs-number">1</span>,
                obd_force:<span class="hljs-number">1</span>,
                . . . . .
        <span class="hljs-keyword">struct</span> rhashtable       obd_uuid_hash;
        <span class="hljs-keyword">struct</span> rhltable         obd_nid_hash;
        <span class="hljs-keyword">struct</span> obd_export       *obd_self_export;
        <span class="hljs-keyword">struct</span> obd_export       *obd_lwp_export;
        <span class="hljs-keyword">struct</span> kset             obd_kset;
        <span class="hljs-keyword">struct</span> kobj_type        obd_ktype;
        . . . . .
};
</code></pre>
<p>The first field in this structure is obd_type as shown in Source Code 11 that defines the type of the obd device - a metadata or bulk data device or both. obd_magic is used to identify data corruption with an obd device. Lustre assigns a magic number to the obd device during its creation phase and later asserts it in different parts of the source code to make sure that it returns the same magic number to ensure data integrity. As described in previous Section obd_minor is the index of the obd device in obd_devs array. An lu_device entry indicates if the obd device is a real device such as an ldiskfs or zfs type of (block) device. obd_uuid and obd_name fields are used for uuid and name of the obd device as the field names suggest. obd_device structure also includes various flags to indicate the current status of the obd device. Some of those are obd_attached - means completed attach, obd_set_up - finished setup, abort_recovery - recovery expired, obd_stopping - started cleanup, obd_starting - started setup and so on. obd_uuid_hash and obd_nid_hash are uuid-export and nid-export hash tables for the obd device respectively. An obd device is also associated with several linked lists pointing to obd_nid_stats, obd_exports, obd_unlinked_exports and obd_delayed_exports. Some of the remaining relevant fields of this structure are obd_exports, kset and kobject device model abstractions, timeouts for recovery, proc entries, directory entry, procfs and debugfs variables.</p>
<blockquote>
<p>&#x8FD9;&#x4E2A;&#x7ED3;&#x6784;&#x4F53;&#x4E2D;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x5B57;&#x6BB5;&#x662F; obd_type&#xFF0C;&#x5982;&#x6E90;&#x4EE3;&#x7801;11&#x6240;&#x793A;&#xFF0C;&#x5B83;&#x5B9A;&#x4E49;&#x4E86; obd &#x8BBE;&#x5907;&#x7684;&#x7C7B;&#x578B; - &#x5143;&#x6570;&#x636E;&#x8BBE;&#x5907;&#x3001;&#x6570;&#x636E;&#x8BBE;&#x5907;&#x6216;&#x4E24;&#x8005;&#x517C;&#x6709;&#x3002;obd_magic &#x7528;&#x4E8E;&#x6807;&#x8BC6; obd &#x8BBE;&#x5907;&#x7684;&#x6570;&#x636E;&#x662F;&#x5426;&#x635F;&#x574F;&#x3002;Lustre &#x5728;&#x521B;&#x5EFA;&#x9636;&#x6BB5;&#x4E3A; obd &#x8BBE;&#x5907;&#x5206;&#x914D;&#x4E00;&#x4E2A;&#x9B54;&#x672F;&#x6570;&#xFF0C;&#x5E76;&#x5728;&#x4EE3;&#x7801;&#x7684;&#x4E0D;&#x540C;&#x90E8;&#x5206;&#x8FDB;&#x884C;&#x65AD;&#x8A00;&#xFF0C;&#x4EE5;&#x786E;&#x4FDD;&#x5B83;&#x8FD4;&#x56DE;&#x76F8;&#x540C;&#x7684;&#x9B54;&#x672F;&#x6570;&#xFF0C;&#x4EE5;&#x786E;&#x4FDD;&#x6570;&#x636E;&#x5B8C;&#x6574;&#x6027;&#x3002;&#x5982;&#x524D;&#x9762;&#x7684;&#x7AE0;&#x8282;&#x4E2D;&#x6240;&#x8FF0;&#xFF0C;obd_minor &#x662F; obd &#x8BBE;&#x5907;&#x5728; obd_devs &#x6570;&#x7EC4;&#x4E2D;&#x7684;&#x7D22;&#x5F15;&#x3002;lu_device &#x6761;&#x76EE;&#x6807;&#x8BC6; obd &#x8BBE;&#x5907;&#x662F;&#x5426;&#x4E3A;&#x771F;&#x5B9E;&#x8BBE;&#x5907;&#xFF0C;&#x5982; ldiskfs &#x6216; zfs &#x7C7B;&#x578B;&#x7684;&#xFF08;&#x5757;&#xFF09;&#x8BBE;&#x5907;&#x3002;obd_uuid &#x548C; obd_name &#x5B57;&#x6BB5;&#x5206;&#x522B;&#x7528;&#x4E8E; obd &#x8BBE;&#x5907;&#x7684; UUID &#x548C;&#x540D;&#x79F0;&#xFF0C;&#x5982;&#x5B57;&#x6BB5;&#x540D;&#x79F0;&#x6240;&#x793A;&#x3002;obd_device &#x7ED3;&#x6784;&#x4F53;&#x8FD8;&#x5305;&#x62EC;&#x5404;&#x79CD;&#x6807;&#x5FD7;&#xFF0C;&#x7528;&#x4E8E;&#x6307;&#x793A; obd &#x8BBE;&#x5907;&#x7684;&#x5F53;&#x524D;&#x72B6;&#x6001;&#x3002;&#x5176;&#x4E2D;&#x4E00;&#x4E9B;&#x662F; obd_attached - &#x8868;&#x793A;&#x5B8C;&#x6210;&#x9644;&#x52A0;&#xFF0C;obd_set_up - &#x8BBE;&#x7F6E;&#x5B8C;&#x6210;&#xFF0C;abort_recovery - &#x6062;&#x590D;&#x8FC7;&#x671F;&#xFF0C;obd_stopping - &#x5F00;&#x59CB;&#x6E05;&#x7406;&#xFF0C;obd_starting - &#x5F00;&#x59CB;&#x8BBE;&#x7F6E;&#x7B49;&#x7B49;&#x3002;obd_uuid_hash &#x548C; obd_nid_hash &#x5206;&#x522B;&#x662F; obd &#x8BBE;&#x5907;&#x7684; uuid-export &#x548C; nid-export &#x54C8;&#x5E0C;&#x8868;&#x3002;obd &#x8BBE;&#x5907;&#x8FD8;&#x4E0E;&#x6307;&#x5411; obd_nid_stats&#x3001;obd_exports&#x3001;obd_unlinked_exports &#x548C; obd_delayed_exports &#x7B49;&#x591A;&#x4E2A;&#x94FE;&#x8868;&#x76F8;&#x5173;&#x8054;&#x3002;&#x6B64;&#x7ED3;&#x6784;&#x4F53;&#x7684;&#x5176;&#x4ED6;&#x76F8;&#x5173;&#x5B57;&#x6BB5;&#x5305;&#x62EC; obd_exports&#x3001;kset &#x548C; kobject &#x8BBE;&#x5907;&#x6A21;&#x578B;&#x62BD;&#x8C61;&#x3001;&#x6062;&#x590D;&#x8D85;&#x65F6;&#x3001;proc&#x6761;&#x76EE;&#x3001;&#x76EE;&#x5F55;&#x6761;&#x76EE;&#x3001;procfs &#x548C; debugfs &#x53D8;&#x91CF;&#x3002;</p>
</blockquote>
<h2 id="mgc-life-cycle"><a name="mgc-life-cycle" class="plugin-anchor" href="#mgc-life-cycle"><i class="fa fa-link" aria-hidden="true"></i></a>MGC Life Cycle</h2>
<p>As described in Section 4 MGC is the first obd device setup and started by Lustre in the obd device life cycle. To understand the lifecycle of MGC obd device let us start from the generic file system mount function vfs_mount(). vfs_mount() is directly invoked by the mount system call from the user and handles the generic portion of mounting a file system. It then invokes file system specific mount function, that is lustre_mount() in case of Lustre. The lustre_mount() defined in llite/llite_lib.c invokes the kernel function mount_nodev() as shown in Source Code 9 which invokes lustre_fill_super() as its call back function.</p>
<blockquote>
<p>&#x5982;&#x7B2C;4&#x8282;&#x6240;&#x8FF0;&#xFF0C;MGC &#x662F; Lustre &#x5728; obd &#x8BBE;&#x5907;&#x751F;&#x547D;&#x5468;&#x671F;&#x4E2D;&#x8BBE;&#x7F6E;&#x548C;&#x542F;&#x52A8;&#x7684;&#x7B2C;&#x4E00;&#x4E2A; obd &#x8BBE;&#x5907;&#x3002;&#x4E3A;&#x4E86;&#x7406;&#x89E3; MGC obd &#x8BBE;&#x5907;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x4ECE;&#x901A;&#x7528;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6302;&#x8F7D;&#x51FD;&#x6570; vfs_mount() &#x5F00;&#x59CB;&#x3002;vfs_mount() &#x7531;&#x7528;&#x6237;&#x76F4;&#x63A5;&#x8C03;&#x7528;&#x6302;&#x8F7D;&#x8FD9;&#x4E2A;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#xFF0C;&#x5E76;&#x5904;&#x7406;&#x6302;&#x8F7D;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;&#x901A;&#x7528;&#x6D41;&#x7A0B;&#x90E8;&#x5206;&#x3002;&#x7136;&#x540E;&#x5B83;&#x8C03;&#x7528;&#x7279;&#x5B9A;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;&#x6302;&#x8F7D;&#x51FD;&#x6570;&#xFF0C;&#x5728;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7C7B;&#x578B;&#x4E3A; Lustre &#x7684;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x8C03;&#x7528; lustre_mount()&#xFF08;llite/llite_lib.c&#xFF09;&#x3002;lustre_mount() &#x8C03;&#x7528;&#x4E86;&#x5185;&#x6838;&#x51FD;&#x6570; mount_nodev()&#xFF0C;&#x5982;&#x6E90;&#x4EE3;&#x7801;9&#x6240;&#x793A;&#xFF0C;&#x5B83;&#x8C03;&#x7528; lustre_fill_super() &#x4F5C;&#x4E3A;&#x56DE;&#x8C03;&#x51FD;&#x6570;&#x3002;</p>
</blockquote>
<p>Source code 9: lustre_mount() function defined in llite/llite_lib.c</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> dentry *<span class="hljs-title">lustre_mount</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file_system_type *fs_type, <span class="hljs-keyword">int</span> flags,
                                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *devname, <span class="hljs-keyword">void</span> *data)</span>
</span>{
        <span class="hljs-keyword">return</span> mount_nodev(fs_type, flags, data, lustre_fill_super);
}
</code></pre>
<p>lustre_fill_super() function is the entry point for the mount call into Lustre. This function initializes lustre superblock, which is used by the MGC to write a local copy of config log. The lustre_fill_super() routine calls ll_fill_super() which initializes a config log instance specific for the superblock. The config_llog_instance structure is defined in include/obd_class.h as shown in Source Code 10. The cfg_instance field in this structure is unique to this superblock. This unique cfg_instance is obtained using ll_get_cfg_instance() function defined in include/obd_class.h. The config_llog_instance structure also has a uuid (obtained from obd_uuid field of ll_sb_info structure defined in llite/llite_internal.h) and a callback handler defined by the function class_config_llog_handler(). We will come back to this callback handler later in the MGC life cycle process. The color coded blocks in Figure 11 were also part of mgc_setup() call graph shown in Figure 8 in Section 4.</p>
<blockquote>
<p>lustre_fill_super() &#x51FD;&#x6570;&#x662F;&#x6302;&#x8F7D;&#x8C03;&#x7528;&#x8FDB;&#x5165; Lustre &#x7684;&#x5165;&#x53E3;&#x70B9;&#x3002;MGC &#x628A;&#x8BE5;&#x51FD;&#x6570;&#x521D;&#x59CB;&#x5316; Lustre &#x8D85;&#x7EA7;&#x5757;&#x5199;&#x5165;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x7684;&#x672C;&#x5730;&#x526F;&#x672C;&#x3002;lustre_fill_super() &#x8C03;&#x7528; ll_fill_super()&#xFF0C;&#x4E3A;&#x8D85;&#x7EA7;&#x5757;&#x521D;&#x59CB;&#x5316;&#x4E86;&#x4E00;&#x4E2A;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x7684;&#x5B9E;&#x4F8B;&#x3002;config_llog_instance&#xFF08;include/obd_class.h&#xFF09;&#x5982;&#x6E90;&#x4EE3;&#x7801;10&#x6240;&#x793A;&#x3002;&#x8FD9;&#x4E2A;&#x7ED3;&#x6784;&#x4F53;&#x4E2D;&#x7684; cfg_instance &#x5B57;&#x6BB5;&#x552F;&#x4E00;&#x6807;&#x8BC6;&#x8BE5;&#x8D85;&#x7EA7;&#x5757;&#x3002;&#x53EF;&#x4EE5;&#x901A;&#x8FC7; ll_get_cfg_instance()&#xFF08;include/obd_class.h&#xFF09;&#x83B7;&#x53D6;&#x8FD9;&#x4E2A;&#x552F;&#x4E00;&#x7684; cfg_instance&#x3002;config_llog_instance &#x7ED3;&#x6784;&#x4F53;&#x8FD8;&#x6709;&#x4E00;&#x4E2A; UUID&#xFF08;&#x4ECE; ll_sb_info &#x4E2D;&#x7684; obd_uuid &#x5B57;&#x6BB5;&#x83B7;&#x53D6;&#xFF0C;llite/llite_internal.h&#xFF09;&#x548C;&#x4E00;&#x4E2A;&#x7531; class_config_llog_handler() &#x5B9A;&#x4E49;&#x7684;&#x56DE;&#x8C03;&#x5904;&#x7406;&#x51FD;&#x6570;&#x6307;&#x9488;&#x3002;&#x7A0D;&#x540E;&#x6211;&#x4EEC;&#x5C06;&#x56DE;&#x5230;&#x8FD9;&#x4E2A;&#x56DE;&#x8C03;&#x5904;&#x7406;&#x51FD;&#x6570;&#xFF0C;&#x4ECB;&#x7ECD; MGC &#x751F;&#x547D;&#x5468;&#x671F;&#x8FC7;&#x7A0B;&#x4E2D;&#x7684;&#x66F4;&#x591A;&#x7EC6;&#x8282;&#x3002;&#x56FE;11&#x4E2D;&#x7684;&#x5F69;&#x8272;&#x5757;&#x4E5F;&#x662F;&#x7B2C;4&#x8282;&#x4E2D;&#x56FE;8&#x4E2D; mgc_setup() &#x8C03;&#x7528;&#x56FE;&#x7684;&#x4E00;&#x90E8;&#x5206;&#x3002;</p>
</blockquote>
<p>Source code 10: config_llog_instance structure is defined in include/obd_class.h</p>
<pre><code class="lang-c"><span class="hljs-keyword">struct</span> config_llog_instance {
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>            cfg_instance;
        <span class="hljs-keyword">struct</span> super_block      *cfg_sb;
        <span class="hljs-keyword">struct</span> obd_uuid          cfg_uuid;
        <span class="hljs-keyword">llog_cb_t</span>                cfg_callback;
        <span class="hljs-keyword">int</span>                      cfg_last_idx; <span class="hljs-comment">/* for partial llog processing */</span>
        <span class="hljs-keyword">int</span>                      cfg_flags;
        __u32                    cfg_lwp_idx;
        __u32                    cfg_sub_clds;
};
</code></pre>
<p>The file system name field (ll_fsinfo) of ll_sb_info structure is populated by copying the profile name obtained using the get_profile_name() function. get_profile_name() defined in include/lustre_disk.h obtains a profile name corresponding to the mount command issued from the user from the lustre_mount_data structure.</p>
<blockquote>
<p>ll_sb_info &#x7ED3;&#x6784;&#x4F53;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x5B57;&#x6BB5;&#xFF08;ll_fsinfo&#xFF09;&#x4F7F;&#x7528; get_profile_name()&#xFF08;include/lustre_disk.h&#xFF09; &#x83B7;&#x53D6;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x540D;&#x79F0;&#x540E;&#x901A;&#x8FC7;&#x590D;&#x5236;&#x8BE5;&#x5B57;&#x7B26;&#x4E32;&#x8FDB;&#x884C;&#x586B;&#x5145;&#x3002;&#x5B83;&#x4ECE;&#x7528;&#x6237;&#x53D1;&#x51FA;&#x7684;&#x6302;&#x8F7D;&#x547D;&#x4EE4;&#x4E2D;&#x5305;&#x542B;&#x7684; lustre_mount_data &#x7ED3;&#x6784;&#x4F53;&#x4E2D;&#x83B7;&#x53D6;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x540D;&#x79F0;&#x3002;</p>
</blockquote>
<p>Then ll_fill_super() then invokes the lustre_process_log() function (see Figure 11) which gets the config logs from MGS and starts processing them. This function is called from both Lustre clients and Lustre servers and it will continue to process new statements appended to the logs. lustre_process_log() is defined in obdclass/obd_mount.c. The three parameters passed to this function are superblock, logname and config log instance. The config instance is unique to the super block which is used by the MGC to write to the local copy of the config log and the logname is the name of the llog to be replicated from the MGS. The config log instance is used to keep the state for the specific config log (can be from ost1, ost2, Lustre client etc.) and is added to the MGC&#x2019;s list of logs to follow. lustre_process_log() then calls obd_process_config() that uses the OBP macro (refer Section 4.3) to call MGC specific mgc_process_config() function. mgc_process_config() gets the config log from the MGS and processes it to start any services. Logs are also added to the list of logs to watch.</p>
<blockquote>
<p>&#x7136;&#x540E;&#xFF0C;ll_fill_super() &#x8C03;&#x7528; lustre_process_log()&#xFF08;obdclass/obd_mount.c&#xFF0C;&#x56FE;11&#xFF09;&#xFF0C;&#x8BE5;&#x51FD;&#x6570;&#x4ECE; MGS &#x83B7;&#x53D6;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x5E76;&#x5F00;&#x59CB;&#x5904;&#x7406;&#x5B83;&#x4EEC;&#x3002;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x5728; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x548C; Lustre &#x670D;&#x52A1;&#x7AEF;&#x4E2D;&#x90FD;&#x88AB;&#x8C03;&#x7528;&#xFF0C;&#x5E76;&#x4E14;&#x5B83;&#x5C06;&#x7EE7;&#x7EED;&#x5904;&#x7406;&#x9644;&#x52A0;&#x5230;&#x65E5;&#x5FD7;&#x4E2D;&#x7684;&#x65B0;&#x8BED;&#x53E5;&#x3002;&#x4F20;&#x9012;&#x7ED9;&#x8BE5;&#x51FD;&#x6570;&#x7684;&#x4E09;&#x4E2A;&#x53C2;&#x6570;&#x662F;&#x8D85;&#x7EA7;&#x5757;&#x3001;&#x65E5;&#x5FD7;&#x540D;&#x79F0;&#x548C;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x5B9E;&#x4F8B;&#x3002;&#x914D;&#x7F6E;&#x5B9E;&#x4F8B;&#x552F;&#x4E00;&#x6807;&#x8BC6;&#x8D85;&#x7EA7;&#x5757;&#xFF0C;&#x7528;&#x4E8E; MGC &#x5199;&#x5165;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x7684;&#x672C;&#x5730;&#x526F;&#x672C;&#xFF0C;&#x800C; logname &#x662F;&#x8981;&#x4ECE; MGS &#x590D;&#x5236;&#x7684;&#x65E5;&#x5FD7;&#x7684;&#x540D;&#x79F0;&#x3002;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x5B9E;&#x4F8B;&#x7528;&#x4E8E;&#x7EF4;&#x62A4;&#x7279;&#x5B9A;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x7684;&#x72B6;&#x6001;&#xFF08;&#x53EF;&#x4EE5;&#x6765;&#x81EA;ost1&#x3001;ost2&#x3001;Lustre&#x5BA2;&#x6237;&#x7AEF;&#x7B49;&#xFF09;&#xFF0C;&#x5E76;&#x6DFB;&#x52A0;&#x5230; MGC &#x7684;&#x65E5;&#x5FD7;&#x8DDF;&#x8E2A;&#x5217;&#x8868;&#x4E2D;&#x3002;&#x7136;&#x540E; lustre_process_log() &#x8C03;&#x7528;obd_process_config()&#xFF0C;&#x5B83;&#x4F7F;&#x7528; OBP &#x5B8F;&#xFF08;&#x53C2;&#x89C1;&#x7B2C;4.3&#x8282;&#xFF09;&#x8C03;&#x7528; MGC &#x7684; mgc_process_config() &#x51FD;&#x6570;&#x3002;&#x5B83;&#x4ECE; MGS &#x83B7;&#x53D6;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x5E76;&#x5904;&#x7406;&#xFF0C;&#x4EE5;&#x7528;&#x4E8E;&#x542F;&#x52A8;&#x5176;&#x4ED6;&#x670D;&#x52A1;&#x3002;&#x65E5;&#x5FD7;&#x4E5F;&#x88AB;&#x6DFB;&#x52A0;&#x5230;&#x8981;&#x76D1;&#x89C6;&#x7684;&#x65E5;&#x5FD7;&#x5217;&#x8868;&#x4E2D;&#x3002;</p>
</blockquote>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/Mgc_lifecycle.png" alt="Figure 11. Obd device life cycle workflow for MGC">
    <figcaption style="font-size:12px">Figure 11. Obd device life cycle workflow for MGC.</figcaption>
</div>

<p>We now describe the detailed workflow of mgc_process_config() by describing the functionalities of each sub-function that it invokes. The config_log_add() function categorizes the data in config log based on if the data is related to - ptl-rpc layer, configuration parameters, nodemaps and barriers. The log data related to each of these categories is then copied to memory using the function config_log_find_or_add(). mgc_process_config() next calls mgc_process_log() and it gets a config log from MGS and processes it. This function is called for both Lustre clients and Lustre servers to process the configuration log from the MGS. The MGC enqueues a DLM lock on the log from the MGS and if the lock gets revoked, MGC will be notified by the lock cancellation callback that the config log has changed, and will enqueue another MGS lock on it, and then continue processing the new additions to the end of the log. Lustre prevents the updation of the same log by multiple processes at the same time. The mgc_process_log() then calls mgc_process_cfg_log() function which reads the log and creates a local copy of the log on the Lustre client or Lustre server. This function first initializes an environment and a context using lu_env_init() and llog_get_context() respectively. The mgc_llog_local_copy() routine is used to create a local copy of the log with the environment and context previously initialized. Real time changes in the log are parsed using the function class_config_parse_llog(). Under read only mode, there will be no local copy or local copy will be incomplete, so Lustre will try to use remote llog first.</p>
<blockquote>
<p>&#x73B0;&#x5728;&#x6211;&#x4EEC;&#x901A;&#x8FC7;&#x63CF;&#x8FF0; mgc_process_config() &#x8C03;&#x7528;&#x7684;&#x6BCF;&#x4E2A;&#x5B50;&#x51FD;&#x6570;&#x7684;&#x529F;&#x80FD;&#xFF0C;&#x6765;&#x8BE6;&#x7EC6;&#x8BF4;&#x660E;&#x5B83;&#x7684;&#x5DE5;&#x4F5C;&#x6D41;&#x7A0B;&#x3002;config_log_add() &#x51FD;&#x6570;&#x6839;&#x636E;&#x65E5;&#x5FD7;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x662F;&#x5426;&#x5173;&#x8054;&#x5230; ptl-rpc &#x5C42;&#x3001;&#x914D;&#x7F6E;&#x53C2;&#x6570;&#x3001;&#x8282;&#x70B9;&#x6620;&#x5C04;&#x548C;&#x5C4F;&#x969C;&#xFF0C;&#x5BF9;&#x5176;&#x8FDB;&#x884C;&#x5206;&#x7C7B;&#x3002;&#x7136;&#x540E;&#xFF0C;&#x4F7F;&#x7528; config_log_find_or_add() &#x628A;&#x4E0E;&#x6BCF;&#x4E2A;&#x7C7B;&#x522B;&#x76F8;&#x5173;&#x7684;&#x65E5;&#x5FD7;&#x6570;&#x636E;&#x88AB;&#x590D;&#x5236;&#x5230;&#x5185;&#x5B58;&#x4E2D;&#x3002;mgc_process_config() &#x63A5;&#x4E0B;&#x6765;&#x8C03;&#x7528; mgc_process_log()&#xFF0C;&#x5B83;&#x4ECE; MGS &#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x5E76;&#x5BF9;&#x5176;&#x8FDB;&#x884C;&#x5904;&#x7406;&#x3002;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x88AB;&#x7528;&#x4E8E; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x548C; Lustre &#x670D;&#x52A1;&#x7AEF;&#xFF0C;&#x4EE5;&#x7528;&#x4E8E;&#x5904;&#x7406;&#x6765;&#x81EA; MGS &#x7684;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x3002;MGC &#x5C06;&#x6765;&#x7740; MGS &#x7684;&#x65E5;&#x5FD7;&#x653E;&#x5165; DLM &#x9501;&#x7684;&#x961F;&#x5217;&#xFF0C;&#x5982;&#x679C;&#x9501;&#x88AB;&#x53D6;&#x6D88;&#xFF0C;&#x9501;&#x53D6;&#x6D88;&#x56DE;&#x8C03;&#x5C06;&#x901A;&#x77E5; MGC &#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x5DF2;&#x7ECF;&#x53D1;&#x751F;&#x4E86;&#x53D8;&#x5316;&#xFF0C;&#x5E76;&#x5C06;&#x5728;&#x5176;&#x4E0A;&#x6392;&#x961F;&#x53E6;&#x4E00;&#x4E2A; MGS &#x9501;&#xFF0C;&#x7136;&#x540E;&#x7EE7;&#x7EED;&#x5904;&#x7406;&#x65E5;&#x5FD7;&#x672B;&#x5C3E;&#x7684;&#x65B0;&#x6DFB;&#x52A0;&#x5185;&#x5BB9;&#x3002;Lustre &#x9632;&#x6B62;&#x591A;&#x4E2A;&#x8FDB;&#x7A0B;&#x540C;&#x65F6;&#x66F4;&#x65B0;&#x540C;&#x4E00;&#x65E5;&#x5FD7;&#x3002;&#x7136;&#x540E; mgc_process_log() &#x8C03;&#x7528; mgc_process_cfg_log()&#xFF0C;&#x8BE5;&#x51FD;&#x6570;&#x8BFB;&#x53D6;&#x65E5;&#x5FD7;&#x5E76;&#x5728; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x6216; Lustre &#x670D;&#x52A1;&#x7AEF;&#x4E0A;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x672C;&#x5730;&#x526F;&#x672C;&#x3002;&#x6B64;&#x51FD;&#x6570;&#x9996;&#x5148;&#x4F7F;&#x7528; lu_env_init() &#x548C; llog_get_context() &#x5206;&#x522B;&#x521D;&#x59CB;&#x5316;&#x73AF;&#x5883;&#x548C;&#x4E0A;&#x4E0B;&#x6587;&#x3002;mgc_llog_local_copy() &#x7528;&#x4E8E;&#x521B;&#x5EFA;&#x4E4B;&#x524D;&#x521D;&#x59CB;&#x5316;&#x7684;&#x73AF;&#x5883;&#x7684;&#x65E5;&#x5FD7;&#x548C;&#x4E4B;&#x524D;&#x521D;&#x59CB;&#x5316;&#x7684;&#x4E0A;&#x4E0B;&#x6587;&#x65E5;&#x5FD7;&#x7684;&#x672C;&#x5730;&#x526F;&#x672C;&#x3002; class_config_parse_llog() &#x7528;&#x4E8E;&#x89E3;&#x6790;&#x65E5;&#x5FD7;&#x4E2D;&#x7684;&#x5B9E;&#x65F6;&#x66F4;&#x6539;&#x3002;&#x5728;&#x53EA;&#x8BFB;&#x6A21;&#x5F0F;&#x4E0B;&#xFF0C;&#x53EF;&#x80FD;&#x6CA1;&#x6709;&#x672C;&#x5730;&#x526F;&#x672C;&#x6216;&#x672C;&#x5730;&#x526F;&#x672C;&#x4E0D;&#x5B8C;&#x6574;&#xFF0C;&#x56E0;&#x6B64;Lustre &#x5C06;&#x5C1D;&#x8BD5;&#x4F7F;&#x7528;&#x8FDC;&#x7A0B;&#x7684; llog&#x3002;</p>
</blockquote>
<p>The class_config_parse_llog() function is defined in obdclass/obd_config.c. The arguments passed to this function are the environment, context and config log instance initialized in mgc_process_cfg_log() function and the config log name. The first log that is being parsed by the class_config_parse_llog() function is start_log. start_log contains configuration information for various Lustre file system components, obd devices and file system mounting process. class_config_parse_llog() first acquires a lock on the log to be parsed using a handler function (llog_init_handle()). It then continues the processing of the log from where it last stopped till the end of the log. To process the logs two entities are used by this function - 1. an index to parse through the data in the log, and 2. a callback function that processes and interprets the data. The call back function can be a generic handler function like class_config_llog_handler() or it can be customized. Note that this is the call back handler initialized by the config_llog_instance structure as previously mentioned in Source Code 10. Additionally, the callback function provides a config marker functionality that allows to inject special flags for selective processing of data in the log. The callback handler also initializes lustre_cfg_bufs to temporarily store the log data. Afterwards the following actions take place in this function: translate log names to obd device names, append uuid with obd device name for each Lustre client mount and finally attach the obd device.</p>
<blockquote>
<p>The class_config_parse_llog()&#xFF08;obdclass/obd_config.c&#xFF09;&#x7684;&#x53C2;&#x6570;&#x662F;&#x5728; mgc_process_cfg_log() &#x4E2D;&#x521D;&#x59CB;&#x5316;&#x7684;&#x73AF;&#x5883;&#x3001;&#x4E0A;&#x4E0B;&#x6587;&#x548C;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x5B9E;&#x4F8B;&#x4EE5;&#x53CA;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x540D;&#x79F0;&#x3002;class_config_parse_llog() &#x89E3;&#x6790;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x65E5;&#x5FD7;&#x662F; start_log&#x3002;start_log &#x5305;&#x542B;&#x5404;&#x79CD; Lustre &#x7EC4;&#x4EF6;&#x3001;obd &#x8BBE;&#x5907;&#x548C;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6302;&#x8F7D;&#x5904;&#x7406;&#x6D41;&#x7A0B;&#x3002;&#x5B83;&#x5148;&#x4F7F;&#x7528; llog_init_handle() &#x5728;&#x8981;&#x88AB;&#x89E3;&#x6790;&#x7684;&#x65E5;&#x5FD7;&#x4E0A;&#x83B7;&#x53D6;&#x9501;&#x3002;&#x7136;&#x540E;&#xFF0C;&#x5B83;&#x4ECE;&#x4E0A;&#x6B21;&#x505C;&#x6B62;&#x7684;&#x4F4D;&#x7F6E;&#x7EE7;&#x7EED;&#x5904;&#x7406;&#x65E5;&#x5FD7;&#xFF0C;&#x76F4;&#x5230;&#x65E5;&#x5FD7;&#x7684;&#x672B;&#x5C3E;&#x3002;&#x4E3A;&#x4E86;&#x5904;&#x7406;&#x65E5;&#x5FD7;&#xFF0C;&#x8BE5;&#x51FD;&#x6570;&#x4F7F;&#x7528;&#x4E24;&#x4E2A;&#x6761;&#x76EE;&#xFF1A;1.&#x7528;&#x4E8E;&#x89E3;&#x6790;&#x65E5;&#x5FD7;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x7684;&#x7D22;&#x5F15;&#xFF0C;2.&#x7528;&#x4E8E;&#x5904;&#x7406;&#x548C;&#x89E3;&#x91CA;&#x6570;&#x636E;&#x7684;&#x56DE;&#x8C03;&#x51FD;&#x6570;&#x3002;&#x56DE;&#x8C03;&#x51FD;&#x6570;&#x53EF;&#x4EE5;&#x662F;&#x4E00;&#x4E2A;&#x901A;&#x7528;&#x7684;&#x5904;&#x7406;&#x7A0B;&#x5E8F;&#x51FD;&#x6570;&#xFF0C;&#x6BD4;&#x5982;class_config_llog_handler()&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x662F;&#x81EA;&#x5B9A;&#x4E49;&#x7684;&#x51FD;&#x6570;&#x3002;&#x8BF7;&#x6CE8;&#x610F;&#xFF0C;&#x8FD9;&#x662F;&#x4E4B;&#x524D;&#x5728; Source Code 10 &#x4E2D;&#x63D0;&#x5230;&#x7684; config_llog_instance &#x7ED3;&#x6784;&#x521D;&#x59CB;&#x5316;&#x7684;&#x56DE;&#x8C03;&#x5904;&#x7406;&#x6D41;&#x7A0B;&#x3002;&#x6B64;&#x5916;&#xFF0C;&#x56DE;&#x8C03;&#x51FD;&#x6570;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x4E2A;&#x914D;&#x7F6E;&#x6807;&#x8BB0;&#x529F;&#x80FD;&#xFF0C;&#x5141;&#x8BB8;&#x5728;&#x65E5;&#x5FD7;&#x4E2D;&#x6CE8;&#x5165;&#x7279;&#x6B8A;&#x6807;&#x5FD7;&#x4EE5;&#x8FDB;&#x884C;&#x9009;&#x62E9;&#x6027;&#x5730;&#x6570;&#x636E;&#x5904;&#x7406;&#x3002;&#x56DE;&#x8C03;&#x5904;&#x7406;&#x7A0B;&#x5E8F;&#x8FD8;&#x521D;&#x59CB;&#x5316; lustre_cfg_bufs &#x4EE5;&#x4E34;&#x65F6;&#x5B58;&#x50A8;&#x65E5;&#x5FD7;&#x6570;&#x636E;&#x3002;&#x7136;&#x540E;&#xFF0C;&#x63A5;&#x4E0B;&#x6765;&#x7684;&#x64CD;&#x4F5C;&#x5305;&#x62EC;&#xFF1A;&#x5C06;&#x65E5;&#x5FD7;&#x540D;&#x79F0;&#x8F6C;&#x6362;&#x4E3A; obd &#x8BBE;&#x5907;&#x540D;&#x79F0;&#xFF0C;&#x5728;&#x6BCF;&#x4E2A; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x6302;&#x8F7D;&#x4E0A;&#x5C06; uuid &#x4E0E; obd &#x8BBE;&#x5907;&#x540D;&#x79F0;&#x8FDE;&#x63A5;&#x8D77;&#x6765;&#xFF0C;&#x5E76;&#x6700;&#x7EC8;&#x9644;&#x52A0; obd &#x8BBE;&#x5907;&#x3002;</p>
</blockquote>
<p>Each obd device then sets up a key to communicate with other devices through secure ptl-rpc layer. The rules for creating this key are stored in the config log. The obd device then creates a connection for communication. Note that the start log contains all state information for all configuration devices and the lustre configuration buffer (lustre_cfg_bufs) stores this information temporarily. The obd device then use this buffer to consume log data. The start log resembles to a virtual log file and it is never stored on the disk. After creating a connection, the handler performs data mining on the logs to extract information (uuid, nid etc.) required to form Lustre config_logs. The parameter llog_rec_hdr passed with class_config_llog_handler() function decides what type of information should be parsed from the logs. For instance OBD_CFG_REC indicates the handler to scan obd device configuration information and CHANGELOG_REC asks to parse for changelog records. Using the extracted nid and uuid information about the obd device, the handler now invokes class_process_config() routine. This function repeats the cycle of obd device creation for other obd devices. Notice that the only obd device exists in Lustre at this point in the life cycle is MGC. The class_process_config() function calls the generic obd class functions such as class_attach(), class_add_uuid(), class_setup() depending upon the lcfg_command that it receives for a specific obd device.</p>
<blockquote>
<p>&#x7136;&#x540E;&#xFF0C;&#x6BCF;&#x4E2A; obd &#x8BBE;&#x5907;&#x4F1A;&#x8BBE;&#x7F6E;&#x4E00;&#x4E2A;&#x5BC6;&#x94A5;&#xFF0C;&#x4EE5;&#x7528;&#x4E8E;&#x901A;&#x8FC7; ptl-rpc &#x5C42;&#x4E0E;&#x5176;&#x4ED6; obd &#x8BBE;&#x5907;&#x8FDB;&#x884C;&#x5B89;&#x5168;&#x901A;&#x4FE1;&#x3002;&#x521B;&#x5EFA;&#x6B64;&#x5BC6;&#x94A5;&#x7684;&#x89C4;&#x5219;&#x5B58;&#x50A8;&#x5728;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x4E2D;&#x3002;&#x7136;&#x540E;&#xFF0C;obd &#x8BBE;&#x5907;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x7528;&#x4E8E;&#x901A;&#x4FE1;&#x7684;&#x8FDE;&#x63A5;&#x3002;&#x6CE8;&#x610F;&#xFF0C;start_log &#x5305;&#x542B;&#x6240;&#x6709;&#x8BBE;&#x5907;&#x914D;&#x7F6E;&#x7684;&#x6240;&#x6709;&#x72B6;&#x6001;&#x4FE1;&#x606F;&#xFF0C;&#x5E76;&#x4E14;&#x7531; lustre &#x914D;&#x7F6E;&#x7684;&#x7F13;&#x51B2;&#x533A;&#xFF08;lustre_cfg_bufs&#xFF09;&#x4E34;&#x65F6;&#x5B58;&#x50A8;&#x3002;&#x7136;&#x540E;&#xFF0C;obd &#x8BBE;&#x5907;&#x4F7F;&#x7528;&#x6B64;&#x7F13;&#x51B2;&#x533A;&#x6765;&#x5904;&#x7406;&#x65E5;&#x5FD7;&#x6570;&#x636E;&#x3002;start_log &#x7C7B;&#x4F3C;&#x4E8E;&#x4E00;&#x4E2A;&#x865A;&#x62DF;&#x65E5;&#x5FD7;&#x6587;&#x4EF6;&#xFF0C;&#x5B83;&#x4E0D;&#x4F1A;&#x5B58;&#x50A8;&#x5728;&#x78C1;&#x76D8;&#x4E0A;&#x3002;&#x521B;&#x5EFA;&#x8FDE;&#x63A5;&#x540E;&#xFF0C;&#x5904;&#x7406;&#x7A0B;&#x5E8F;&#x89E3;&#x6790;&#x65E5;&#x5FD7;&#x6570;&#x636E;&#x4EE5;&#x83B7;&#x53D6;&#x6240;&#x9700;&#x7684;&#x4FE1;&#x606F;&#xFF08;uuid&#x3001;nid&#x7B49;&#xFF09;&#xFF0C; &#x5E76;&#x751F;&#x6210; Lustre config_logs&#x3002;class_config_llog_handler() &#x51FD;&#x6570;&#x7684; llog_rec_hdr &#x53C2;&#x6570;&#x51B3;&#x5B9A;&#x5E94;&#x4ECE;&#x65E5;&#x5FD7;&#x4E2D;&#x89E3;&#x6790;&#x54EA;&#x79CD;&#x7C7B;&#x578B;&#x7684;&#x4FE1;&#x606F;&#x3002;&#x4F8B;&#x5982;&#xFF0C;OBD_CFG_REC &#x8868;&#x793A;&#x5904;&#x7406;&#x7A0B;&#x5E8F;&#x8981;&#x626B;&#x63CF; obd &#x8BBE;&#x5907;&#x7684;&#x914D;&#x7F6E;&#x4FE1;&#x606F;&#xFF0C;CHANGELOG_REC&#x8981; &#x6C42;&#x89E3;&#x6790; changelog &#x8BB0;&#x5F55;&#x3002;&#x4E3A;&#x4E86;&#x83B7;&#x53D6;&#x6709;&#x5173; obd &#x8BBE;&#x5907;&#x7684; nid &#x548C; uuid&#xFF0C;&#x5904;&#x7406;&#x7A0B;&#x5E8F;&#x8C03;&#x7528; class_process_config()&#x3002;&#x6B64;&#x51FD;&#x6570;&#x4F1A;&#x4E3A;&#x5176;&#x4ED6; obd &#x8BBE;&#x5907;&#x5FAA;&#x73AF;&#x6267;&#x884C; obd &#x8BBE;&#x5907;&#x7684;&#x521B;&#x5EFA;&#x3002;&#x6CE8;&#x610F;&#xFF0C;&#x5728; Lustre obd &#x8BBE;&#x5907;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;&#x7684;&#x8FD9;&#x4E2A;&#x70B9;&#x4E0A;&#xFF0C;&#x53EA;&#x5B58;&#x5728;&#x7740; MGC&#x3002;class_process_config()&#x51FD;&#x6570;&#x6839;&#x636E;&#x63A5;&#x6536;&#x5230;&#x7684;&#x7279;&#x5B9A; obd &#x8BBE;&#x5907;&#x7684;lcfg_command &#x547D;&#x4EE4;&#x8C03;&#x7528;&#x901A;&#x7528; obd &#x7C7B;&#x51FD;&#x6570;&#xFF0C;&#x4F8B;&#x5982; class_attach()&#x3001;class_add_uuid()&#x3001;class_setup() &#x7B49;&#x3002;</p>
</blockquote>
<h2 id="obd-device-life-cycle"><a name="obd-device-life-cycle" class="plugin-anchor" href="#obd-device-life-cycle"><i class="fa fa-link" aria-hidden="true"></i></a>Obd Device Life Cycle</h2>
<p>In this Section we describe the work flow of various obd device life cycle functions such as class_attach(), class_setup(), class_precleanup(), class_cleanup(), and class_detach().</p>
<blockquote>
<p>&#x5728;&#x672C;&#x8282;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x63CF;&#x8FF0;&#x5404;&#x79CD; obd &#x8BBE;&#x5907;&#x751F;&#x547D;&#x5468;&#x671F;&#x51FD;&#x6570;&#x7684;&#x5DE5;&#x4F5C;&#x6D41;&#x7A0B;&#xFF0C;&#x5305;&#x62EC; class_attach()&#x3001;class_setup()&#x3001;class_precleanup()&#x3001;class_cleanup() &#x548C; class_detach()&#x3002;</p>
</blockquote>
<h3 id="classattach"><a name="classattach" class="plugin-anchor" href="#classattach"><i class="fa fa-link" aria-hidden="true"></i></a>class_attach()</h3>
<p>The first method that is called in the life cycle of an obd device is class_attach() and the corresponding lustre config command is LCFG_ATTACH. The class_attach() method is defined in obdclass/obd_config.c. It registers and adds the obd device to the list of obd devices. The list of obd devices is defined in obdclass/genops.c using *obd_devs[MAX_OBD_DEVICES]. The attach function first checks if the obd device type being passed is valid. The obd_type structure is defined in include/obd.h (as shown in Source Code 11). Two types of operations defined in this structure are obd_ops (i.e., data operations) and md_ops (i.e., metadata operations). These operations determine if the obd device is destined to perform data or metadata operations or both.</p>
<blockquote>
<p>obd &#x8BBE;&#x5907;&#x751F;&#x547D;&#x5468;&#x671F;&#x4E2D;&#x7B2C;&#x4E00;&#x4E2A;&#x8C03;&#x7528;&#x7684;&#x51FD;&#x6570;&#x662F; class_attach()&#xFF08;obdclass/obd_config.c&#xFF09;&#xFF0C;&#x5BF9;&#x5E94;&#x7684; Lustre &#x547D;&#x4EE4;&#x662F; LCFG_ATTACH&#x3002;&#x5B83;&#x5C06; obd &#x8BBE;&#x5907;&#x6CE8;&#x518C;&#x5E76;&#x6DFB;&#x52A0;&#x5230; obd &#x8BBE;&#x5907;&#x5217;&#x8868;&#x4E2D;&#x3002;obd &#x8BBE;&#x5907;&#x5217;&#x8868;&#xFF08;obdclass/genops.c&#xFF09;&#x7684;&#x5B9A;&#x4E49;&#x5728;*obd_devs[MAX_OBD_DEVICES]&#x4E2D;&#x3002;attach &#x51FD;&#x6570;&#x9996;&#x5148;&#x68C0;&#x67E5; obd &#x8BBE;&#x5907;&#x7C7B;&#x578B;&#x53C2;&#x6570;&#x662F;&#x5426;&#x6709;&#x6548;&#x3002;obd_type&#x7ED3;&#x6784;&#xFF08;include/obd.h&#xFF09;&#x5982;Source Code 11&#x6240;&#x793A;&#x3002;&#x8BE5;&#x7ED3;&#x6784;&#x5B9A;&#x4E49;&#x4E86;&#x4E24;&#x79CD;&#x64CD;&#x4F5C;&#x7C7B;&#x578B;&#xFF1A;obd_ops&#xFF08;&#x5373;&#x6570;&#x636E;&#x64CD;&#x4F5C;&#xFF09;&#x548C;md_ops&#xFF08;&#x5373;&#x5143;&#x6570;&#x636E;&#x64CD;&#x4F5C;&#xFF09;&#x3002;&#x8FD9;&#x4E9B;&#x64CD;&#x4F5C;&#x786E;&#x5B9A; obd &#x8BBE;&#x5907;&#x662F;&#x5426;&#x6267;&#x884C;&#x6570;&#x636E;&#x64CD;&#x4F5C;&#x3001;&#x5143;&#x6570;&#x636E;&#x64CD;&#x4F5C;&#x6216;&#x4E24;&#x8005;&#x517C;&#x800C;&#x6709;&#x4E4B;&#x3002;</p>
</blockquote>
<p>The lu_device_type field of obd_type structure makes sense only for real block devices such as zfs and ldiskfs osd devices. Furthermore the lu_device_type differentiates metadata and data devices using the tags LU_DEVICE_MD and LU_DEVICE_DT respectively. An example of an lu_device_type structure defined for ldiskfs osd_device_type is shown in Source Code 12.</p>
<blockquote>
<p>obd_type &#x7ED3;&#x6784;&#x4E2D;&#x7684; lu_device_type &#x5B57;&#x6BB5;&#x4EC5;&#x5BF9;&#x771F;&#x5B9E;&#x5757;&#x8BBE;&#x5907;&#xFF08;&#x4F8B;&#x5982; zfs &#x548C; ldiskfs osd &#x8BBE;&#x5907;&#xFF09;&#x6709;&#x610F;&#x4E49;&#x3002;&#x6B64;&#x5916;&#xFF0C;lu_device_type &#x4F7F;&#x7528; LU_DEVICE_MD &#x548C; LU_DEVICE_DT &#x6807;&#x8BB0;&#x533A;&#x5206;&#x5143;&#x6570;&#x636E;&#x8BBE;&#x5907;&#x548C;&#x6570;&#x636E;&#x8BBE;&#x5907;&#x3002;Source Code 12 &#x5C55;&#x793A;&#x4E86;&#x4E3A; ldiskfs osd_device_type &#x5B9A;&#x4E49;&#x7684; lu_device_type &#x7ED3;&#x6784;&#x7684;&#x793A;&#x4F8B;&#x3002;</p>
</blockquote>
<p>Source code 11: obd_type structure defined in include/obd.h</p>
<pre><code class="lang-c"><span class="hljs-keyword">struct</span> obd_type {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> obd_ops    *typ_dt_ops;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> md_ops     *typ_md_ops;
        <span class="hljs-keyword">struct</span> proc_dir_entry   *typ_procroot;
        <span class="hljs-keyword">struct</span> dentry           *typ_debugfs_entry;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_SERVER_SUPPORT</span>
        <span class="hljs-keyword">bool</span>                     typ_sym_filter;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        <span class="hljs-keyword">atomic_t</span>                 typ_refcnt;
        <span class="hljs-keyword">struct</span> lu_device_type   *typ_lu;
        <span class="hljs-keyword">struct</span> kobject           typ_kobj;
};
</code></pre>
<p>Source code 12: lu_device_type structure for ldiskfs osd_device_type defined in osd-ldiskfs/osd_handler.c</p>
<pre><code class="lang-c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> lu_device_type osd_device_type = {
        .ldt_tags     = LU_DEVICE_DT,
        .ldt_name     = LUSTRE_OSD_LDISKFS_NAME,
        .ldt_ops      = &amp;osd_device_type_ops,
        .ldt_ctx_tags = LCT_LOCAL,
};
</code></pre>
<p>The class_attach() then calls a class_newdev() function which creates, allocates a new obd device and initializes it. A complete workflow of the class_attach() function is shown in Figure 12. The class_get_type() function invoked by class_newdev() registers already created obd device and loads the obd device module. All obd device loaded has metadata or data operations (or both) defined for them. For instance the LMV obd device has its md_ops and obd_ops defined in structures lmv_md_ops and lmv_obd_ops respectively. These structures and the associated operations can be seen in lmv/lmv_obd.c file. The obd_minor initialized here is the index of the obd device in obd_devs array.</p>
<blockquote>
<p>class_attach() &#x51FD;&#x6570;&#x63A5;&#x4E0B;&#x6765;&#x8C03;&#x7528; class_newdev() &#x51FD;&#x6570;&#xFF0C;&#x8BE5;&#x51FD;&#x6570;&#x521B;&#x5EFA;&#x3001;&#x5206;&#x914D;&#x4E00;&#x4E2A;&#x65B0;&#x7684; obd &#x8BBE;&#x5907;&#x5E76;&#x8FDB;&#x884C;&#x521D;&#x59CB;&#x5316;&#x3002;class_attach() &#x51FD;&#x6570;&#x7684;&#x5B8C;&#x6574;&#x5DE5;&#x4F5C;&#x6D41;&#x7A0B;&#x5982;&#x56FE;12&#x6240;&#x793A;&#x3002;class_newdev() &#x51FD;&#x6570;&#x8C03;&#x7528;&#x7684; class_get_type() &#x51FD;&#x6570;&#x6CE8;&#x518C;&#x5DF2;&#x521B;&#x5EFA;&#x7684; obd &#x8BBE;&#x5907;&#x5E76;&#x52A0;&#x8F7D; obd &#x8BBE;&#x5907;&#x6A21;&#x5757;&#x3002;&#x6240;&#x6709;&#x52A0;&#x8F7D;&#x7684; obd &#x8BBE;&#x5907;&#x90FD;&#x5177;&#x6709;&#x4E3A;&#x5176;&#x5B9A;&#x4E49;&#x7684;&#x5143;&#x6570;&#x636E;&#x64CD;&#x4F5C;&#x6216;&#x6570;&#x636E;&#x64CD;&#x4F5C;&#xFF08;&#x6216;&#x4E24;&#x8005;&#x517C;&#x5907;&#xFF09;&#x3002;&#x4F8B;&#x5982;&#xFF0C;LMV obd &#x8BBE;&#x5907;&#x7684; md_ops &#x548C; obd_ops (lmv/lmv_obd.c)&#x5206;&#x522B; lmv_md_ops &#x548C; lmv_obd_ops &#x7ED3;&#x6784;&#x4E2D;&#x5B9A;&#x4E49;&#x3002;&#x5728;&#x6B64;&#x521D;&#x59CB;&#x5316;&#x7684; obd_minor &#x662F; obd &#x8BBE;&#x5907;&#x5728; obd_devs &#x6570;&#x7EC4;&#x4E2D;&#x7684;&#x7D22;&#x5F15;&#x3002;</p>
</blockquote>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/Class_attach.png" alt="Figure 12. Workflow of class_attach() function in obd device lifecycle">
    <figcaption style="font-size:12px">Figure 12. Workflow of class_attach() function in obd device lifecycle</figcaption>
</div>

<p>The obd device then creates a self export using the function class_new_export_self(). The class_new_export_self() function invokes a __class_new_export() function which creates a new export, adds it to the hash table of exports and returns a pointer to it. Note that a self export is created only for a client obd device. The reference count for this export when created is 2, one for the hash table reference and the other for the pointer returned by this function itself. This function populates the obd_export structure defined in include/lustre_export.h (shown in Source Code 13). Various fields associated with this structure are explained in the next Section. Two functions that are used to increment and decrement the reference count for obd devices are class_export_get() and class_export_put() respectively. The last part of class_attach() is registering/listing the obd device in the obd_devs array which is done through class_register_device() function. This functions assigns a minor number to the obd device that can be used to lookup the device in the array.</p>
<blockquote>
<p>&#x7136;&#x540E;&#xFF0C;obd &#x8BBE;&#x5907;&#x4F7F;&#x7528; class_new_export_self() &#x51FD;&#x6570;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x81EA;&#x5BFC;&#x51FA;&#xFF08;self export&#xFF09;&#x3002;class_new_export_self() &#x51FD;&#x6570;&#x8C03;&#x7528; __class_new_export() &#x51FD;&#x6570;&#xFF0C;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x5BFC;&#x51FA;&#xFF0C;&#x5C06;&#x5176;&#x6DFB;&#x52A0;&#x5230;&#x5BFC;&#x51FA;&#x7684;&#x54C8;&#x5E0C;&#x8868;&#x4E2D;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;&#x6307;&#x5411;&#x8BE5;&#x5BFC;&#x51FA;&#x7684;&#x6307;&#x9488;&#x3002;&#x9700;&#x8981;&#x6CE8;&#x610F;&#x7684;&#x662F;&#xFF0C;&#x53EA;&#x6709;&#x5BA2;&#x6237;&#x7AEF; obd &#x8BBE;&#x5907;&#x624D;&#x4F1A;&#x521B;&#x5EFA;&#x81EA;&#x5BFC;&#x51FA;&#x3002;&#x521B;&#x5EFA;&#x65F6;&#xFF0C;&#x8BE5;&#x5BFC;&#x51FA;&#x7684;&#x5F15;&#x7528;&#x8BA1;&#x6570;&#x4E3A;2&#xFF0C;&#x4E00;&#x4E2A;&#x7528;&#x4E8E;&#x54C8;&#x5E0C;&#x8868;&#x5F15;&#x7528;&#xFF0C;&#x53E6;&#x4E00;&#x4E2A;&#x7528;&#x4E8E;&#x8BE5;&#x51FD;&#x6570;&#x672C;&#x8EAB;&#x8FD4;&#x56DE;&#x7684;&#x6307;&#x9488;&#x3002;&#x8BE5;&#x51FD;&#x6570;&#x586B;&#x5145;obd_export &#x7ED3;&#x6784;&#xFF08;include/lustre_export.h&#xFF09;&#xFF0C;&#x5982;Source Code 13&#x6240;&#x793A;&#x3002;&#x4E0E;&#x8BE5;&#x7ED3;&#x6784;&#x76F8;&#x5173;&#x7684;&#x5404;&#x4E2A;&#x5B57;&#x6BB5;&#x5C06;&#x5728;&#x4E0B;&#x4E00;&#x8282;&#x4E2D;&#x89E3;&#x91CA;&#x3002;&#x7528;&#x4E8E;&#x589E;&#x52A0;&#x548C;&#x51CF;&#x5C11; obd &#x8BBE;&#x5907;&#x5F15;&#x7528;&#x8BA1;&#x6570;&#x7684;&#x4E24;&#x4E2A;&#x51FD;&#x6570;&#x5206;&#x522B;&#x662F; class_export_get() &#x548C; class_export_put()&#x3002;class_attach() &#x7684;&#x6700;&#x540E;&#x4E00;&#x90E8;&#x5206;&#x662F;&#x901A;&#x8FC7; class_register_device() &#x51FD;&#x6570;&#x5728; obd_devs &#x6570;&#x7EC4;&#x4E2D;&#x6CE8;&#x518C;/&#x5217;&#x51FA; obd &#x8BBE;&#x5907;&#x3002;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x4E3A; obd &#x8BBE;&#x5907;&#x5206;&#x914D;&#x4E00;&#x4E2A;&#x6B21;&#x8BBE;&#x5907;&#x53F7;&#xFF0C;&#x53EF;&#x4EE5;&#x7528;&#x6765;&#x5728;&#x6570;&#x7EC4;&#x4E2D;&#x67E5;&#x627E;&#x8BE5;&#x8BBE;&#x5907;&#x3002;</p>
</blockquote>
<h3 id="obdexport-structure"><a name="obdexport-structure" class="plugin-anchor" href="#obdexport-structure"><i class="fa fa-link" aria-hidden="true"></i></a>obd_export Structure</h3>
<p>This Section describes some of the relevant fields of the obd_export structure (shown in Source Code 13) that represents a target side export connection (using ptlrpc layer) for obd devices in Lustre. This is also used to connect between layers on the same node when there is no network connection between the nodes. For every connected client there exists an export structure on the server attached to the same obd device. Various fields of this structure are described below.</p>
<blockquote>
<p>&#x672C;&#x8282;&#x4ECB;&#x7ECD; obd_export &#x7ED3;&#x6784;&#x7684;&#x4E00;&#x4E9B;&#x76F8;&#x5173;&#x5B57;&#x6BB5;&#xFF08;&#x5982;Source Code 13&#x6240;&#x793A;&#xFF09;&#xFF0C;&#x8BE5;&#x7ED3;&#x6784;&#x8868;&#x793A; Lustre &#x4E2D; obd &#x8BBE;&#x5907;&#x7684;&#x76EE;&#x6807;&#x7AEF;&#x5BFC;&#x51FA;&#x8FDE;&#x63A5;&#xFF08;&#x4F7F;&#x7528; ptlrpc &#x5C42;&#xFF09;&#x3002;&#x5B83;&#x7528;&#x4E8E;&#x5728;&#x4E0D;&#x540C;&#x8282;&#x70B9;&#x4E4B;&#x95F4;&#x6CA1;&#x6709;&#x7F51;&#x7EDC;&#x8FDE;&#x63A5;&#x65F6;&#xFF0C;&#x8FDE;&#x63A5;&#x540C;&#x4E00;&#x8282;&#x70B9;&#x7684;&#x4E0D;&#x540C;&#x5C42;&#x3002;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E2A;&#x5DF2;&#x8FDE;&#x63A5;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#xFF0C;&#x5728;&#x670D;&#x52A1;&#x7AEF;&#x4E0A;&#x90FD;&#x5B58;&#x5728;&#x4E00;&#x4E2A;&#x4E0E;&#x8BE5; obd &#x8BBE;&#x5907;&#x5173;&#x8054;&#x7684;&#x5BFC;&#x51FA;&#x7ED3;&#x6784;&#x3002;&#x4E0B;&#x9762;&#x63CF;&#x8FF0;&#x4E86;&#x8BE5;&#x7ED3;&#x6784;&#x7684;&#x5404;&#x4E2A;&#x5B57;&#x6BB5;&#x3002;</p>
</blockquote>
<ul>
<li><p>exp_handle - On connection establishment, the export handle id is provided to client and the subsequent client RPCs contain this handle id to identify which export they are talking to.</p>
<blockquote>
<p>exp_handle - &#x5728;&#x5EFA;&#x7ACB;&#x8FDE;&#x63A5;&#x65F6;&#xFF0C;&#x5C06;&#x5BFC;&#x51FA;&#x53E5;&#x67C4; ID &#x63D0;&#x4F9B;&#x7ED9;&#x5BA2;&#x6237;&#x7AEF;&#xFF0C;&#x968F;&#x540E;&#x5BA2;&#x6237;&#x7AEF;&#x7684; RPC &#x5C06;&#x5305;&#x542B;&#x6B64;&#x53E5;&#x67C4; ID&#xFF0C;&#x7528;&#x4E8E;&#x6807;&#x8BC6;&#x5B83;&#x4EEC;&#x8981;&#x8FDE;&#x63A5;&#x7684;&#x5BFC;&#x51FA;&#x3002;</p>
</blockquote>
</li>
<li><p>Set of counters described below is used to track where export references are kept. exp_rpc_count is the number of RPC references, exp_cb_count counts commit callback references, exp_replay_count is the number of queued replay requests to be processed and exp_locks_count keeps track of the number of lock references.</p>
<blockquote>
<p>&#x4E0B;&#x9762;&#x63CF;&#x8FF0;&#x7684;&#x4E00;&#x7EC4;&#x8BA1;&#x6570;&#x5668;&#x7528;&#x4E8E;&#x8DDF;&#x8E2A;&#x5BFC;&#x51FA;&#x5F15;&#x7528;&#x7684;&#x4F4D;&#x7F6E;&#x3002;exp_rpc_count &#x662F; RPC &#x5F15;&#x7528;&#x7684;&#x6570;&#x91CF;&#xFF0C;exp_cb_count &#x8BA1;&#x6570;&#x63D0;&#x4EA4;&#x56DE;&#x8C03;&#x7684;&#x5F15;&#x7528;&#x6B21;&#x6570;&#xFF0C;exp_replay_count &#x662F;&#x5F85;&#x5904;&#x7406;&#x7684;&#x961F;&#x5217;&#x4E2D;&#x7684;&#x91CD;&#x653E;&#x8BF7;&#x6C42;&#x7684;&#x6570;&#x91CF;&#xFF0C;exp_locks_count &#x8DDF;&#x8E2A;&#x9501;&#x5F15;&#x7528;&#x7684;&#x6570;&#x91CF;&#x3002;</p>
</blockquote>
</li>
</ul>
<p>Source code 13: obd_export structure defined in include/lustre_export.h</p>
<pre><code class="lang-c"><span class="hljs-keyword">struct</span> obd_export {
        <span class="hljs-keyword">struct</span> portals_handle   exp_handle;
        <span class="hljs-keyword">atomic_t</span>                exp_rpc_count;
        <span class="hljs-keyword">atomic_t</span>                exp_cb_count;
        <span class="hljs-keyword">atomic_t</span>                exp_replay_count;
        <span class="hljs-keyword">atomic_t</span>                exp_locks_count;
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LUSTRE_TRACKS_LOCK_EXP_REFS</span>
        <span class="hljs-keyword">struct</span> list_head        exp_locks_list; 
        <span class="hljs-keyword">spinlock_t</span>              exp_locks_list_guard;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        <span class="hljs-keyword">struct</span> obd_uuid         exp_client_uuid;
        <span class="hljs-keyword">struct</span> list_head        exp_obd_chain; 
        <span class="hljs-keyword">struct</span> work_struct      exp_zombie_work;
        <span class="hljs-keyword">struct</span> list_head        exp_stale_list; 
        <span class="hljs-keyword">struct</span> rhash_head       exp_uuid_hash; 
        <span class="hljs-keyword">struct</span> rhlist_head      exp_nid_hash; 
        <span class="hljs-keyword">struct</span> hlist_node       exp_gen_hash;
        <span class="hljs-keyword">struct</span> list_head        exp_obd_chain_timed; 
        <span class="hljs-keyword">struct</span> obd_device      *exp_obd;
        <span class="hljs-keyword">struct</span> obd_import        *exp_imp_reverse;
        <span class="hljs-keyword">struct</span> nid_stat          *exp_nid_stats;
        <span class="hljs-keyword">struct</span> ptlrpc_connection *exp_connection;
        __u32                     exp_conn_cnt;
        <span class="hljs-keyword">struct</span> cfs_hash          *exp_lock_hash;
        <span class="hljs-keyword">struct</span> cfs_hash          *exp_flock_hash;
};
</code></pre>
<ul>
<li><p><code>exp_locks_list</code> maintains a linked list of all the locks and exp_locks_list_guard is - the spinlock that protects this list.</p>
<blockquote>
<p>exp_locks_list &#x7EF4;&#x62A4;&#x6240;&#x6709;&#x7C7B;&#x578B;&#x9501;&#x7684;&#x94FE;&#x8868;&#xFF0C;exp_locks_list_guard &#x662F;&#x4FDD;&#x62A4;&#x6B64;&#x94FE;&#x8868;&#x7684;&#x81EA;&#x65CB;&#x9501;&#x3002;</p>
</blockquote>
</li>
<li><p><code>exp_client_uuid</code> is the UUID of client connected to this export.</p>
<blockquote>
<p>exp_client_uuid &#x662F;&#x4E0E;&#x6B64;&#x5BFC;&#x51FA;&#x8FDE;&#x63A5;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x7684; UUID&#x3002;</p>
</blockquote>
</li>
<li><p><code>exp_obd_chain</code> links all the exports on an obd device.</p>
<blockquote>
<p>exp_obd_chain &#x5C06;&#x6240;&#x6709;&#x5BFC;&#x51FA;&#x94FE;&#x63A5;&#x5230;&#x4E00;&#x4E2A; obd &#x8BBE;&#x5907;&#x4E0A;&#x3002;</p>
</blockquote>
</li>
<li><p><code>exp_zombie_work</code> is used when the export connection is destroyed.</p>
<blockquote>
<p>exp_zombie_work &#x9500;&#x6BC1;&#x5BFC;&#x51FA;&#x7684;&#x8FDE;&#x63A5;&#x65F6;&#x4F7F;&#x7528;</p>
</blockquote>
</li>
<li><p>The structure also maintains several hash tables to keep track of <code>uuid-exports</code>, nid-exports and last received messages in case of recovery from failure. (exp_uuid_hash, exp_nid_hash and exp_gen_hash).</p>
<blockquote>
<p>&#x8BE5;&#x7ED3;&#x6784;&#x8FD8;&#x7EF4;&#x62A4;&#x4E86;&#x591A;&#x4E2A;&#x54C8;&#x5E0C;&#x8868;&#xFF0C;&#x7528;&#x4E8E;&#x8DDF;&#x8E2A; UUID-&#x5BFC;&#x51FA;&#x3001;NID-&#x5BFC;&#x51FA;&#x4EE5;&#x53CA;&#x5728;&#x53D1;&#x751F;&#x6545;&#x969C;&#x6062;&#x590D;&#x65F6;&#x63A5;&#x6536;&#x7684;&#x6700;&#x540E;&#x4E00;&#x6761;&#x6D88;&#x606F;&#xFF08;exp_uuid_hash&#x3001;exp_nid_hash &#x548C; exp_gen_hash&#xFF09;&#x3002;</p>
</blockquote>
</li>
<li><p>The obd device for this export is defined by the pointer <code>*exp_obd</code>.</p>
<blockquote>
<p>&#x5BFC;&#x51FA;&#x7684; obd &#x8BBE;&#x5907;&#x7531;&#x6307;&#x9488; *exp_obd &#x5B9A;&#x4E49;&#x3002;</p>
</blockquote>
</li>
<li><p><code>*exp_connection</code> - This defines the portal rpc connection for this export.</p>
<blockquote>
<p>*exp_connection - &#x5B9A;&#x4E49;&#x4E86;&#x5BFC;&#x51FA;&#x7684; portal rpc &#x8FDE;&#x63A5;&#x3002;</p>
</blockquote>
</li>
<li><p><code>*exp_lock_hash</code> - This lists all the ldlm locks granted on this export.</p>
<blockquote>
<p>*exp_lock_hash - &#x5217;&#x51FA;&#x4E86;&#x5728;&#x6B64;&#x5BFC;&#x51FA;&#x4E0A;&#x6388;&#x4E88;&#x7684;&#x6240;&#x6709; ldlm &#x9501;&#x3002;</p>
</blockquote>
</li>
<li><p>This structure also has additional fields such as hashes for posix deadlock detection, time for last request received, linked list to replay all requests waiting to be replayed on recovery, lists for RPCs handled, blocking ldlm locks and special union to deal with target specific data.</p>
<blockquote>
<p>&#x8BE5;&#x7ED3;&#x6784;&#x8FD8;&#x5177;&#x6709;&#x5176;&#x4ED6;&#x5B57;&#x6BB5;&#xFF0C;&#x5982;&#x7528;&#x4E8E; posix &#x6B7B;&#x9501;&#x68C0;&#x6D4B;&#x7684;&#x54C8;&#x5E0C;&#x3001;&#x4E0A;&#x6B21;&#x63A5;&#x6536;&#x8BF7;&#x6C42;&#x7684;&#x65F6;&#x95F4;&#x3001;&#x7528;&#x4E8E;&#x5728;&#x6545;&#x969C;&#x6062;&#x590D;&#x65F6;&#x91CD;&#x653E;&#x6240;&#x6709;&#x7B49;&#x5F85;&#x91CD;&#x653E;&#x7684;&#x8BF7;&#x6C42;&#x7684;&#x94FE;&#x8868;&#x3001;&#x5904;&#x7406;&#x7684; RPC &#x7684;&#x5217;&#x8868;&#x3001;&#x963B;&#x585E;&#x7684; ldlm &#x9501;&#x4EE5;&#x53CA;&#x5904;&#x7406;&#x76EE;&#x6807;&#x7279;&#x5B9A;&#x6570;&#x636E;&#x7684; union &#x7ED3;&#x6784;&#x3002;</p>
</blockquote>
</li>
</ul>
<h3 id="classsetup"><a name="classsetup" class="plugin-anchor" href="#classsetup"><i class="fa fa-link" aria-hidden="true"></i></a>class_setup()</h3>
<p>The primary duties of class_setup() routine are create hashtables and self-export, and invoke the obd type specific setup() function. As an initial step this function obtains the obd device from obd_devs array using obd_minor number and asserts the obd_magic number to make sure data integrity. Then it sets the obd_starting flag to indicate that the set up of this obd device has started (refer Source Code 8). Next the uuid-export and nid-export hashtables are setup using Linux kernel builtin functions rhashtable_init() and rhltable_init(). For the nid-stats hashtable Lustre uses its custom implementation of hashtable namely cfs_hash.</p>
<blockquote>
<p>class_setup() &#x51FD;&#x6570;&#x7684;&#x4E3B;&#x8981;&#x4EFB;&#x52A1;&#x662F;&#x521B;&#x5EFA;&#x54C8;&#x5E0C;&#x8868;&#x548C;&#x81EA;&#x5BFC;&#x51FA;&#xFF08;self-export&#xFF09;&#xFF0C;&#x5E76;&#x8C03;&#x7528; obd &#x7C7B;&#x578B;&#x7279;&#x5B9A;&#x7684; setup() &#x51FD;&#x6570;&#x3002;&#x4F5C;&#x4E3A;&#x521D;&#x59CB;&#x6B65;&#x9AA4;&#xFF0C;&#x8BE5;&#x51FD;&#x6570;&#x4F7F;&#x7528; obd_minor &#x53F7;&#x4ECE; obd_devs &#x6570;&#x7EC4;&#x83B7;&#x53D6; obd &#x8BBE;&#x5907;&#xFF0C;&#x5E76;&#x901A;&#x8FC7;&#x5224;&#x65AD; obd_magic &#x53F7;&#x6765;&#x786E;&#x4FDD;&#x6570;&#x636E;&#x5B8C;&#x6574;&#x6027;&#x3002;&#x7136;&#x540E;&#xFF0C;&#x5B83;&#x5C06; obd_starting &#x6807;&#x5FD7;&#x8BBE;&#x7F6E;&#x4E3A;&#x6307;&#x793A;&#x8BE5; obd &#x8BBE;&#x5907;&#x7684;&#x8BBE;&#x7F6E;&#x5DF2;&#x7ECF;&#x5F00;&#x59CB;&#x72B6;&#x6001;&#xFF08;&#x89C1;Source Code 8&#xFF09;&#x3002;&#x63A5;&#x4E0B;&#x6765;&#xFF0C;&#x4F7F;&#x7528; Linux &#x5185;&#x6838;&#x5185;&#x7F6E;&#x51FD;&#x6570; rhashtable_init() &#x548C; rhltable_init() &#x8BBE;&#x7F6E; uuid-export &#x548C; nid-export &#x54C8;&#x5E0C;&#x8868;&#x3002;&#x5BF9;&#x4E8E; nid-stats &#x54C8;&#x5E0C;&#x8868;&#xFF0C;Lustre &#x4F7F;&#x7528;&#x81EA;&#x5DF1;&#x5B9E;&#x73B0;&#x7684; hashtable &#x5B9E;&#x73B0;&#xFF0C;&#x5373;cfs_hash&#x3002;</p>
</blockquote>
<p>A generic device setup function obd_setup() defined in include/obd_class.h is then invoked by class_setup() by passing the odb_device structure populated and the corresponding lcfg command (LCFG_SETUP). This leads to the invocation of device specific setup routines from various subsystems such as mgc_setup(), lwp_setup(), osc_setup_common() and so on. All of these setup routines invoke a client_obd_setup() routine that acts as a pre-setup stage before the creation of imports for the clients as shown in Figure 13. The client_obd_setup() defined in ldlm/ldlm_lib.c function populates client_obd structure defined in include/obd.h as shown in Source Code 14. Note that the client_obd_setup() routine is called only in case of client obd devices like osp, lwp, mgc, osc, and mdc.</p>
<blockquote>
<p>&#x7136;&#x540E;&#xFF0C;class_setup() &#x8C03;&#x7528;&#x901A;&#x7528;&#x8BBE;&#x5907;&#x8BBE;&#x7F6E;&#x51FD;&#x6570; obd_setup()&#xFF08;include/obd_class.h&#xFF09;&#xFF0C;&#x53C2;&#x6570;&#x662F;&#x5DF2;&#x7ECF;&#x586B;&#x5145;&#x597D;&#x7684; odb_device &#x7ED3;&#x6784;&#x548C;&#x76F8;&#x5E94;&#x7684; lcfg &#x547D;&#x4EE4;&#xFF08;LCFG_SETUP&#xFF09;&#x3002;&#x8FD9;&#x5C06;&#x5BFC;&#x81F4;&#x4ECE;&#x5404;&#x4E2A;&#x5B50;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x7279;&#x5B9A;&#x4E8E;&#x8BBE;&#x5907;&#x7684;&#x8BBE;&#x7F6E;&#x6D41;&#x7A0B;&#xFF0C;&#x5982; mgc_setup()&#x3001;lwp_setup()&#x3001;osc_setup_common() &#x7B49;&#x7B49;&#x3002;&#x6240;&#x6709;&#x8FD9;&#x4E9B;&#x8BBE;&#x7F6E;&#x6D41;&#x7A0B;&#x90FD;&#x8C03;&#x7528; client_obd_setup()&#xFF08;ldlm/ldlm_lib.c&#xFF09;&#xFF0C;&#x8BE5;&#x51FD;&#x6570;&#x4E3A;&#x5BA2;&#x6237;&#x7AEF;&#x5728;&#x521B;&#x5EFA;&#x5BFC;&#x5165;&#x4E4B;&#x524D;&#x8FDB;&#x884C;&#x9884;&#x8BBE;&#x7F6E;&#xFF0C;&#x5982;&#x56FE;13&#x6240;&#x793A;&#x3002;&#x5B83;&#x586B;&#x5145;&#x4E86; client_obd &#x7ED3;&#x6784;&#xFF08;include/obd.h&#xFF09;&#xFF0C;&#x5982; Source Code 14&#x6240;&#x793A;&#x3002;&#x8BF7;&#x6CE8;&#x610F;&#xFF0C;client_obd_setup() &#x4EC5;&#x5728;&#x5BA2;&#x6237;&#x7AEF; obd &#x8BBE;&#x5907;&#xFF08;&#x5982;osp&#x3001;lwp&#x3001;mgc&#x3001;osc&#x548C;mdc&#xFF09;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x88AB;&#x8C03;&#x7528;&#x3002;</p>
</blockquote>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/Class_setup.png" alt="Figure 13. Workflow of class_setup() function in obd device lifecycle">
    <figcaption style="font-size:12px">Figure 13. Workflow of class_setup() function in obd device lifecycle.</figcaption>
</div>

<p>Source Code 14: client_obd structure defined in include/obd.h</p>
<pre><code class="lang-c"><span class="hljs-keyword">struct</span>  client_obd {
        <span class="hljs-keyword">struct</span> rw_semaphore       cl_sem;
        <span class="hljs-keyword">struct</span> obd_uuid           cl_target_uuid;
        <span class="hljs-keyword">struct</span> obd_import         *cl_import; <span class="hljs-comment">/* ptlrpc connection state */</span>
        <span class="hljs-keyword">size_t</span>                    cl_conn_count;
        __u32                     cl_default_mds_easize;
        __u32                     cl_max_mds_easize;
        <span class="hljs-keyword">struct</span> cl_client_cache    *cl_cache;
        <span class="hljs-keyword">atomic_long_t</span>             *cl_lru_left;
        <span class="hljs-keyword">atomic_long_t</span>             cl_lru_busy;
        <span class="hljs-keyword">atomic_long_t</span>             cl_lru_in_list;
        . . . . .
};
</code></pre>
<p>client_obd structure is mainly used for page cache and extended attributes management. It comprises of fields pointing to obd device uuid and import interfaces, counter to keep track of client connections and fields to represent maximum and default extended attribute sizes. Few other fields used for cache handling are cl_cache - LRU cache for caching OSC pages, cl_lru_left - available LRU slots per OSC cache, cl_lru_busy - number of busy LRU pages, and cl_lru_in_list - number of LRU pages in the cache for this client_obd. Please also refer source code to see additional fields in the structure.</p>
<blockquote>
<p>client_obd &#x7ED3;&#x6784;&#x4E3B;&#x8981;&#x7528;&#x4E8E;&#x9875;&#x9762;&#x7F13;&#x5B58;&#x548C;&#x6269;&#x5C55;&#x5C5E;&#x6027;&#x7BA1;&#x7406;&#x3002;&#x5B83;&#x5305;&#x542B;&#x6307;&#x5411; obd &#x8BBE;&#x5907; uuid &#x548C;&#x5BFC;&#x5165;&#x63A5;&#x53E3;&#x7684;&#x5B57;&#x6BB5;&#xFF0C;&#x7528;&#x4E8E;&#x8DDF;&#x8E2A;&#x5BA2;&#x6237;&#x7AEF;&#x8FDE;&#x63A5;&#x7684;&#x8BA1;&#x6570;&#x5668;&#xFF0C;&#x4EE5;&#x53CA;&#x8868;&#x793A;&#x6700;&#x5927;&#x548C;&#x9ED8;&#x8BA4;&#x6269;&#x5C55;&#x5C5E;&#x6027;&#x5927;&#x5C0F;&#x7684;&#x5B57;&#x6BB5;&#x3002;&#x7528;&#x4E8E;&#x7F13;&#x5B58;&#x5904;&#x7406;&#x7684;&#x5176;&#x4ED6;&#x4E00;&#x4E9B;&#x5B57;&#x6BB5;&#x5305;&#x62EC; cl_cache - &#x7528;&#x4E8E;&#x7F13;&#x5B58; OSC &#x9875;&#x9762;&#x7684; LRU &#x7F13;&#x5B58;&#xFF0C;cl_lru_left - &#x6BCF;&#x4E2A; OSC &#x7F13;&#x5B58;&#x4E2D;&#x53EF;&#x7528;&#x7684; LRU &#x7684; slot &#x6570;&#xFF0C;cl_lru_busy - &#x5FD9;&#x72B6;&#x6001;&#x7684; LRU &#x9875;&#x9762;&#x6570;&#xFF0C;&#x4EE5;&#x53CA;c l_lru_in_list - &#x6B64; client_obd &#x7F13;&#x5B58;&#x5728;&#x7F13;&#x5B58; LRU &#x9875;&#x9762;&#x6570;&#x3002;&#x8BF7;&#x53C2;&#x8003;&#x6E90;&#x4EE3;&#x7801;&#x4EE5;&#x67E5;&#x770B;&#x7ED3;&#x6784;&#x4E2D;&#x7684;&#x5176;&#x4ED6;&#x5B57;&#x6BB5;&#x3002;</p>
</blockquote>
<p>The client_obd_setup() then obtains an LDLM lock to setup the LDLM layer references for this client obd device. Further it sets up ptl-rpc request and reply portals using the ptlrpc_init_client() routine defined in ptlrpc/client.c. The client_obd structure defines a pointer to the obd_import structure defined in include/lustre_import.h. The obd_import structure represents ptl-rpc imports that are client-side view of remote targets. A new import connection for the obd device is created using the function class_new_import(). The class_new_import() method populates obd_import structure defined in include/lustre_import.h as shown in Source Code 15.</p>
<blockquote>
<p>&#x63A5;&#x4E0B;&#x6765;&#xFF0C;client_obd_setup() &#x51FD;&#x6570;&#x83B7;&#x53D6;&#x4E00;&#x4E2A; LDLM &#x9501;&#x6765;&#x8BBE;&#x7F6E; LDLM &#x5C42;&#x5BF9;&#x4E8E;&#x8FD9;&#x4E2A;&#x5BA2;&#x6237;&#x7AEF; obd &#x8BBE;&#x5907;&#x7684;&#x5F15;&#x7528;&#x3002;&#x7136;&#x540E;&#xFF0C;&#x5B83;&#x4F7F;&#x7528; ptlrpc_init_client()&#xFF08;ptlrpc/client.c&#xFF09;&#x8BBE;&#x7F6E; ptl-rpc &#x8BF7;&#x6C42;&#x548C;&#x56DE;&#x590D;&#x7AEF;&#x53E3;&#x3002;client_obd &#x7ED3;&#x6784;&#x5B9A;&#x4E49;&#x4E86;&#x6307;&#x5411; obd_import &#x7ED3;&#x6784;&#xFF08;include/lustre_import.h&#xFF09;&#x7684;&#x6307;&#x9488;&#x3002;obd_import &#x7ED3;&#x6784;&#x8868;&#x793A;&#x662F;&#x8FDC;&#x7A0B;&#x76EE;&#x6807;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x89C6;&#x56FE;&#x7684; ptl-rpc &#x5BFC;&#x5165;&#x3002;&#x901A;&#x8FC7;&#x4F7F;&#x7528; class_new_import() &#x51FD;&#x6570;&#x521B;&#x5EFA;&#x4E86; obd &#x8BBE;&#x5907;&#x7684;&#x65B0;&#x5BFC;&#x5165;&#x8FDE;&#x63A5;&#x3002;class_new_import() &#x586B;&#x5145; obd_import &#x7ED3;&#x6784;&#xFF08;include/lustre_import.h&#xFF09;&#xFF0C;&#x5982; Source Code 15 &#x6240;&#x793A;&#x3002;</p>
</blockquote>
<p>The obd_import structure represents the client side view of a remote target. This structure mainly consists of fields representing ptl-rpc layer client and active connections on it, client side ldlm handle and various flags representing the status of imports such as imp_invalid, imp_deactive, and imp_replayable. There are also linked lists pointing to lists of requests that are retained for replay, waiting for a reply, and waiting for recovery to complete.</p>
<blockquote>
<p>obd_import &#x7ED3;&#x6784;&#x8868;&#x793A;&#x8FDC;&#x7A0B;&#x76EE;&#x6807;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x89C6;&#x56FE;&#x3002;&#x8BE5;&#x7ED3;&#x6784;&#x4E3B;&#x8981;&#x5305;&#x542B;&#x4EE3;&#x8868; ptl-rpc &#x5C42;&#x5BA2;&#x6237;&#x7AEF;&#x548C;&#x5176;&#x4E0A;&#x7684;&#x6D3B;&#x52A8;&#x8FDE;&#x63A5;&#x7684;&#x5B57;&#x6BB5;&#xFF0C;&#x5BA2;&#x6237;&#x7AEF; ldlm &#x53E5;&#x67C4;&#x4EE5;&#x53CA;&#x8868;&#x793A;&#x5BFC;&#x5165;&#x72B6;&#x6001;&#x7684;&#x5404;&#x79CD;&#x6807;&#x5FD7;&#xFF0C;&#x4F8B;&#x5982; imp_invalid&#x3001;imp_deactive &#x548C; imp_replayable&#x3002;&#x8FD8;&#x6709;&#x6307;&#x5411;&#x4FDD;&#x5B58;&#x91CD;&#x653E;&#x3001;&#x7B49;&#x5F85;&#x56DE;&#x590D;&#x548C;&#x7B49;&#x5F85;&#x6062;&#x590D;&#x5B8C;&#x6210;&#x7684;&#x8BF7;&#x6C42;&#x5217;&#x8868;&#x7684;&#x94FE;&#x8868;&#x3002;</p>
</blockquote>
<p>The client_obd_setup() then adds an initial connection for the obd device to the ptl-rpc layer by invoking client_import_add_conn() method. This method uses ptl-rpc layer specific routine ptlrpc_uuid_to_connection() to return a ptl-rpc connection specific for the uuid passed for the remote obd device. Finally client_obd_setup() creates a new ldlm namespace for the obd device that it just set up using the ldlm_namespace_new() routine. This completes the setup phase in the obd device lifecycle and the newly setup obd device can now be used for communications between subsystems in Lustre.</p>
<blockquote>
<p>&#x63A5;&#x4E0B;&#x6765;&#xFF0C;client_obd_setup() &#x8C03;&#x7528; client_import_add_conn() &#x4E3A; obd &#x8BBE;&#x5907;&#x6DFB;&#x52A0;&#x4E00;&#x4E2A;&#x521D;&#x59CB;&#x5316;&#x8FDE;&#x63A5;&#xFF0C;&#x5B83;&#x8FDE;&#x63A5;&#x5230; ptl-rpc &#x5C42;&#x3002;&#x8BE5;&#x65B9;&#x6CD5;&#x4F7F;&#x7528; ptl-rpc &#x5C42;&#x7279;&#x5B9A;&#x7684; ptlrpc_uuid_to_connection() &#x51FD;&#x6570;&#xFF0C;&#x63A5;&#x6536;&#x8FDC;&#x7A0B; obd &#x8BBE;&#x5907;&#x7684; UUID &#x4F5C;&#x4E3A;&#x53C2;&#x6570;&#xFF0C;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x7279;&#x5B9A; ptl-rpc &#x8FDE;&#x63A5;&#x3002;&#x6700;&#x540E;&#xFF0C;client_obd_setup() &#x4F7F;&#x7528; ldlm_namespace_new() &#x4E3A;&#x521A;&#x521A;&#x8BBE;&#x7F6E;&#x7684; obd &#x8BBE;&#x5907;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684; ldlm &#x547D;&#x540D;&#x7A7A;&#x95F4;&#x3002;&#x5B8C;&#x6210;&#x4E86; obd &#x8BBE;&#x5907;&#x751F;&#x547D;&#x5468;&#x671F;&#x4E2D;&#x7684;&#x8BBE;&#x7F6E;&#x9636;&#x6BB5;&#x540E;&#xFF0C;&#x65B0;&#x8BBE;&#x7F6E;&#x7684; obd &#x8BBE;&#x5907;&#x53EF;&#x4EE5;&#x7528;&#x4E8E; Lustre &#x4E2D;&#x5B50;&#x7CFB;&#x7EDF;&#x4E4B;&#x95F4;&#x7684;&#x901A;&#x4FE1;&#x3002;</p>
</blockquote>
<p>Source code 15: obd_import structure defined in include/lustre_import.h</p>
<pre><code class="lang-c"><span class="hljs-keyword">struct</span> obd_import {
        <span class="hljs-keyword">refcount_t</span>                 imp_refcount;
        <span class="hljs-keyword">struct</span> lustre_handle       imp_dlm_handle;
        <span class="hljs-keyword">struct</span> ptlrpc_connection   *imp_connection;
        <span class="hljs-keyword">struct</span> ptlrpc_client       *imp_client;
        <span class="hljs-keyword">enum</span> lustre_imp_state      imp_state;
        <span class="hljs-keyword">struct</span> obd_import_conn     *imp_conn_current;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>              imp_invalid:<span class="hljs-number">1</span>,
                                    imp_deactive:<span class="hljs-number">1</span>,
                                    imp_replayable:<span class="hljs-number">1</span>,
        . . . . .
};
</code></pre>
<h2 id="classprecleanup-and-classcleanup"><a name="classprecleanup-and-classcleanup" class="plugin-anchor" href="#classprecleanup-and-classcleanup"><i class="fa fa-link" aria-hidden="true"></i></a>class_precleanup() and class_cleanup()</h2>
<p>Lustre unmount process begins from the ll_umount_begin() function defined as part of the lustre_super_operations structure (shown in Source Code 16). The ll_umount_begin() function accepts a super_block from which the metadata and data exports for the obd_device are extracted using the class_exp2obd() routine. The obd_force flag from obd_device structure is set to indicate that cleanup will be performed even though the obd reference count is greater than zero. Then it periodically checks and waits to finish until there are no outstanding requests from vfs layer.</p>
<blockquote>
<p>Lustre &#x5378;&#x8F7D;&#x6D41;&#x7A0B;&#x4ECE; lustre_super_operations &#x7ED3;&#x6784;&#x4E2D;&#x7684; ll_umount_begin() &#x51FD;&#x6570;&#x5F00;&#x59CB;&#xFF08;&#x5982;&#x6E90;&#x4EE3;&#x7801;16&#x6240;&#x793A;&#xFF09;&#x3002;ll_umount_begin() &#x51FD;&#x6570;&#x63A5;&#x6536;&#x4E00;&#x4E2A; super_block&#xFF0C;&#x901A;&#x8FC7; class_exp2obd() &#x83B7;&#x53D6; obd_device &#x7684;&#x5143;&#x6570;&#x636E;&#x548C;&#x6570;&#x636E;&#x5BFC;&#x51FA;&#x9879;&#x3002;&#x8BBE;&#x7F6E; obd_device &#x7ED3;&#x6784;&#x4E2D;&#x7684; obd_force &#x6807;&#x5FD7;&#xFF0C;&#x6807;&#x660E;&#x5373;&#x4F7F; obd &#x5F15;&#x7528;&#x8BA1;&#x6570;&#x5927;&#x4E8E;&#x96F6;&#xFF0C;&#x4E5F;&#x5C06;&#x6267;&#x884C;&#x6E05;&#x7406;&#x64CD;&#x4F5C;&#x3002;&#x7136;&#x540E;&#x5B83;&#x5468;&#x671F;&#x6027;&#x68C0;&#x67E5;&#x5E76;&#x7B49;&#x5F85;&#xFF0C;&#x76F4;&#x5230; vfs &#x5C42;&#x6CA1;&#x6709;&#x672A;&#x5B8C;&#x6210;&#x7684;&#x8BF7;&#x6C42;&#x3002;</p>
</blockquote>
<p>Source code 16: lustre_super_operations structure defined in llite/super25.c</p>
<pre><code class="lang-c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> super_operations lustre_super_operations =
{
        .alloc_inode   = ll_alloc_inode,
        .destroy_inode = ll_destroy_inode,
        .drop_inode    = ll_drop_inode,
        .evict_inode   = ll_delete_inode,
        .put_super     = ll_put_super,
        .statfs        = ll_statfs,
        .umount_begin  = ll_umount_begin,
        .remount_fs    = ll_remount_fs,
        .show_options  = ll_show_options,
};
</code></pre>
<p>The cleanup cycle then invokes the ll<em>put_super() routine defined in llite/llite_lib.c. This function obtains the cfg_instance and profile name corresponding to the super_block using ll</em> get_ cfg_instance() and get_profile_name() functions respectively. Next it invokes lustre_end_log() routine by passing the super block, profile name and a config llog instance initialized here. The lustre_end_log() function defined in obdclass/obd_mount.c ensures to stop following updates for the config log corresponding to the config llog instance passed. lustre_end_log() resets lustre config buffers and calls obd_process_config() by passing the lcfg command LCFG_LOG_END and MGC as obd device. This results in the invocation of mgc_process_config() which calls config_log_end() method when LCFG_LOG_END is passed. The config_log_end() finds the config log and stops watching updates for the log.</p>
<blockquote>
<p>&#x6E05;&#x7406;&#x5FAA;&#x73AF;&#x63A5;&#x4E0B;&#x6765;&#x8C03;&#x7528; ll_put_super()(llite/llite_lib.c)&#x3002;&#x6B64;&#x51FD;&#x6570;&#x4F7F;&#x7528; ll_get_cfg_instance() &#x548C; get_profile_name() &#x51FD;&#x6570;&#x5206;&#x522B;&#x83B7;&#x53D6; super_block &#x5BF9;&#x5E94;&#x7684; cfg_instance &#x548C; profile &#x540D;&#x79F0;&#x3002;&#x7136;&#x540E;&#xFF0C;&#x5B83;&#x8C03;&#x7528;&#x4EE5; super_block&#x3001;profile &#x540D;&#x79F0;&#x548C;&#x5728;&#x6B64;&#x5904;&#x521D;&#x59CB;&#x5316;&#x7684; config llog &#x5B9E;&#x4F8B;&#x4F5C;&#x4E3A;&#x53C2;&#x6570; lustre_end_log() &#x51FD;&#x6570;&#x3002;lustre_end_log()&#x51FD;&#x6570;&#xFF08;obdclass/obd_mount.c&#xFF09;&#x786E;&#x4FDD;&#x505C;&#x6B62;&#x76F8;&#x5E94;&#x4E8E;&#x7684; config llog &#x5B9E;&#x4F8B;&#x53C2;&#x6570;&#x7684;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x7684;&#x540E;&#x7EED;&#x66F4;&#x65B0;&#x3002;lustre_end_log() &#x91CD;&#x7F6E; lustre &#x914D;&#x7F6E;&#x7F13;&#x51B2;&#x533A;&#xFF0C;&#x4F7F;&#x7528; lcfg &#x547D;&#x4EE4; LCFG_LOG_END &#x548C; MGC &#x4F5C;&#x4E3A; obd &#x8BBE;&#x5907;&#x53C2;&#x6570;&#x8C03;&#x7528; obd_process_config()&#x3002;&#x800C;&#x5B83;&#x5C06;&#x8C03;&#x7528; mgc_process_config()&#xFF0C;&#x5F53;&#x53C2;&#x6570;&#x4E3A; LCFG_LOG_END &#x65F6;&#xFF0C;&#x5B83;&#x8C03;&#x7528; config_log_end() &#x51FD;&#x6570;&#x3002;config_log_end() &#x627E;&#x5230;&#x914D;&#x7F6E;&#x65E5;&#x5FD7;&#x5E76;&#x505C;&#x6B62;&#x76D1;&#x89C6;&#x65E5;&#x5FD7;&#x7684;&#x66F4;&#x65B0;&#x3002;</p>
</blockquote>
<p>Further ll_put_super() invokes class_devices_in_group() method which iterates through the obd devices with same group uuid and sets the obd_force flag for all the devices. Afterwards it calls class_manual_cleanup() routine which invokes obdclass functions class_cleanup() and class_detach() in the order. The class_cleanup() is invoked through class_process_config() by passing the LCFG_CLEANUP command.</p>
<blockquote>
<p>&#x63A5;&#x4E0B;&#x6765;&#xFF0C;ll_put_super() &#x8C03;&#x7528; class_devices_in_group()&#xFF0C;&#x5B83;&#x8FED;&#x4EE3;&#x5177;&#x6709;&#x76F8;&#x540C;&#x7EC4; UUID &#x7684; obd &#x8BBE;&#x5907;&#xFF0C;&#x5E76;&#x4E3A;&#x6240;&#x6709;&#x8BBE;&#x5907;&#x8BBE;&#x7F6E; obd_force &#x6807;&#x5FD7;&#x3002;&#x7136;&#x540E;&#x5B83;&#x8C03;&#x7528; class_manual_cleanup()&#xFF0C;&#x5B83;&#x6309;&#x987A;&#x5E8F;&#x8C03;&#x7528;obdclass &#x51FD;&#x6570; class_cleanup() &#x548C; class_detach()&#x3002;</p>
</blockquote>
<p>class_cleanup() starts the shut down process of the obd device. This first sets the obd_stopping flag to indicate that cleanup has started and then waits for any already arrived connection requests to complete. Once all the requests are completed it disconnects all the exports using class_disconnect_exports() function (shown in Figure 14). It then invokes obd generic function obd_precleanup() that ensures that all exports get destroyed. obd_precleanup() calls device specific precleanup function (e.g. mgc_precleanup()). class_cleanup() then destroys the uuid-export, nid-export, and nid-stats hashtables and invokes class_decref() function. class_decref() function asserts that all exports are destroyed.</p>
<blockquote>
<p>class_cleanup() &#x5F00;&#x59CB; obd &#x8BBE;&#x5907;&#x7684;&#x5173;&#x95ED;&#x6D41;&#x7A0B;&#x3002;&#x9996;&#x5148;&#x5C06; obd_stopping &#x6807;&#x5FD7;&#x8BBE;&#x7F6E;&#x4E3A;&#x6307;&#x793A;&#x6E05;&#x7406;&#x5DF2;&#x5F00;&#x59CB;&#x72B6;&#x6001;&#xFF0C;&#x7136;&#x540E;&#x7B49;&#x5F85;&#x4EFB;&#x4F55;&#x5DF2;&#x7ECF;&#x5230;&#x8FBE;&#x7684;&#x8FDE;&#x63A5;&#x8BF7;&#x6C42;&#x5B8C;&#x6210;&#x3002;&#x4E00;&#x65E6;&#x6240;&#x6709;&#x8BF7;&#x6C42;&#x5B8C;&#x6210;&#xFF0C;&#x5B83;&#x4F7F;&#x7528;class_disconnect_exports() &#x51FD;&#x6570;&#xFF08;&#x56FE;14&#xFF09;&#x65AD;&#x5F00;&#x6240;&#x6709;&#x5BFC;&#x51FA;&#x3002;&#x7136;&#x540E;&#xFF0C;&#x5B83;&#x8C03;&#x7528; obd &#x901A;&#x7528;&#x51FD;&#x6570; obd_precleanup()&#xFF0C;&#x4EE5;&#x786E;&#x4FDD;&#x6240;&#x6709;&#x5BFC;&#x51FA;&#x90FD;&#x88AB;&#x9500;&#x6BC1;&#x3002;obd_precleanup() &#x8C03;&#x7528;&#x8BBE;&#x5907;&#x7279;&#x5B9A;&#x7684; precleanup &#x51FD;&#x6570;&#xFF08;&#x4F8B;&#x5982;mgc_precleanup()&#xFF09;&#x3002;&#x7136;&#x540E; class_cleanup() &#x9500;&#x6BC1; uuid-export&#x3001;nid-export &#x548C; nid-stats &#x54C8;&#x5E0C;&#x8868;&#xFF0C;&#x5E76;&#x8C03;&#x7528; class_decref() &#x51FD;&#x6570;&#x3002;class_decref() &#x51FD;&#x6570;&#x65AD;&#x8A00;&#x6240;&#x6709;&#x5BFC;&#x51FA;&#x90FD;&#x88AB;&#x9500;&#x6BC1;&#x3002;</p>
</blockquote>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/Class_cleanup_1.png" alt="Figure 14. Lustre unmounting and initiation of class_cleanup() in obd device lifecycle.">
    <figcaption style="font-size:12px">Figure 14. Lustre unmounting and initiation of class_cleanup() in obd device lifecycle.</figcaption>
</div>

<p>class_manual_cleanup() then invokes class_detach() function by passing the LCFG_DETACH command. class_detach() (defined in obdclass/obd_config.c) makes the obd_attached flag to zero and unregisters the device (frees the slot in obd_devs array) using class_unregister_device() function. Next it invokes the class_decref() routine that destroys the last export (self export) by calling class_unlink_export() method. class_unlink_export() calls class_export_put() that frees the obd device using class_free_dev() function. class_free_dev() calls device specific cleanup through obd_cleanup() and finally invokes class_put_type() routine that unloads the module. This is the end of the life cycle for the obd device. An end to end workflow of class_cleanup() routine is illustrated in Figure 15.</p>
<blockquote>
<p>&#x7136;&#x540E; class_manual_cleanup() &#x901A;&#x8FC7; LCFG_DETACH &#x547D;&#x4EE4;&#x4F5C;&#x4E3A;&#x53C2;&#x6570;&#x8C03;&#x7528; class_detach() &#x51FD;&#x6570;&#x3002;class_detach()&#xFF08;obdclass/obd_config.c&#xFF09;&#x5C06; obd_attached &#x6807;&#x5FD7;&#x8BBE;&#x7F6E;&#x4E3A;&#x96F6;&#xFF0C;&#x5E76;&#x4F7F;&#x7528;class_unregister_device() &#x51FD;&#x6570;&#x53D6;&#x6D88;&#x6CE8;&#x518C;&#x8BBE;&#x5907;&#xFF08;&#x91CA;&#x653E; obd_devs &#x6570;&#x7EC4;&#x4E2D;&#x7684; slot&#xFF09;&#x3002;&#x63A5;&#x4E0B;&#x6765;&#xFF0C;&#x5B83;&#x901A;&#x8FC7;&#x8C03;&#x7528; class_unlink_export() &#x8C03;&#x7528; class_decref()&#xFF0C;class_decref &#x901A;&#x8FC7;&#x8C03;&#x7528;class_export_put() &#x91CA;&#x653E;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x5BFC;&#x51FA;&#xFF08;&#x81EA;&#x5BFC;&#x51FA;&#xFF09;&#x3002;class_unlink_export() &#x8C03;&#x7528; class_free_dev() &#x51FD;&#x6570;&#x91CA;&#x653E; obd &#x8BBE;&#x5907;&#x3002;class_free_dev() &#x901A;&#x8FC7; obd_cleanup() &#x8C03;&#x7528;&#x8BBE;&#x5907;&#x7279;&#x5B9A;&#x7684;&#x6E05;&#x7406;&#x51FD;&#x6570;&#xFF0C;&#x6700;&#x540E;&#x8C03;&#x7528; class_put_type() &#x5378;&#x8F7D;&#x6A21;&#x5757;&#x3002;&#x8FD9;&#x6807;&#x5FD7;&#x7740; obd &#x8BBE;&#x5907;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;&#x7684;&#x7ED3;&#x675F;&#x3002;class_cleanup() &#x7684;&#x7AEF;&#x5230;&#x7AEF;&#x5DE5;&#x4F5C;&#x6D41;&#x7A0B;&#x793A;&#x4F8B;&#x5982;&#x56FE;15&#x6240;&#x793A;&#x3002;</p>
</blockquote>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/Class_cleanup_2.png" alt="Figure 15. class_cleanup() workflow in obd device lifecycle.">
    <figcaption style="font-size:12px">Figure 15. class_cleanup() workflow in obd device lifecycle.</figcaption>
</div>

<h2 id="imports-and-exports"><a name="imports-and-exports" class="plugin-anchor" href="#imports-and-exports"><i class="fa fa-link" aria-hidden="true"></i></a>Imports and Exports</h2>
<p>Obd devices in Lustre are components including lmv, lod, lov, mdc, mdd, mdt, mds, mgc, mgs, obdecho, ofd, osc, osd-ldsikfs, osd-zfs, osp, lwp, ost, and qmt. Among these mdc, mgc, osc, osp, and lwp are client obd devices meaning two server odb device components such as mdt and ost need one client device to establish communication between them. This is also applicable in case of a Lustre client communicating with Lustre servers. Client side obd devices consist of self export and import whereas server side obd devices consist of exports and reverse imports. A client obd device sends requests to the server using its import and the server receives requests using its export as illustrated in Figure 16. The imports on server obd devices are called reverse imports because they are used to send requests to the client obd devices. These requests are mostly callback requests sent by the server to clients infrequently. And the client uses it&#x2019;s self export to receive these callback requests from the server.</p>
<blockquote>
<p>&#x5728; Lustre &#x4E2D;&#xFF0C;obd&#x8BBE;&#x5907;&#x662F;&#x5305;&#x62EC; lmv&#x3001;lod&#x3001;lov&#x3001;mdc&#x3001;mdd&#x3001;mdt&#x3001;mds&#x3001;mgc&#x3001;mgs&#x3001;obdecho&#x3001;ofd&#x3001;osc&#x3001;osd-ldsikfs&#x3001;osd-zfs&#x3001;osp&#x3001;lwp&#x3001;ost &#x548C; qmt &#x5728;&#x5185;&#x7684;&#x7EC4;&#x4EF6;&#x3002;&#x5176;&#x4E2D;&#xFF0C;mdc&#x3001;mgc&#x3001;osc&#x3001;osp &#x548C; lwp &#x662F;&#x5BA2;&#x6237;&#x7AEF; obd &#x8BBE;&#x5907;&#xFF0C;&#x8FD9;&#x610F;&#x5473;&#x7740;&#x4E24;&#x4E2A;&#x670D;&#x52A1;&#x7AEF; obd &#x8BBE;&#x5907;&#x7EC4;&#x4EF6;&#xFF08;&#x5982; mdt &#x548C; ost&#xFF09;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x5BA2;&#x6237;&#x7AEF;&#x8BBE;&#x5907;&#x6765;&#x5EFA;&#x7ACB;&#x5B83;&#x4EEC;&#x4E4B;&#x95F4;&#x7684;&#x901A;&#x4FE1;&#x3002;&#x8FD9;&#x5728; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x4E0E; Lustre &#x670D;&#x52A1;&#x7AEF;&#x901A;&#x4FE1;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x4E5F;&#x9002;&#x7528;&#x3002;&#x5BA2;&#x6237;&#x7AEF;Obd&#x8BBE;&#x5907;&#x7531;&#x81EA;&#x5BFC;&#x51FA;&#x548C;&#x5BFC;&#x5165;&#x7EC4;&#x6210;&#xFF0C;&#x800C;&#x670D;&#x52A1;&#x5668;&#x7AEF; obd &#x8BBE;&#x5907;&#x7531;&#x5BFC;&#x51FA;&#x548C;&#x53CD;&#x5411;&#x5BFC;&#x5165;&#x7EC4;&#x6210;&#x3002;&#x5BA2;&#x6237;&#x7AEF; obd &#x8BBE;&#x5907;&#x4F7F;&#x7528;&#x5176;&#x5BFC;&#x5165;&#x5411;&#x670D;&#x52A1;&#x5668;&#x53D1;&#x9001;&#x8BF7;&#x6C42;&#xFF0C;&#x670D;&#x52A1;&#x7AEF;&#x4F7F;&#x7528;&#x5176;&#x5BFC;&#x51FA;&#x63A5;&#x6536;&#x8BF7;&#x6C42;&#xFF0C;&#x5982;&#x56FE;16&#x6240;&#x793A;&#x3002;&#x670D;&#x52A1;&#x7AEF; obd &#x8BBE;&#x5907;&#x4E0A;&#x7684;&#x5BFC;&#x5165;&#x79F0;&#x4E3A;&#x53CD;&#x5411;&#x5BFC;&#x5165;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4EEC;&#x7528;&#x4E8E;&#x5411;&#x5BA2;&#x6237;&#x7AEF; obd &#x8BBE;&#x5907;&#x53D1;&#x9001;&#x8BF7;&#x6C42;&#x3002;&#x8FD9;&#x4E9B;&#x8BF7;&#x6C42;&#x901A;&#x5E38;&#x662F;&#x7531;&#x670D;&#x52A1;&#x7AEF;&#x53D1;&#x9001;&#x7ED9;&#x5BA2;&#x6237;&#x7AEF;&#x7684;&#x56DE;&#x8C03;&#x8BF7;&#x6C42;&#xFF0C;&#x4F46;&#x8BF7;&#x6C42;&#x5E76;&#x4E0D;&#x9891;&#x7E41;&#x3002;&#x5BA2;&#x6237;&#x7AEF;&#x4F7F;&#x7528;&#x81EA;&#x5BFC;&#x51FA;&#x6765;&#x63A5;&#x6536;&#x670D;&#x52A1;&#x5668;&#x53D1;&#x9001;&#x7684;&#x8FD9;&#x4E9B;&#x56DE;&#x8C03;&#x8BF7;&#x6C42;&#x3002;</p>
</blockquote>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/Import_export.png" alt="Figure 16 Import and export pair in Lustre">
    <figcaption style="font-size:12px">Figure 16 Import and export pair in Lustre.</figcaption>
</div>

<p>For any two obd devices to communicate with each other, they need an import and export pair [7]. For instance, let us consider the case of communication between ost and mdt obd devices. Logging into an OSS node and doing lctl dl shows the obd devices on the node and associated details (obd device status, type, name, uuid etc.). Examining /sys/fs/lustre directory can also show the obd devices corresponding to various device types. An example of the name of an obd device created for the data exchange between OST5 and MDT2 will be MDT2-lwp-OST5. This means that the client obd device that enables the communication here is lwp. A conceptual view of the communication between ost and mdt through import and export connections is shown in Figure 17. LWP (Light Weight Proxy) obd device manages connections established from ost to mdt, and mdts to mdt0. An lwp device is used in Lustre to send quota and FLD query requests (see Section 7). Figure 17 also shows the communication between mdt and ost through osp client obd device.</p>
<blockquote>
<p>&#x4E3A;&#x4E86;&#x4F7F;&#x4EFB;&#x610F;&#x4E24;&#x4E2A; obd &#x8BBE;&#x5907;&#x80FD;&#x4E92;&#x76F8;&#x901A;&#x4FE1;&#xFF0C;&#x5B83;&#x4EEC;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x5BFC;&#x5165;&#x548C;&#x5BFC;&#x51FA;&#x914D;&#x5BF9;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x8003;&#x8651; ost &#x548C; mdt obd &#x8BBE;&#x5907;&#x4E4B;&#x95F4;&#x7684;&#x901A;&#x4FE1;&#x60C5;&#x51B5;&#x3002;&#x767B;&#x5F55;&#x5230; OSS &#x8282;&#x70B9;&#x5E76;&#x6267;&#x884C; lctl dl &#x547D;&#x4EE4;&#x4F1A;&#x663E;&#x793A;&#x8282;&#x70B9;&#x4E0A;&#x7684; obd &#x8BBE;&#x5907;&#x53CA;&#x5176;&#x76F8;&#x5173;&#x8BE6;&#x7EC6;&#x4FE1;&#x606F;&#xFF08;obd&#x8BBE;&#x5907;&#x72B6;&#x6001;&#x3001;&#x7C7B;&#x578B;&#x3001;&#x540D;&#x79F0;&#x3001;UUID&#x7B49;&#xFF09;&#x3002;&#x68C0;&#x67E5; /sys/fs/lustre &#x76EE;&#x5F55;&#x4E5F;&#x53EF;&#x4EE5;&#x663E;&#x793A;&#x4E0E;&#x5404;&#x79CD;&#x8BBE;&#x5907;&#x7C7B;&#x578B;&#x5BF9;&#x5E94;&#x7684; obd &#x8BBE;&#x5907;&#x3002;&#x4E00;&#x4E2A;&#x4F8B;&#x5B50;&#xFF1A;&#x7528;&#x4E8E; OST5 &#x548C; MDT2 &#x4E4B;&#x95F4;&#x6570;&#x636E;&#x4EA4;&#x6362;&#x7684; obd &#x8BBE;&#x5907;&#x7684;&#x540D;&#x79F0;&#x662F;MDT2-lwp-OST5&#x3002;&#x8FD9;&#x610F;&#x5473;&#x7740;&#x5728;&#x8FD9;&#x91CC;&#x542F;&#x7528;&#x901A;&#x4FE1;&#x7684;&#x5BA2;&#x6237;&#x7AEF; obd &#x8BBE;&#x5907;&#x662F; lwp&#x3002;&#x56FE;17&#x5C55;&#x793A;&#x4E86;&#x901A;&#x8FC7;&#x5BFC;&#x5165;&#x548C;&#x5BFC;&#x51FA;&#x8FDE;&#x63A5;&#x5728; ost &#x548C; mdt &#x4E4B;&#x95F4;&#x901A;&#x4FE1;&#x7684;&#x6982;&#x5FF5;&#x89C6;&#x56FE;&#x3002;LWP&#xFF08;&#x8F7B;&#x91CF;&#x7EA7;&#x4EE3;&#x7406;&#xFF09;obd &#x8BBE;&#x5907;&#x7BA1;&#x7406;&#x4ECE; ost &#x5230; mdt &#x548C;&#x4ECE; mdts &#x5230; mdt0 &#x5EFA;&#x7ACB;&#x7684;&#x8FDE;&#x63A5;&#x3002;&#x5728; Lustre &#x4E2D;&#xFF0C;&#x4F7F;&#x7528; lwp &#x8BBE;&#x5907;&#x53D1;&#x9001;&#x914D;&#x989D;&#x548C; FLD &#x67E5;&#x8BE2;&#x8BF7;&#x6C42;&#xFF08;&#x53C2;&#x89C1;&#x7B2C;7&#x8282;&#xFF09;&#x3002;&#x56FE;17&#x8FD8;&#x663E;&#x793A;&#x4E86;&#x901A;&#x8FC7; osp &#x5BA2;&#x6237;&#x7AEF; obd&#x8BBE;&#x5907;&#x5728; mdt &#x548C; ost &#x4E4B;&#x95F4;&#x8FDB;&#x884C;&#x7684;&#x901A;&#x4FE1;&#x3002;</p>
</blockquote>
<div align="center" style="margin-bottom:12px;margin-top:12px">
    <img src="../../image/Understanding-Lustre-Internals-&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;/Ost_mdt_comm.png" alt="Figure 17. Communication between ost and mdt server obd devices in Lustre">
    <figcaption style="font-size:12px">Figure 17. Communication between ost and mdt server obd devices in Lustre.</figcaption>
</div>

<ul>
<li><p><code>name</code>: Shows the name of the ost device.</p>
<blockquote>
<p>name: &#x663E;&#x793A;ost&#x8BBE;&#x5907;&#x7684;&#x540D;&#x79F0;&#x3002;</p>
</blockquote>
</li>
<li><p><code>client</code>: The nid of the client export connection. (nid of MDT2 in this example.)</p>
<blockquote>
<p>client: &#x5BA2;&#x6237;&#x7AEF;&#x5BFC;&#x51FA;&#x8FDE;&#x63A5;&#x7684;nid&#xFF08;&#x5728;&#x672C;&#x4F8B;&#x4E2D;&#x4E3A;MDT2&#x7684;nid&#xFF09;&#x3002;</p>
</blockquote>
</li>
<li><p><code>connect_flags</code>: Flags representing various configurations for the lnet and ptl-rpc connections between the obd devices.</p>
<blockquote>
<p>connect_flags: &#x8868;&#x793A;obd&#x8BBE;&#x5907;&#x4E4B;&#x95F4;lnet&#x548C;ptl-rpc&#x8FDE;&#x63A5;&#x7684;&#x5404;&#x79CD;&#x914D;&#x7F6E;&#x7684;&#x6807;&#x5FD7;&#x3002;</p>
</blockquote>
</li>
<li><p><code>connect_data</code>: Includes fields such as flags, instance, target_version, mdt_index and target_index.</p>
<blockquote>
<p>connect_data: &#x5305;&#x62EC;&#x6807;&#x5FD7;&#x3001;&#x5B9E;&#x4F8B;&#x3001;&#x76EE;&#x6807;&#x7248;&#x672C;&#x3001;mdt&#x7D22;&#x5F15;&#x548C;&#x76EE;&#x6807;&#x7D22;&#x5F15;&#x7B49;&#x5B57;&#x6BB5;&#x3002;</p>
</blockquote>
</li>
<li><p><code>export_flags</code>: Configuration flags for export connection.</p>
<blockquote>
<p>export_flags: &#x5BFC;&#x51FA;&#x8FDE;&#x63A5;&#x7684;&#x914D;&#x7F6E;&#x6807;&#x5FD7;&#x3002;</p>
</blockquote>
</li>
<li><p><code>grant</code>: Represents target specific export data.</p>
<blockquote>
<p>grant: &#x8868;&#x793A;&#x7279;&#x5B9A;&#x76EE;&#x6807;&#x7684;&#x5BFC;&#x51FA;&#x6570;&#x636E;&#x3002;</p>
</blockquote>
</li>
</ul>
<h2 id="useful-apis-in-obdclass"><a name="useful-apis-in-obdclass" class="plugin-anchor" href="#useful-apis-in-obdclass"><i class="fa fa-link" aria-hidden="true"></i></a>Useful APIs in Obdclass</h2>
<p>All obdclass related function declarations are listed in the file include/obd_class.h and their definitions can be seen in obdclass/genops.c Here we list some of the important obdclass function prototypes and their purpose for quick reference.</p>
<blockquote>
<p>&#x6240;&#x6709;&#x4E0E; obdclass &#x76F8;&#x5173;&#x7684;&#x51FD;&#x6570;&#x58F0;&#x660E;&#x90FD;&#x5728; include/obd_class.h &#x6587;&#x4EF6;&#x4E2D;&#xFF0C;&#x5B83;&#x4EEC;&#x7684;&#x5B9A;&#x4E49;&#x53EF;&#x4EE5;&#x5728; obdclass/genops.c &#x4E2D;&#x627E;&#x5230;&#x3002;&#x4EE5;&#x4E0B;&#x662F;&#x4E00;&#x4E9B;&#x91CD;&#x8981;&#x7684; obdclass &#x51FD;&#x6570;&#x539F;&#x578B;&#x53CA;&#x5176;&#x4F5C;&#x7528;&#xFF0C;&#x4EE5;&#x4F9B;&#x5FEB;&#x901F;&#x53C2;&#x8003;&#x4F7F;&#x7528;&#x3002;</p>
</blockquote>
<ul>
<li><p>class_newdev() - Creates a new obd device, allocates and initializes it.</p>
<blockquote>
<p>class_newdev() - &#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684; obd &#x8BBE;&#x5907;&#xFF0C;&#x5206;&#x914D;&#x5E76;&#x521D;&#x59CB;&#x5316;&#x5B83;&#x3002;</p>
</blockquote>
</li>
<li><p>class_free_dev() - Frees an obd devic</p>
<blockquote>
<p>class_free_dev() - &#x91CA;&#x653E;&#x4E00;&#x4E2A; obd &#x8BBE;&#x5907;&#x3002;</p>
</blockquote>
</li>
<li><p>class_unregister_device() - Unregisters an obd device by feeing its slot in obd_devs array.</p>
<blockquote>
<p>class_unregister_device() - &#x901A;&#x8FC7;&#x91CA;&#x653E; obd_devs &#x6570;&#x7EC4;&#x4E2D;&#x7684; slot &#x6765;&#x6CE8;&#x9500;&#x4E00;&#x4E2A; obd &#x8BBE;&#x5907;&#x3002;</p>
</blockquote>
</li>
<li><p>class_register_device() - Registers obd device by finding a free slot in in obd_devs array and filling it with the new obd device.</p>
<blockquote>
<p>class_register_device() -   &#x901A;&#x8FC7;&#x5728; obd_devs &#x6570;&#x7EC4;&#x4E2D;&#x627E;&#x5230;&#x4E00;&#x4E2A;&#x7A7A;&#x95F2;&#x69FD;&#x4F4D;&#x5E76;&#x5C06;&#x5176;&#x586B;&#x5145;&#x4E3A;&#x65B0;&#x7684; obd &#x8BBE;&#x5907;&#x6765;&#x6CE8;&#x518C; obd &#x8BBE;&#x5907;&#x3002;</p>
</blockquote>
</li>
<li><p>class_name2dev() - Returns minor number corresponding to an obd device name.</p>
<blockquote>
<p>class_name2dev() - &#x8FD4;&#x56DE;&#x4E0E; obd &#x8BBE;&#x5907;&#x540D;&#x79F0;&#x5BF9;&#x5E94;&#x7684;&#x6B21;&#x8BBE;&#x5907;&#x53F7;&#x3002;</p>
</blockquote>
</li>
<li><p>class_name2obd() - Returns pointer to an obd_device structure corresponding to the device name.</p>
<blockquote>
<p>class_name2obd() - &#x8FD4;&#x56DE;&#x4E0E;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#x5BF9;&#x5E94;&#x7684; obd_device &#x7ED3;&#x6784;&#x7684;&#x6307;&#x9488;&#x3002;</p>
</blockquote>
</li>
<li><p>class_uuid2dev() - Returns minor number of an obd device when uuid is provided.</p>
<blockquote>
<p>class_uuid2dev() - &#x5728;&#x63D0;&#x4F9B; UUID &#x65F6;&#x8FD4;&#x56DE; obd &#x8BBE;&#x5907;&#x7684;&#x6B21;&#x8BBE;&#x5907;&#x53F7;&#x3002;</p>
</blockquote>
</li>
<li><p>class_uuid2obd() - Returns obd_device structure pointer corresponding to a uuid.</p>
<blockquote>
<p>class_uuid2obd() - &#x8FD4;&#x56DE;&#x4E0E; UUID &#x5BF9;&#x5E94;&#x7684; obd_device &#x7ED3;&#x6784;&#x7684;&#x6307;&#x9488;&#x3002;</p>
</blockquote>
</li>
<li><p>class_num2obd() - Returns obd_device structure corresponding to a minor number.</p>
<blockquote>
<p>class_num2obd() - &#x8FD4;&#x56DE;&#x4E0E;&#x6B21;&#x8BBE;&#x5907;&#x53F7;&#x5BF9;&#x5E94;&#x7684; obd_device &#x7ED3;&#x6784;&#x3002;</p>
</blockquote>
</li>
<li><p>class_dev_by_str() - Finds an obd device in the obd_devs array by name or uuid. Also increments obd reference count if its found.</p>
<blockquote>
<p>class_dev_by_str() -   &#x901A;&#x8FC7;&#x540D;&#x79F0;&#x6216; UUID &#x5728; obd_devs &#x6570;&#x7EC4;&#x4E2D;&#x67E5;&#x627E; obd &#x8BBE;&#x5907;&#x3002;&#x5982;&#x679C;&#x627E;&#x5230;&#xFF0C;&#x5219;&#x589E;&#x52A0; obd &#x7684;&#x5F15;&#x7528;&#x8BA1;&#x6570;&#x3002;</p>
</blockquote>
</li>
<li><p>get_devices_count() - Gets the count of the obd devices in any state.</p>
<blockquote>
<p>get_devices_count() - &#x83B7;&#x53D6; obd &#x8BBE;&#x5907;&#x7684;&#x6570;&#x91CF;&#x3002;</p>
</blockquote>
</li>
<li><p>class_find_client_obd() - Searches for a client obd connected to a target obd device.</p>
<blockquote>
<p>class_find_client_obd() - &#x641C;&#x7D22;&#x8FDE;&#x63A5;&#x5230;&#x76EE;&#x6807; obd &#x8BBE;&#x5907;&#x7684;&#x5BA2;&#x6237;&#x7AEF; obd&#x3002;</p>
</blockquote>
</li>
<li><p>class_export_destroy() - Destroys and export connection of an obd device.</p>
<blockquote>
<p>class_export_destroy() - &#x9500;&#x6BC1; obd &#x8BBE;&#x5907;&#x7684;&#x5BFC;&#x51FA;&#x8FDE;&#x63A5;&#x3002;</p>
</blockquote>
</li>
<li><p>__class_new_export() - Creates a new export for an obd device and add its to the hash table of exports.</p>
<blockquote>
<p>__class_new_export() - &#x4E3A; obd &#x8BBE;&#x5907;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x5BFC;&#x51FA;&#x8FDE;&#x63A5;&#xFF0C;&#x5E76;&#x5C06;&#x5176;&#x6DFB;&#x52A0;&#x5230;&#x5BFC;&#x51FA;&#x54C8;&#x5E0C;&#x8868;&#x4E2D;&#x3002;</p>
</blockquote>
</li>
</ul>
<h1 id="libcfs"><a name="libcfs" class="plugin-anchor" href="#libcfs"><i class="fa fa-link" aria-hidden="true"></i></a>LIBCFS</h1>
<h2 id="libcfs-introduction"><a name="libcfs-introduction" class="plugin-anchor" href="#libcfs-introduction"><i class="fa fa-link" aria-hidden="true"></i></a>Introduction</h2>

<p>Libcfs provides APIs comprising of fundamental primitives for process management and debugging support in Lustre. Libcfs is used throughout LNet, Lustre, and associated utilities. Its APIs define a portable run time environment that is implemented consistently on all supported build targets. Besides debugging support libcfs provides APIs for failure injection, Linux kernel compatibility, encryption for data, Linux 64 bit time addition, log collection using tracefile, string parsing support and capabilities for querying and manipulating CPU partition tables. Libcfs is the first module that Lustre loads. The module loading function can be found in tests/test-framework.sh script as shown in Source Code 17. When Lustre is mounted, mount_facet() function gets invoked and it calls load_modules() function. load_modules() invokes load_modules_local() that loads Lustre modules libcfs, lnet, obdclass, ptl-rpc, fld, fid, and lmv in the same order.</p>
<blockquote>
<p>&#x5728; Lustre &#x4E2D;&#xFF0C;Libcfs &#x63D0;&#x4F9B;&#x4E86;&#x8FDB;&#x7A0B;&#x7BA1;&#x7406;&#x548C;&#x8C03;&#x8BD5;&#x7684;&#x57FA;&#x7840; API&#x3002;Libcfs &#x88AB;&#x5927;&#x91CF;&#x5730;&#x4F7F;&#x7528;&#x5728; LNet&#x3001;Lustre &#x548C;&#x76F8;&#x5173;&#x5DE5;&#x5177;&#x4E2D;&#x3002;&#x5176; API &#x5B9A;&#x4E49;&#x4E86;&#x4E00;&#x5957;&#x53EF;&#x79FB;&#x690D;&#x7684;&#x8FD0;&#x884C;&#x65F6;&#x73AF;&#x5883;&#xFF0C;&#x4EE5;&#x8FFD;&#x6C42;&#x5728;&#x6240;&#x6709;&#x652F;&#x6301;&#x7684;&#x6784;&#x5EFA;&#x76EE;&#x6807;&#x4E0A;&#x7684;&#x4E00;&#x81F4;&#x5B9E;&#x73B0;&#x3002;&#x9664;&#x4E86;&#x8C03;&#x8BD5;&#x652F;&#x6301;&#x5916;&#xFF0C;Libcfs &#x8FD8;&#x63D0;&#x4F9B;&#x4E86;&#x9519;&#x8BEF;&#x6CE8;&#x5165;&#x3001;Linux &#x5185;&#x6838;&#x517C;&#x5BB9;&#x6027;&#x3001;&#x6570;&#x636E;&#x52A0;&#x5BC6;&#x3001;Linux 64 &#x4F4D;&#x65F6;&#x95F4;&#x52A0;&#x6CD5;<sup><a href="#fn_3" id="reffn_3">3</a></sup>&#x3001;&#x4F7F;&#x7528;&#x6587;&#x4EF6;&#x8DDF;&#x8E2A;&#x624B;&#x6BB5;&#x8FDB;&#x884C;&#x65E5;&#x5FD7;&#x6536;&#x96C6;&#x3001;&#x5B57;&#x7B26;&#x4E32;&#x89E3;&#x6790;&#x652F;&#x6301;&#x4EE5;&#x53CA;&#x67E5;&#x8BE2;&#x548C;&#x64CD;&#x4F5C; CPU &#x5206;&#x533A;&#x8868;&#x7684;&#x529F;&#x80FD;&#x3002;&#x5F53; lustre &#x88AB;&#x6302;&#x8F7D;&#x65F6;&#xFF0C;mount_facet() &#x51FD;&#x6570;&#x88AB;&#x8C03;&#x7528;&#xFF0C;&#x5B83;&#x8C03;&#x7528; load_modules() &#x51FD;&#x6570;&#x3002;load_modules() &#x51FD;&#x6570;&#x8C03;&#x7528; load_modules_local()&#xFF0C;&#x7528;&#x4E8E;&#x6309;&#x987A;&#x5E8F;&#x52A0;&#x8F7D; lustre &#x7684;&#x6A21;&#x5757;&#xFF1A;libcfs, lnet, obdclass, ptl-rpc, fld, fid, and lmv&#x3002;</p>
</blockquote>
<p>In the following Sections we describe libcfs APIs and functionalities in detail.</p>
<blockquote>
<p>&#x5728;&#x63A5;&#x4E0B;&#x6765;&#x7684;&#x7AE0;&#x8282;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x8BE6;&#x7EC6;&#x5730;&#x63CF;&#x8FF0; libcfs APIs &#x548C;&#x5176; &#x529F;&#x80FD;&#x3002;</p>
</blockquote>
<h2 id="data-encryption-support-in-libcfs"><a name="data-encryption-support-in-libcfs" class="plugin-anchor" href="#data-encryption-support-in-libcfs"><i class="fa fa-link" aria-hidden="true"></i></a>Data Encryption Support in Libcfs</h2>
<p>Lustre implements two types of encryption capabilities - data on the wire and data at rest. Encryption over the wire protects data transfers between the physical nodes from Man-in-the-middle attacks. Whereas the objective of encrypting data at rest is protection against storage theft and network snooping. Lustre 2.14+ releases provides encryption for data at rest. Data is encrypted on Lustre client before being sent to servers and decrypted upon reception from the servers. That way applications running on Lustre client see clear text and servers see only encrypted text. Hence access to encryption keys is limited to Lustre clients.</p>
<blockquote>
<p>Lustre &#x5B9E;&#x73B0;&#x4E86;&#x4E24;&#x79CD;&#x7C7B;&#x578B;&#x7684;&#x52A0;&#x5BC6;&#x529F;&#x80FD;&#xFF1A;&#x6570;&#x636E;&#x4F20;&#x8F93;&#x65F6;&#x7684;&#x52A0;&#x5BC6;&#x548C;&#x9759;&#x6001;&#x6570;&#x636E;&#x7684;&#x52A0;&#x5BC6;&#x3002;&#x901A;&#x8FC7;&#x5BF9;&#x4F20;&#x8F93;&#x8FC7;&#x7A0B;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x8FDB;&#x884C;&#x52A0;&#x5BC6;&#xFF0C;&#x53EF;&#x4EE5;&#x4FDD;&#x62A4;&#x7269;&#x7406;&#x8282;&#x70B9;&#x4E4B;&#x95F4;&#x7684;&#x6570;&#x636E;&#x4F20;&#x8F93;&#x514D;&#x53D7;&#x4E2D;&#x95F4;&#x4EBA;&#x653B;&#x51FB;&#x3002;&#x800C;&#x5BF9;&#x9759;&#x6001;&#x6570;&#x636E;&#x7684;&#x7684;&#x52A0;&#x5BC6;&#x65E8;&#x5728;&#x4FDD;&#x62A4;&#x6570;&#x636E;&#x5B58;&#x50A8;&#x4E0D;&#x53D7;&#x5B58;&#x50A8;&#x8BBE;&#x5907;&#x76D7;&#x7A83;&#x548C;&#x7F51;&#x7EDC;&#x7A83;&#x542C;&#x7684;&#x5A01;&#x80C1;&#x3002;Lustre 2.14+ &#x7248;&#x672C;&#x63D0;&#x4F9B;&#x4E86;&#x9759;&#x6001;&#x6570;&#x636E;&#x7684;&#x52A0;&#x5BC6;&#x529F;&#x80FD;&#x3002;&#x6570;&#x636E;&#x5728;&#x53D1;&#x9001;&#x5230;&#x670D;&#x52A1;&#x5668;&#x4E4B;&#x524D;&#x5728; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x4E0A;&#x8FDB;&#x884C;&#x52A0;&#x5BC6;&#xFF0C;&#x5E76;&#x5728;&#x63A5;&#x6536;&#x670D;&#x52A1;&#x5668;&#x8FD4;&#x56DE;&#x6570;&#x636E;&#x65F6;&#x8FDB;&#x884C;&#x89E3;&#x5BC6;&#x3002;&#x8FD9;&#x6837;&#xFF0C;&#x8FD0;&#x884C;&#x5728; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x4E0A;&#x7684;&#x5E94;&#x7528;&#x7A0B;&#x5E8F;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x660E;&#x6587;&#xFF0C;&#x800C;&#x670D;&#x52A1;&#x5668;&#x53EA;&#x80FD;&#x770B;&#x5230;&#x52A0;&#x5BC6;&#x7684;&#x6587;&#x672C;&#x3002;&#x56E0;&#x6B64;&#xFF0C;&#x5BF9;&#x52A0;&#x5BC6;&#x5BC6;&#x94A5;&#x7684;&#x8BBF;&#x95EE;&#x4EC5;&#x9650;&#x4E8E; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x3002;</p>
</blockquote>
<p>Source code 17: Libcfs module loading script (tests/test-framework.sh)</p>
<pre><code class="lang-c">mount_facet() {
    . . . . .
    module_loaded lustre || load_modules
}

load_modules() {
    . . . . .
    load_modules_local
}

load_modules_local() {
    . . . . .
    load_module ../libcfs/libcfs/libcfs
    . . . . .
    load_module ../lnet/lnet/lnet
    . . . . .
    load_module obdclass/obdclass
    load_module ptlrpc/ptlrpc
    load_module ptlrpc/gss/ptlrpc_gss
    load_module fld/fld
    load_module fid/fid
    load_module lmv/lmv
    . . . . .
}
</code></pre>
<p>Data (at rest) encryption related algorithm and policy flags and data structures are defined in libcfs/include/uapi/linux/llcrypt.h. The encryption algorithm macros are defined in Source Code 18. Definition of an encryption key structure shown in Source Code 19 includes a name, the raw key and size fields. Maximum size of the encryption key is limited to LLCRYPT_MAX_KEY_SIZE. This file also contains ioctl definitions to add and remove encryption keys, and obtain encryption policy, and key status.</p>
<blockquote>
<p>&#x6570;&#x636E;&#xFF08;&#x9759;&#x6001;&#xFF09;&#x52A0;&#x5BC6;&#x76F8;&#x5173;&#x7684;&#x7B97;&#x6CD5;&#x3001;&#x7B56;&#x7565;&#x6807;&#x5FD7;&#x548C;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x5B9A;&#x4E49;&#x5728; libcfs/include/uapi/linux/llcrypt.h &#x4E2D;&#x3002;&#x52A0;&#x5BC6;&#x7B97;&#x6CD5;&#x7684;&#x76F8;&#x5173;&#x5B8F;&#x5728; Source Code 18 &#x4E2D;&#x663E;&#x793A;&#x3002;Source Code 19 &#x4E2D;&#x5C55;&#x793A;&#x4E86;&#x52A0;&#x5BC6;&#x5BC6;&#x94A5;&#x7ED3;&#x6784;&#x7684;&#x5B9A;&#x4E49;&#xFF0C;&#x5305;&#x62EC;&#x540D;&#x79F0;&#x3001;&#x539F;&#x59CB;&#x5BC6;&#x94A5;&#x548C;&#x5927;&#x5C0F;&#x5B57;&#x6BB5;&#x3002;&#x52A0;&#x5BC6;&#x5BC6;&#x94A5;&#x7684;&#x6700;&#x5927;&#x5927;&#x5C0F;&#x9650;&#x5236;&#x4E3A; LLCRYPT_MAX_KEY_SIZE&#x3002;&#x8BE5;&#x6587;&#x4EF6;&#x8FD8;&#x5305;&#x542B;&#x4E86;&#x7528;&#x4E8E;&#x6DFB;&#x52A0;&#x548C;&#x5220;&#x9664;&#x52A0;&#x5BC6;&#x5BC6;&#x94A5;&#x3001;&#x83B7;&#x53D6;&#x52A0;&#x5BC6;&#x7B56;&#x7565;&#x548C;&#x5BC6;&#x94A5;&#x72B6;&#x6001;&#x7684; ioctl &#x5B9A;&#x4E49;&#x3002;</p>
</blockquote>
<p>Source code 18: Encryption algorithm macros defined in libcfs/include/uapi/linux/llcrypt.h</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LLCRYPT_MODE_AES_256_XTS                1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LLCRYPT_MODE_AES_256_CTS                4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LLCRYPT_MODE_AES_128_CBC                5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LLCRYPT_MODE_AES_128_CTS                6</span>
</code></pre>
<p>While userland headers for data encryption are listed in libcfs/include/uapi/linux/llcrypt.h, the corresponding kernel headers can be found in libcfs/include/libcfs/crypto/llcrypt.h. Some of the kernel APIs for data encryption are shown in Source Code 20. The definitions of these APIs can be found in libcfs/libcfs/crypto/hooks.c.</p>
<blockquote>
<p>&#x867D;&#x7136;&#x7528;&#x6237;&#x7A7A;&#x95F4;&#x7684;&#x6570;&#x636E;&#x52A0;&#x5BC6;&#x5934;&#x6587;&#x4EF6;&#x90FD;&#x5728; libcfs/include/uapi/linux/llcrypt.h &#x4E2D;&#xFF0C;&#x4F46;&#x76F8;&#x5E94;&#x7684;&#x5185;&#x6838;&#x5934;&#x6587;&#x4EF6;&#x53EF;&#x4EE5;&#x5728; libcfs/include/libcfs/crypto/llcrypt.h &#x4E2D;&#x627E;&#x5230;&#x3002;&#x4E00;&#x4E9B;&#x7528;&#x4E8E;&#x6570;&#x636E;&#x52A0;&#x5BC6;&#x7684;&#x5185;&#x6838; API &#x663E;&#x793A;&#x5728; Source Code 20 &#x4E2D;&#x3002;&#x8FD9;&#x4E9B; API &#x7684;&#x5B9A;&#x4E49;&#x53EF;&#x4EE5;&#x5728; libcfs/libcfs/crypto/hooks.c &#x4E2D;&#x627E;&#x5230;&#x3002;</p>
</blockquote>
<p>Support functions for data encryption are defined in libcfs/libcfs/crypto/crypto.c file. These include:</p>
<blockquote>
<p>&#x652F;&#x6301;&#x6570;&#x636E;&#x52A0;&#x5BC6;&#x7684;&#x51FD;&#x6570;&#x5B9A;&#x4E49;&#x5728; libcfs/libcfs/crypto/crypto.c &#x6587;&#x4EF6;&#x4E2D;&#x3002;&#x5176;&#x4E2D;&#x5305;&#x62EC;&#xFF1A;</p>
</blockquote>
<ul>
<li><p>llcrypt_release_ctx() - Releases a decryption context.</p>
</li>
<li><p>llcrypt_get_ctx() - Gets a decryption context.</p>
</li>
<li><p>llcrypt_free_bounce_page() - Frees a ciphertext bounce page.</p>
</li>
<li><p>llcrypt_crypt_block() - Encrypts or decrypts a single file system block of file contents.</p>
</li>
<li><p>llcrypt_encrypt_pagecache_blocks() - Encrypts file system blocks from a page cache page.</p>
</li>
<li><p>llcrypt_encrypt_block_inplace() - Encrypts a file system block in place.</p>
</li>
<li><p>llcrypt_decrypt_pagecache_blocks() - Decrypts file system blocks in a page cache page.</p>
</li>
<li><p>llcrypt_decrypt_block_inplace() - Decrypts a file system block in place.</p>
</li>
</ul>
<p>Setup and cleanup functions (llcrypt_init(), llcrypt_exit()) for file system encryption are also defined here. fname.c implements functions to encrypt and decrypt filenames, allocate and free buffers for file name encryption and to convert a file name from disk space to user space. keyring.c and keysetup.c implement functions to manage cryptographic master keys and policy.c provides APIs to find supported policies, check the equivalency of two policies and policy context management.</p>
<blockquote>
<p>&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x52A0;&#x5BC6;&#x7684;&#x8BBE;&#x7F6E;&#x548C;&#x6E05;&#x7406;&#x51FD;&#x6570;&#xFF08;llcrypt_init()&#x3001;llcrypt_exit()&#xFF09;&#x4E5F;&#x5728; crypto.c &#x5B9A;&#x4E49;&#x3002;fname.c &#x5B9E;&#x73B0;&#x4E86;&#x5BF9;&#x6587;&#x4EF6;&#x540D;&#x7684;&#x52A0;&#x5BC6;&#x548C;&#x89E3;&#x5BC6;&#x51FD;&#x6570;&#xFF0C;&#x5206;&#x914D;&#x548C;&#x91CA;&#x653E;&#x6587;&#x4EF6;&#x540D;&#x52A0;&#x5BC6;&#x7684;&#x7F13;&#x51B2;&#x533A;&#xFF0C;&#x5E76;&#x5C06;&#x6587;&#x4EF6;&#x540D;&#x4ECE;&#x78C1;&#x76D8;&#x7A7A;&#x95F4;&#x8F6C;&#x6362;&#x4E3A;&#x7528;&#x6237;&#x7A7A;&#x95F4;&#x3002;keyring.c &#x548C; keysetup.c &#x5B9E;&#x73B0;&#x4E86;&#x7BA1;&#x7406;&#x52A0;&#x5BC6;&#x4E3B;&#x5BC6;&#x94A5;&#x7684;&#x529F;&#x80FD;&#xFF0C;&#x800C; policy.c &#x63D0;&#x4F9B;&#x4E86;&#x67E5;&#x627E;&#x652F;&#x6301;&#x7684;&#x7B56;&#x7565;&#x3001;&#x68C0;&#x67E5;&#x4E24;&#x4E2A;&#x7B56;&#x7565;&#x7684;&#x7B49;&#x6548;&#x6027;&#x4EE5;&#x53CA;&#x7B56;&#x7565;&#x4E0A;&#x4E0B;&#x6587;&#x7BA1;&#x7406;&#x7684; API&#x3002;</p>
</blockquote>
<p>Source code 19: llcrypt_key structure defined in libcfs/include/uapi/linux/llcrypt.h</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LLCRYPT_MAX_KEY_SIZE            64</span>
<span class="hljs-keyword">struct</span> llcrypt_key {
        __u32 mode;
        __u8 raw[LLCRYPT_MAX_KEY_SIZE];
        __u32 size;
};
</code></pre>
<h2 id="cpu-partition-table-management"><a name="cpu-partition-table-management" class="plugin-anchor" href="#cpu-partition-table-management"><i class="fa fa-link" aria-hidden="true"></i></a>CPU Partition Table Management</h2>
<p>Libcfs includes APIs and data structures that help with CPU partition table management in Lustre. A CPU partition is a virtual processing unit and can have 1-N cores or 1-N NUMA nodes. Therefore a CPU partition is also viewed as a pool of processors.</p>
<blockquote>
<p>libcfs &#x4E2D;&#x7684; API &#x548C;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x7528;&#x4E8E;&#x5904;&#x7406; Lustre &#x4E2D;&#x7684; CPU &#x5206;&#x533A;&#x8868;&#x3002;CPU &#x5206;&#x533A;&#x8868;&#x662F;&#x865A;&#x62DF;&#x5316;&#x5904;&#x7406;&#x5355;&#x5143;&#xFF0C;&#x5B83;&#x6709; 1&#x5230; N &#x4E2A;&#x6838;&#x5FC3;&#x548C; 1&#x5230; N &#x4E2A; NUMA &#x8282;&#x70B9;&#x3002;&#x6240;&#x4EE5;&#xFF0C;CPU &#x5206;&#x533A;&#x4E5F;&#x662F;&#x5904;&#x7406;&#x5668;&#x6C60;&#x7684;&#x89C6;&#x56FE;&#x3002;</p>
</blockquote>
<p>Source code 20: Kernel APIs for data encryption defined in libcfs/include/libcfs/crypto/llcrypt.h</p>
<pre><code class="lang-c"><span class="hljs-comment">//Prepares for a rename between possibly-encrypted directories</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">llcrypt_prepare_rename</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *old_dir,
                                         <span class="hljs-keyword">struct</span> dentry *old_dentry,
                                         <span class="hljs-keyword">struct</span> inode *new_dir,
                                         <span class="hljs-keyword">struct</span> dentry *new_dentry,
                                         <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span>
<span class="hljs-comment">//Prepares to lookup a name in a possibly-encrypted directory</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">llcrypt_prepare_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dir,
                                         <span class="hljs-keyword">struct</span> dentry *dentry,
                                         <span class="hljs-keyword">struct</span> llcrypt_name *fname)</span>

<span class="hljs-comment">// Prepares to change a possibly-encrypted inode&apos;s attributes</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">llcrypt_prepare_setattr</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dentry *dentry,
                                          <span class="hljs-keyword">struct</span> iattr *attr)</span>
<span class="hljs-comment">//Prepares to create a possibly-encrypted symlink</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">llcrypt_prepare_symlink</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dir,
                                          <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *target,
                                          <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len,
                                          <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> max_len,
                                          <span class="hljs-keyword">struct</span> llcrypt_str *disk_link)</span>
<span class="hljs-comment">//Encrypts the symlink target if needed</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">llcrypt_encrypt_symlink</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode,
                                          <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *target,
                                          <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len,
                                          <span class="hljs-keyword">struct</span> llcrypt_str *disk_link)</span>
</span></code></pre>
<p>A CPU partition table (CPT) consists of a set of CPU partitions. CPTs can have two modes of operation, NUMA and SMP denoted by CFS_CPU_MODE_NUMA and CFS_CPU_MODE_SMP respectively. Users can specify total number of CPU partitions while creating a CPT and ID of a CPU partition always starts from 0. For example: if there are 8 cores in the system, creating a CPT:</p>
<blockquote>
<p>&#x4E00;&#x4E2A; CPU &#x5206;&#x533A;&#x8868;&#xFF08;CPT&#xFF09;&#x5305;&#x542B;&#x4E00;&#x7EC4; CPU &#x5206;&#x533A;&#x3002;CPTs &#x6709;&#x4E24;&#x79CD;&#x6A21;&#x5F0F;&#xFF1A;NUMA &#x548C; SMB&#xFF0C;&#x5206;&#x522B;&#x5BF9;&#x5E94; CFS_CPU_MODE_NUMA &#x548C; CFS_CPU_MODE_SMP&#x3002;&#x5F53;&#x5728;&#x521B;&#x5EFA; CPT &#x65F6;&#xFF0C;&#x7528;&#x6237;&#x53EF;&#x4EE5;&#x6307;&#x5B9A;&#x5168;&#x90E8;&#x7684; CPU &#x5206;&#x533A;&#x7684;&#x5230;&#x8BE5; CPT &#x4E0A;&#xFF0C;CPU &#x7684;&#x5206;&#x533A; ID &#x4ECE; 0 &#x5F00;&#x59CB;&#x3002;&#x4F8B;&#x5982;&#xFF1A;&#x5982;&#x679C;&#x5728;&#x4E00;&#x4E2A;&#x7CFB;&#x7EDF;&#x4E2D;&#x6709; 8 &#x4E2A;&#x6838;&#x5FC3;&#xFF0C;&#x5F53;&#x521B;&#x5EFA;&#x4E00;&#x4E2A; CPT &#x65F6;&#xFF1A;</p>
</blockquote>
<pre><code class="lang-c">with cpu_npartitions=<span class="hljs-number">4</span>:
    core[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>] = partition[<span class="hljs-number">0</span>], core[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>] = partition[<span class="hljs-number">1</span>]
    core[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>] = partition[<span class="hljs-number">2</span>], core[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>] = partition[<span class="hljs-number">3</span>]
cpu_npartitions=<span class="hljs-number">1</span>:
    core[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ... <span class="hljs-number">7</span>] = partition[<span class="hljs-number">0</span>]
</code></pre>
<p>Users can also specify CPU partitions by a string pattern.</p>
<blockquote>
<p>&#x7528;&#x6237;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x5B57;&#x7B26;&#x4E32; pattern &#x6307;&#x5B9A; CPU &#x5206;&#x533A;</p>
</blockquote>
<pre><code class="lang-c">cpu_partitions=<span class="hljs-string">&quot;0[0,1], 1[2,3]&quot;</span>
cpu_partitions=<span class="hljs-string">&quot;N 0[0-3], 1[4-8]&quot;</span>
</code></pre>
<p>The first character &#x201C;N&#x201D; means following numbers are NUMA IDs. By default, Lustre modules should refer to the global cfs_cpt_tab, instead of accessing hardware CPUs directly, so concurrency of Lustre can be configured by cpu_npartitions of the global cfs_cpt_tab.</p>
<blockquote>
<p>&#x7B2C;&#x4E00;&#x4E2A;&#x5B57;&#x7B26; &quot;N&quot; &#x8868;&#x793A;&#x63A5;&#x4E0B;&#x6765;&#x7684;&#x6570;&#x5B57;&#x90FD;&#x662F; NUMA IDs&#x3002;&#x9ED8;&#x8BA4;&#x7684;&#xFF0C;Lustre &#x6A21;&#x5757;&#x5E94;&#x8BE5;&#x5F15;&#x7528;&#x5168;&#x90E8; cfs_cpt_tab&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x76F4;&#x63A5;&#x8BBF;&#x95EE; CPU &#x786C;&#x4EF6;&#xFF0C;&#x6240;&#x4EE5;&#xFF0C;Lustre &#x7684;&#x5E76;&#x53D1;&#x5EA6;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x914D;&#x7F6E;&#x5168;&#x5C40; cfs_cpt_tab &#x7684; cpu_npartitions&#x3002;</p>
</blockquote>
<p>Source Code 21 and Source Code 22 show data structures that define CPU partition and CPT. A CPU partition consists of fields representing CPU mask (cpt_cpumask) and node mask (<em>cpt_nodemask) for the partition, NUMA distance between CPTs (</em>cpt_distance), spread rotor for NUMA allocator (cpt_spread_rotor) and NUMA node if cpt_nodemask is empty (cpt_node). Number of CPU partitions, structure representing partition tables and masks to represent all CPUs and nodes are the significant fields in the cfs_cpt_table structure.</p>
<blockquote>
<p>&#x6E90;&#x7801;21&#x548C;&#x6E90;&#x7801;22 &#x663E;&#x793A;&#x4E86;&#x5B9A;&#x4E49; CPU &#x5206;&#x533A;&#x548C;&#x5206;&#x533A;&#x8868;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;&#x4E00;&#x4E2A; CPU &#x5206;&#x533A;&#x4E2D;&#xFF0C;&#x5305;&#x542B;&#x8868;&#x793A; CPU &#x63A9;&#x7801;&#xFF08;cpt_cpumask&#xFF09;&#x548C;&#x8868;&#x793A;&#x5206;&#x533A;&#x8282;&#x70B9;&#x63A9;&#x7801;&#xFF08;<em>cpt_nodemask&#xFF09;&#xFF0C;CPTs&#xFF08;</em>cpt_distance&#xFF09;&#x4E4B;&#x95F4;&#x7684; NUMA &#x8DDD;&#x79BB;&#xFF0C;NUMA &#x5206;&#x914D;&#x5668;&#x7684;&#x5E7F;&#x64AD;&#x65CB;&#x8F6C;&#x5B50;&#xFF0C;NUMA &#x8282;&#x70B9;&#xFF08;&#x5982;&#x679C; cpt_nodemask &#x4E3A;&#x7A7A;&#xFF09;&#x3002;CPU &#x5206;&#x533A;&#x6570;&#xFF0C;&#x8868;&#x793A;&#x5206;&#x533A;&#x8868;&#x7684;&#x7ED3;&#x6784;&#x4F53;&#x548C;&#x6240;&#x6709; CPU &#x7684;&#x63A9;&#x7801;&#xFF0C;&#x662F; cfs_cpt_table &#x7ED3;&#x6784;&#x4F53;&#x4E2D;&#x6700;&#x91CD;&#x8981;&#x7684;&#x90E8;&#x5206;&#x3002;</p>
</blockquote>
<p>Source code 21: cfs_cpu_partition structure defined in libcfs/libcfs/libcfs_cpu.c</p>
<pre><code class="lang-c"><span class="hljs-keyword">struct</span> cfs_cpu_partition {
        <span class="hljs-keyword">cpumask_var_t</span>                   cpt_cpumask;
        <span class="hljs-keyword">nodemask_t</span>                      *cpt_nodemask;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>                    *cpt_distance;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>                    cpt_spread_rotor;
        <span class="hljs-keyword">int</span>                             cpt_node;
};
</code></pre>
<p>Source code 22: cfs_cpt_table structure defined in libcfs/libcfs/libcfs_cpu.c</p>
<pre><code class="lang-c"><span class="hljs-keyword">struct</span> cfs_cpt_table {
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>                    ctb_spread_rotor;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>                    ctb_distance;
        <span class="hljs-keyword">int</span>                             ctb_nparts;
        <span class="hljs-keyword">struct</span> cfs_cpu_partition        *ctb_parts;
        <span class="hljs-keyword">int</span>                             *ctb_cpu2cpt;
        <span class="hljs-keyword">cpumask_var_t</span>                   ctb_cpumask;
        <span class="hljs-keyword">int</span>                             *ctb_node2cpt;
        <span class="hljs-keyword">nodemask_t</span>                      *ctb_nodemask;
};
</code></pre>
<p>Libcfs provides the following APIs to access and manipulate CPU partitions and CPTs.</p>
<blockquote>
<p>libcfs &#x63D0;&#x4F9B;&#x4E0B;&#x9762; APIs &#x51FD;&#x6570;&#xFF0C;&#x7528;&#x4E8E;&#x8BBF;&#x95EE;&#x548C;&#x7BA1;&#x7406; CPU &#x5206;&#x533A; &#x548C; CPTs&#x3002;</p>
</blockquote>
<ul>
<li><p>cfs_cpt_table_alloc() - Allocates a CPT given the number of CPU partitions.</p>
</li>
<li><p>cfs_cpt_table_free() - Frees a CPT corresponding to the given reference.</p>
</li>
<li><p>cfs_cpt_table_print() - Prints a CPT corresponding to the given reference.</p>
</li>
<li><p>cfs_cpt_number() - Returns number of CPU partitions in a CPT.</p>
</li>
<li><p>cfs_cpt_online() - returns the number of online CPTs.</p>
</li>
<li><p>cfs_cpt_distance_calculate() - Calculates the maximum NUMA distance between all nodes in the from_mask and all nodes in the to_mask.</p>
</li>
</ul>
<p>Additionally libcfs includes functions to initialize and remove CPUs, set and unset node masks and add and delete CPUs and nodes. Per CPU data and partition variables management functions are located in libcfs/libcfs/libcfs_mem.c file.</p>
<blockquote>
<p>&#x6B64;&#x5916;&#xFF0C;libcfs &#x8FD8;&#x5305;&#x542B;&#x521D;&#x59CB;&#x5316;&#x548C;&#x5220;&#x9664; CPU &#x7684;&#x51FD;&#x6570;&#xFF0C;&#x8BBE;&#x7F6E;&#x3001;&#x53D6;&#x6D88;&#x8BBE;&#x7F6E;&#x8282;&#x70B9;&#x63A9;&#x7801;&#xFF0C;&#x589E;&#x52A0;&#x3001;&#x5220;&#x9664; CPU &#x548C;&#x8282;&#x70B9;&#x7B49;&#x51FD;&#x6570;&#x3002;&#x6BCF;&#x4E2A; CPU &#x6570;&#x636E;&#x548C;&#x5206;&#x533A;&#x7684;&#x53D8;&#x91CF;&#x7BA1;&#x7406;&#x51FD;&#x6570;&#x4F4D;&#x4E8E; libcfs/libcfs/libcfs_mem.c &#x6587;&#x4EF6;&#x4E2D;&#x3002;</p>
</blockquote>
<h2 id="debugging-support-and-failure-injection"><a name="debugging-support-and-failure-injection" class="plugin-anchor" href="#debugging-support-and-failure-injection"><i class="fa fa-link" aria-hidden="true"></i></a>Debugging Support and Failure Injection</h2>
<p>Lustre debugging infrastructure contains a number of macros that can be used to report errors and warnings. The debugging macros are defined in libcfs/include/libcfs/libcfs_debug.h. CERROR, CNETERR, CWARN, CEMERG, LCONSOLE, CDEBUG are examples of the debugging macros. Complete list of the debugging macros and their detailed description can be found in this link.</p>
<blockquote>
<p>lustre &#x8C03;&#x8BD5;&#x57FA;&#x7840;&#x5957;&#x4EF6;&#x5305;&#x542B;&#x5404;&#x79CD;&#x7528;&#x5728;&#x62A5;&#x544A;&#x9519;&#x8BEF;&#x548C;&#x544A;&#x8B66;&#x7684;&#x5B8F;&#x3002;&#x6587;&#x4EF6; libcfs/include/libcfs/libcfs_debug.h &#x5B9A;&#x4E49;&#x4E86;&#x8BF8;&#x5982; CERROR, CNETERR, CWARN, CEMERG, LCONSOLE, CDEBUG &#x8C03;&#x8BD5;&#x5B8F;&#x3002;&#x8C03;&#x8BD5;&#x5B8F;&#x7684;&#x5B8C;&#x6574;&#x5217;&#x8868;&#x548C;&#x7EC6;&#x63CF;&#x8FF0;&#x90FD;&#x5728;&#x8BE5;<a href="https://github.com/DDNStorage/lustre_manual_markdown" target="_blank">&#x94FE;&#x63A5;</a>&#x4E2D;&#x3002;</p>
</blockquote>
<p>Failure macros defined in libcfs_fail.h are used to deliberately inject failure conditions in Lustre for testing purposes. CFS_FAIL_ONCE, CFS_FAILv SKIP, CFS_FAULT, CFS_FAIL_SOME are examples of such failure macros (see Source Code 23). Libcfs module defines the failure macros starting with the keyword CFS whereas Lustre redefines them in lustre/include/obd_support.h file starting with the keyword OBD. The hex values representing these failure macros are used in the lctl set_param fail_loc command inject specific failures. Instances of OBD_FAIL macro usage can be seen in llite/vvp_io.c file.</p>
<blockquote>
<p>&#x6545;&#x969C;&#x5B8F;&#xFF08;&#x89C1; libcfs_fail.h&#xFF09;&#x901A;&#x8FC7;&#x6CE8;&#x5165;&#x6545;&#x969C;&#x6761;&#x4EF6;&#x4EE5;&#x8FBE;&#x5230;&#x6D4B;&#x8BD5;&#x7684;&#x76EE;&#x6807;&#x3002;&#x4E00;&#x4E9B;&#x6545;&#x969C;&#x5B8F;&#x7684;&#x4F8B;&#x5B50;&#x5305;&#x62EC;&#xFF1A;CFS_FAIL_ONCE, CFS_FAILv SKIP, CFS_FAULT, CFS_FAIL_SOME&#xFF08;&#x89C1;&#x6E90;&#x7801;23&#xFF09;&#x3002;Libcfs &#x5B9A;&#x4E49;&#x7684;&#x6545;&#x969C;&#x5B8F;&#x7684;&#x524D;&#x7F00;&#x4E3A; CFS&#xFF0C;&#x800C; Lustre &#x5728; lustre/include/obd_support.h &#x6587;&#x4EF6;&#x4E2D;&#x4F7F;&#x7528;&#x524D;&#x7F00; OBD &#x91CD;&#x65B0;&#x5B9A;&#x4E49;&#x4E86;&#x6545;&#x969C;&#x5B8F;&#x3002;&#x8FD9;&#x4E9B;&#x5B8F;&#x7684;&#x5341;&#x516D;&#x8FDB;&#x5236;&#x7684;&#x503C;&#x88AB;&#x7528;&#x5728; lctl set_param fail_loc &#x547D;&#x4EE4;&#x4E0A;&#xFF0C;&#x4EE5;&#x7528;&#x4E8E;&#x6CE8;&#x5165;&#x7279;&#x5B9A;&#x7684;&#x6545;&#x969C;&#x3002;&#x5B8F; OBD_FAIL &#x5B9E;&#x4F8B;&#x4F7F;&#x7528;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x5728; llite/vvp_io.c &#x4E2D;&#x627E;&#x5230;&#x3002;</p>
</blockquote>
<p>Source code 23: CFS_FAIL macros defined in libcfs/include/libcfs/libcfs_fail.h</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFS_FAIL_SKIP        0x20000000 <span class="hljs-comment">/* skip N times then fail */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFS_FAIL_SOME        0x10000000 <span class="hljs-comment">/* only fail N times */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFS_FAIL_RAND        0x08000000 <span class="hljs-comment">/* fail 1/N of the times */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFS_FAIL_USR1        0x04000000 <span class="hljs-comment">/* user flag */</span></span>
</code></pre>
<h2 id="additional-supporting-software-in-libcfs"><a name="additional-supporting-software-in-libcfs" class="plugin-anchor" href="#additional-supporting-software-in-libcfs"><i class="fa fa-link" aria-hidden="true"></i></a>Additional Supporting Software in Libcfs</h2>
<p>Files located in libcfs/include/libcfs/linux furnish additional supporting software for Lustre for having 64bit time, atomics, extended arrays and spin locks.</p>
<blockquote>
<p>&#x5728; libcfs/include/libcfs/linux &#x76EE;&#x5F55;&#x4E2D;&#x7684;&#x6587;&#x4EF6;&#x63D0;&#x4F9B;&#x989D;&#x5916;&#x7684;&#x8F6F;&#x4EF6;&#x652F;&#x6301;&#xFF0C;&#x5305;&#x62EC;64&#x4F4D;&#x65F6;&#x95F4;&#xFF0C;&#x539F;&#x5B50;&#x6027;&#xFF0C;&#x6269;&#x5C55;&#x6570;&#x7EC4;&#xFF0C;spin lock&#x3002;</p>
</blockquote>
<ul>
<li><p><code>linux-time.h</code> - Implementation of portable time API for Linux for both kernel and user-level.</p>
</li>
<li><p><code>refcount.h</code> - Implements a variant of atomic_t specialized for reference counts.</p>
</li>
<li><p><code>xarray.h</code> - Implementation of large array of pointers that has the functionality of resizable arrays.</p>
</li>
<li><p><code>processor.h</code> - Provides spin_begin(), spin_cpu_yield() and spin_until_cond() capabilities for spin locks.</p>
</li>
</ul>
<h1 id="file-identifiers-fid-location-database-and-object-index"><a name="file-identifiers-fid-location-database-and-object-index" class="plugin-anchor" href="#file-identifiers-fid-location-database-and-object-index"><i class="fa fa-link" aria-hidden="true"></i></a>File Identifiers, FID Location Database, and Object Index</h1>
<h2 id="file-identifier-fid"><a name="file-identifier-fid" class="plugin-anchor" href="#file-identifier-fid"><i class="fa fa-link" aria-hidden="true"></i></a>File Identifier (FID)</h2>
<p>Lustre refers to all the data that it stores as objects. This includes not only the individual components of a striped file but also such things as directory entries, internal configuration files, etc. To identify an object, Lustre assigns a File IDentifier (FID) to the object that is unique across the file system. A FID is a 128-bit number that consists of three components: a 64-bit sequence number, a 32-bit object ID, and a 32-bit version number. The data structure for a FID is shown in Source Code 24. As noted in the code, the version number is not currently used but is reserved for future purposes.</p>
<blockquote>
<p>Lustre &#x4F7F;&#x7528;&#x201C;&#x5BF9;&#x8C61;&#x201D;&#x63CF;&#x8FF0;&#x5B83;&#x6240;&#x5B58;&#x50A8;&#x7684;&#x6240;&#x6709;&#x6570;&#x636E;&#x3002;&#x201C;&#x5BF9;&#x8C61;&#x201D;&#x4E0D;&#x4EC5;&#x5305;&#x542B;&#x72EC;&#x7ACB;&#x7684;&#x6761;&#x5E26;&#x5316;&#x6587;&#x4EF6;&#x7EC4;&#x4EF6;&#xFF0C;&#x8FD8;&#x5305;&#x542B;&#x76EE;&#x5F55;&#x6761;&#x76EE;&#xFF0C;&#x5185;&#x90E8;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x7B49;&#x3002;Lustre &#x4F7F;&#x7528; FID &#x552F;&#x4E00;&#x6807;&#x8BC6;&#x5BF9;&#x8C61;&#xFF0C;FID &#x5171;128&#x4F4D;&#xFF0C;&#x5206;&#x4E3A;&#x4E09;&#x4E2A;&#x90E8;&#x5206;&#xFF1A;&#x4E00;&#x4E2A;64&#x4F4D;&#x7684;&#x5E8F;&#x5217;&#x53F7;&#xFF0C;&#x4E00;&#x4E2A;32&#x4F4D;&#x7684;&#x5BF9;&#x8C61; ID&#xFF0C;&#x548C;32&#x4F4D;&#x7684;&#x7248;&#x672C;&#x53F7;&#x3002;&#x6E90;&#x7801;24&#x4E3A; FID &#x7684;&#x7ED3;&#x6784;&#x4F53;&#x3002;&#x9700;&#x8981;&#x6CE8;&#x610F;&#x7684;&#x662F;&#xFF0C;&#x5F53;&#x524D;&#x7248;&#x672C;&#x53F7;&#x672A;&#x88AB;&#x4F7F;&#x7528;&#xFF0C;&#x53EA;&#x662F;&#x4F5C;&#x4E3A;&#x4FDD;&#x7559;&#x5B57;&#x6BB5;&#xFF0C;</p>
</blockquote>
<p>Source Code 24: FID structure (include/uapi/linux/lustre/lustre_user.h)</p>
<pre><code class="lang-c"><span class="hljs-keyword">struct</span> lu_fid {
       <span class="hljs-comment">/**
        * FID sequence. Sequence is a unit of migration: all files (objects)
        * with FIDs from a given sequence are stored on the same server.
        * Lustre should support 2^64 objects, so even if each sequence
        * has only a single object we can still enumerate 2^64 objects.
        **/</span>
        __u64 f_seq;
        <span class="hljs-comment">/* FID number within sequence. */</span>
        __u32 f_oid;
        <span class="hljs-comment">/**
         * FID version, used to distinguish different versions (in the sense
         * of snapshots, etc.) of the same file system object. Not currently
         * used.
         **/</span>
        __u32 f_ver;
} __attribute__((packed));
</code></pre>
<p>Sequence numbers are controlled by the Lustre file system and allocated to clients. The entire space of sequence numbers is overseen by the sequence controller that runs on MDT0, and every storage target (MDTs and OSTs) runs a sequence manager. As the file system is started and the storage targets are brought online, each sequence manager contacts the sequence controller to obtain a unique range of sequence numbers (known as a super sequence). Every client that establishes a connection to a storage target will be granted a unique sequence number by the target&#x2019;s sequence manager. This ensures that no two clients share a sequence number and that the same sequence number will always map to the same storage target.</p>
<blockquote>
<p>Lustre &#x63A7;&#x5236;&#x7740;&#x5E8F;&#x5217;&#x53F7;&#x548C;&#x5206;&#x914D;&#xFF08;&#x7ED9;&#x5BA2;&#x6237;&#x7AEF;&#xFF09;&#x3002;&#x5E8F;&#x5217;&#x63A7;&#x5236;&#x5668;&#x8FD0;&#x884C;&#x5728; MDT0 &#x4E0A;&#xFF0C;&#x5B83;&#x76D1;&#x89C6;&#x7740;&#x6574;&#x4E2A;&#x5E8F;&#x5217;&#x53F7;&#x7A7A;&#x95F4;&#x3002;&#x5E8F;&#x5217;&#x7BA1;&#x7406;&#x5668;&#x8FD0;&#x884C;&#x5728;&#x5B58;&#x50A8;&#x76EE;&#x6807;&#x4E0A;&#xFF08;MDT &#x548C; OST&#xFF09;&#x3002;&#x5F53;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x542F;&#x52A8;&#xFF0C;&#x4E14;&#x5B58;&#x50A8;&#x76EE;&#x6807;&#x4E0A;&#x7EBF;&#x65F6;&#xFF0C;&#x6BCF;&#x4E2A;&#x5E8F;&#x5217;&#x7BA1;&#x7406;&#x5668;&#x8FDE;&#x63A5;&#x5230;&#x5E8F;&#x5217;&#x63A7;&#x5236;&#x5668;&#x83B7;&#x53D6;&#x552F;&#x4E00;&#x7684;&#x67D0;&#x6BB5;&#x5E8F;&#x5217;&#x53F7;&#xFF0C;&#x4E5F;&#x79F0;&#x4E3A;&#x8D85;&#x7EA7;&#x5E8F;&#x5217;&#x3002;&#x968F;&#x540E;&#x5BA2;&#x6237;&#x7AEF;&#x7684;&#x5E8F;&#x5217;&#x7BA1;&#x7406;&#x5668;&#x5EFA;&#x7ACB;&#x548C;&#x5B58;&#x50A8;&#x76EE;&#x6807;&#x7684;&#x94FE;&#x63A5;&#xFF0C;&#x5E76;&#x6388;&#x4E88;&#x5B58;&#x50A8;&#x76EE;&#x6807;&#x4E00;&#x4E2A;&#x5E8F;&#x5217;&#x53F7;&#x3002;&#x8FD9;&#x79CD;&#x673A;&#x5236;&#x4FDD;&#x8BC1;&#x4E86;&#x4E0D;&#x540C;&#x5BA2;&#x6237;&#x7AEF;&#x4E4B;&#x95F4;&#x5E8F;&#x5217;&#x53F7;&#x7684;&#x552F;&#x4E00;&#x6027;&#x548C;&#x540C;&#x4E00;&#x4E2A;&#x5E8F;&#x5217;&#x53F7;&#x603B;&#x662F;&#x6620;&#x5C04;&#x5230;&#x76F8;&#x540C;&#x5B58;&#x50A8;&#x76EE;&#x6807;&#x4E0A;&#x3002;</p>
</blockquote>
<p>When a client creates a new object on a storage target, the client allocates a new FID to use for the object. The FID is created by using the sequence number granted to the client by the storage target and adding a unique object ID chosen by the client. The client maintains a counter for each sequence number and increments that counter when a new object ID is needed. This combination of target-specific sequence number and client-chosen object ID (along with a version number of zero) is used to populate the lu_fid structure for the new object. It should be noted that FIDs are never reused within the same Lustre file system (with a few exceptions for special internal-only objects). If a client exhausts a sequence number and cannot create more FIDs, the client will contact the target and request a new sequence number.</p>
<blockquote>
<p>&#x5F53;&#x5BA2;&#x6237;&#x7AEF;&#x5728;&#x5B58;&#x50A8;&#x76EE;&#x6807;&#x4E0A;&#x521B;&#x5EFA;&#x65B0;&#x5BF9;&#x8C61;&#x65F6;&#xFF0C;&#x5BA2;&#x6237;&#x7AEF;&#x4F1A;&#x7ED9;&#x8BE5;&#x5BF9;&#x8C61;&#x7533;&#x8BF7;&#x65B0;&#x7684; FID&#x3002;&#x8BE5; FID &#x7531;&#x5B58;&#x50A8;&#x76EE;&#x6807;&#x6388;&#x4E88;&#x7ED9;&#x5BA2;&#x6237;&#x7AEF;&#x7684;&#x5E8F;&#x5217;&#x53F7;&#xFF0C;&#x52A0;&#x4E0A;&#x5BA2;&#x6237;&#x7AEF;&#x9009;&#x62E9;&#x7684;&#x552F;&#x4E00;&#x7684;&#x5BF9;&#x8C61; ID &#x7EC4;&#x6210;&#x3002;&#x5BA2;&#x6237;&#x7AEF;&#x7EF4;&#x62A4;&#x5E8F;&#x5217;&#x53F7;&#x7684;&#x8BA1;&#x6570;&#x5668;&#xFF0C;&#x5E76;&#x4E14;&#x5728;&#x521B;&#x5EFA;&#x5BF9;&#x8C61;&#x65F6;&#x81EA;&#x589E;&#x3002;&#x57FA;&#x4E8E;&#x7279;&#x5B9A;&#x76EE;&#x6807;&#x7684;&#x5E8F;&#x5217;&#x53F7;&#x548C;&#x5BA2;&#x6237;&#x7AEF;&#x9009;&#x62E9;&#x7684;&#x5BF9;&#x8C61; ID &#x7684;&#x7EC4;&#x5408;&#xFF08;&#x8FD8;&#x6709;&#x5168;&#x4E3A;0&#x7684;&#x7248;&#x672C;&#x53F7;&#xFF09;&#x5728;&#x521B;&#x5EFA;&#x65B0;&#x5BF9;&#x8C61;&#x65F6;&#x586B;&#x5145; lu_fid &#x7ED3;&#x6784;&#x4F53;&#x3002;&#x9700;&#x8981;&#x6CE8;&#x610F;&#x7684;&#x662F;&#xFF0C;&#x5728; lustre &#x4E2D;&#xFF0C;FID &#x4E0D;&#x4F1A;&#x88AB;&#x91CD;&#x590D;&#x4F7F;&#x7528;&#x3002;&#x5982;&#x679C;&#x5BA2;&#x6237;&#x7AEF;&#x8017;&#x5C3D;&#x5E8F;&#x5217;&#x53F7;&#xFF0C;&#x5BA2;&#x6237;&#x7AEF;&#x5C06;&#x5411;&#x76EE;&#x6807;&#x5668;&#x8BF7;&#x6C42;&#x65B0;&#x7684;&#x5E8F;&#x5217;&#x53F7;&#x3002;</p>
</blockquote>
<p>It is important to understand that the use of the term &#x201C;client&#x201D; in this context does not just refer to Lustre file system clients that present the POSIX file system interface to end-users. A FID client is any node that is responsible for creating new objects, and this can include other Lustre servers. When a Lustre file system client uses the POSIX interface to create a new file, it will use a sequence number granted by an MDT target to construct a FID for the new file. This FID will be used to identify the object on the MDT that corresponds to this new file. However, the MDS server hosting the MDT will use the layout configuration for this new file to allocate objects on one or more OSTs that will contain the actual file data. In this scenario, the MDS is acting as a FID client to the OST targets. The MDS server will have been granted sequence numbers by the OST targets and use these sequence numbers to generate the FIDs that identify all the OST objects associated with the file layout.</p>
<blockquote>
<p>&#x672F;&#x8BED;&#x201C;client&#x201D;&#x5728;&#x4E0A;&#x4E0B;&#x6587;&#x7684;&#x542B;&#x4E49;&#x975E;&#x5E38;&#x91CD;&#x8981;&#x3002;&#x5B83;&#x4E0D;&#x4EC5;&#x4EC5;&#x6307;&#x4EE3;&#x5448;&#x73B0;&#x7ED9;&#x7EC8;&#x7AEF;&#x7528;&#x6237;&#x7684; POSIX &#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x63A5;&#x53E3;&#x7C7B;&#x578B;&#x7684; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x3002;FID &#x5BA2;&#x6237;&#x7AEF;&#x53EF;&#x4EE5;&#x5728; Lustre &#x7684;&#x4EFB;&#x4F55;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x4E0A;&#xFF0C;&#x4F8B;&#x5982; Lustre &#x670D;&#x52A1;&#x5668;&#xFF0C;&#x53EA;&#x8981;&#x662F;&#x9700;&#x8981;&#x521B;&#x5EFA;&#x65B0;&#x5BF9;&#x8C61;&#x7684;&#x5730;&#x65B9;&#x3002;&#x5F53; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x4F7F;&#x7528; POSIX &#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x63A5;&#x53E3;&#x53BB;&#x521B;&#x5EFA;&#x65B0;&#x7684;&#x6587;&#x4EF6;&#x65F6;&#xFF0C;&#x5B83;&#x5C06;&#x4F7F;&#x7528; MDT &#x6388;&#x4E88;&#x7ED9;&#x5BA2;&#x6237;&#x7AEF;&#x7684;&#x5E8F;&#x5217;&#x53F7;&#x6765;&#x521B;&#x5EFA;&#x65B0;&#x7684; FID &#x7ED9;&#x8BE5;&#x6587;&#x4EF6;&#x3002;&#x7136;&#x800C;&#xFF0C;MDS &#x670D;&#x52A1;&#x5668;&#x6302;&#x8F7D;&#x7684; MDT &#x4F1A;&#x4F7F;&#x7528;&#x5E03;&#x5C40;&#x914D;&#x7F6E;&#x5728;&#x5355;&#x4E2A;&#x6216;&#x591A;&#x4E2A; OST &#x4E0A;&#x7533;&#x8BF7;&#x5BF9;&#x8C61;&#x7ED9;&#x65B0;&#x521B;&#x5EFA;&#x7684;&#x6587;&#x4EF6;&#x6570;&#x636E;&#xFF0C;&#x5728;&#x8FD9;&#x79CD;&#x573A;&#x666F;&#x4E0B;&#xFF0C;MDS &#x65F6;&#x4F5C;&#x4E3A;&#x4E00;&#x4E2A; OST &#x76EE;&#x6807;&#x7684; FID &#x5BA2;&#x6237;&#x7AEF;&#x800C;&#x5B58;&#x5728;&#x3002;MDS &#x670D;&#x52A1;&#x5668;&#x88AB; OST &#x76EE;&#x6807;&#x6388;&#x4E88;&#x5E8F;&#x5217;&#x53F7;&#xFF0C;&#x7136;&#x540E;&#x4F7F;&#x7528;&#x8FD9;&#x4E9B;&#x5E8F;&#x5217;&#x53F7;&#x751F;&#x6210;&#x65B0;&#x7684;&#xFF0C;&#x53EF;&#x4EE5;&#x6807;&#x8BC6;&#x6240;&#x6709;&#x5173;&#x8054;&#x5230;&#x6587;&#x4EF6;&#x5E03;&#x5C40;&#x7684; OST &#x5BF9;&#x8C61;&#x7684; FID&#x3002;</p>
</blockquote>
<h3 id="reserved-sequence-numbers-and-object-ids"><a name="reserved-sequence-numbers-and-object-ids" class="plugin-anchor" href="#reserved-sequence-numbers-and-object-ids"><i class="fa fa-link" aria-hidden="true"></i></a>Reserved Sequence Numbers and Object IDs</h3>
<p>The sequence controller does not allocate certain sequence numbers to the sequence managers. These sequence numbers are reserved for special uses such as testing or compatibility with older Lustre versions. Information about these reserved sequence numbers can be found in include/lustrefid.h. Below is a list of sequence ranges used by Lustre:</p>
<blockquote>
<p>&#x5E8F;&#x5217;&#x63A7;&#x5236;&#x5668;&#x4E0D;&#x4F1A;&#x7ED9;&#x5E8F;&#x5217;&#x7BA1;&#x7406;&#x5668;&#x5206;&#x914D;&#x7279;&#x6B8A;&#x7684;&#x5E8F;&#x5217;&#x53F7;&#x3002;&#x8FD9;&#x4E9B;&#x4FDD;&#x7559;&#x5E8F;&#x5217;&#x53F7;&#x88AB;&#x7528;&#x4E8E;&#x5982;&#x6D4B;&#x8BD5;&#x6216;&#x65E7;&#x7248;&#x672C;&#x517C;&#x5BB9;&#x6027;&#x76EE;&#x7684;&#x3002;&#x6709;&#x5173;&#x4FDD;&#x7559;&#x5E8F;&#x5217;&#x53F7;&#x4FE1;&#x606F;&#x53EF;&#x4EE5;&#x5728; include/lustrefid.h &#x6587;&#x4EF6;&#x4E2D;&#x67E5;&#x770B;&#x3002;&#x4EE5;&#x4E0B;&#x5217;&#x51FA;&#x5728; lustre &#x4E2D;&#x4F7F;&#x7528;&#x7684;&#x5E8F;&#x5217;&#x8303;&#x56F4;&#xFF1A;</p>
</blockquote>
<ul>
<li><p>IGIF (Inode and Generation In FID): sequence range = [12, 2^{32} - 1]</p>
<p>  This range is reserved for compatibility with older Lustre versions that previously identified MDT objects using the ext3 inode number on the backend file system. Since those inode values were only 32-bit integers, a FID can be generated for these older objects by simply using the inode number as the sequence number. Since ext3 reserves inodes 0-11 for internal purposed, these sequence numbers will be used for other internal purposes by Lustre.</p>
<blockquote>
<p>&#x8FD9;&#x4E2A;&#x8303;&#x56F4;&#x7528;&#x4E8E;&#x4E0E;&#x65E7;&#x7248;&#x672C;&#x7684;&#x517C;&#x5BB9;&#x6027;&#x3002;&#x65E9;&#x671F; Lustre &#x4F7F;&#x7528; ext3 inode &#x53F7;&#x6765;&#x6807;&#x8BC6; MDT &#x5BF9;&#x8C61;&#x3002;&#x56E0;&#x4E3A;&#x8FD9;&#x4E9B; inode &#x53F7;&#x53EA;&#x6709;32&#x4F4D;&#xFF0C;&#x6240;&#x4EE5;&#x53EF;&#x4EE5;&#x7B80;&#x5355;&#x5730;&#x901A;&#x8FC7;&#x628A; inode &#x53F7;&#x4F5C;&#x4E3A;&#x5E8F;&#x5217;&#x53F7;&#x6765;&#x4E3A;&#x8FD9;&#x4E9B;&#x65E7;&#x7248;&#x672C;&#x7684;&#x5BF9;&#x8C61;&#x751F;&#x6210; FID&#x3002;&#x7531;&#x4E8E; ext3 &#x4FDD;&#x7559; inode &#x7684; 0&#x5230;11 &#x4F5C;&#x4E3A;&#x5185;&#x90E8;&#x7528;&#x9014;&#xFF0C;&#x8FD9;&#x4E9B;&#x5E8F;&#x5217;&#x53F7;&#x53EF;&#x4EE5;&#x88AB;&#x7528;&#x4E8E; Lustre &#x7684;&#x5176;&#x4ED6;&#x5185;&#x90E8;&#x9700;&#x6C42;&#x3002;</p>
</blockquote>
</li>
<li><p>IDIF (object ID In FID): sequence range = [2^{32}, 2^{33} - 1]</p>
<p>  This range is used for compatibility to distinguish OST objects allocated from MDT0000 with sequence 0. Bit 33 of the FID Sequence is set to 1, and the OST index along with the high 16 bits of the object number are encoded into the lower 32 bits of the sequence number. The low 32 bits of the OST Object ID is stored in the FID OID.</p>
<blockquote>
<p>&#x8FD9;&#x4E2A;&#x8303;&#x56F4;&#x7684;&#x5E8F;&#x5217;&#x7528;&#x4E8E;&#x8BC6;&#x522B; OST &#x4ECE; MDT0000 &#x7533;&#x8BF7;&#x5230;&#x7684;&#x5E8F;&#x5217;&#x53F7;&#x4E3A;0&#x7684;&#x5BF9;&#x8C61;&#x3002;FID &#x7684;&#x7B2C;33&#x4F4D;&#x8BBE;&#x7F6E;&#x4E3A;1&#xFF0C;&#x5E76;&#x5C06; OST &#x7684;&#x4E0B;&#x6807;&#x548C;&#x9AD8;16&#x4F4D;&#x7684;&#x5BF9;&#x8C61;&#x53F7;&#x7F16;&#x7801;&#x5230;&#x5E8F;&#x5217;&#x53F7;&#x7684;&#x4F4E;32&#x3002;&#x5BF9;&#x8C61; ID &#x7684;&#x4F4E;32&#x4F4D;&#x5B58;&#x653E;&#x5728; FID &#x7684; OID&#x4E2D;&#x3002;</p>
</blockquote>
</li>
<li><p>OST_MDT0: sequence = 0</p>
<p>  Used to identify existing objects allocated by MDT0000 on old formatted OSTs before the introduction of FID-on-OST.</p>
</li>
<li><p>LLOG: sequence = 1</p>
<p>  Used internally for Lustre Log objects.</p>
<blockquote>
<p>Lustre &#x5185;&#x90E8;&#x7684;&#x65E5;&#x5FD7;&#x5BF9;&#x8C61;&#x3002;</p>
</blockquote>
</li>
<li><p>ECHO: sequence = 2</p>
<p>  Used for testing OST IO performance to avoid conflicting with any &quot;real&quot; data objects.</p>
<blockquote>
<p>&#x6D4B;&#x8BD5;&#x7528;&#x9014;&#x3002;&#x907F;&#x514D;&#x548C;&#x5B9E;&#x9645;&#x6570;&#x636E;&#x4EA7;&#x751F;&#x51B2;&#x7A81;&#x3002;</p>
</blockquote>
</li>
<li><p>OST_MDT1 ... OSTMAX: sequence range = [3-9]</p>
<p>  Used for testing file systems with multiple MDTs prior to the release of DNE. These have never been used in production.</p>
<blockquote>
<p>&#x7528;&#x4E8E;&#x5728;&#x53D1;&#x5E03; DNE &#x4E4B;&#x524D;&#xFF0C;&#x6D4B;&#x8BD5;&#x591A; MDT &#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;&#x6D4B;&#x8BD5;&#x3002;&#x8FD9;&#x4E2A;&#x8303;&#x56F4;&#x7684;&#x5E8F;&#x5217;&#x53F7;&#x4ECE;&#x6CA1;&#x6709;&#x5728;&#x751F;&#x4EA7;&#x4E2D;&#x4F7F;&#x7528;&#x3002;</p>
</blockquote>
</li>
<li><p>Normal Sequences: sequence range = [2^{33}, 2^{64} - 1] </p>
<p>  This is the sequence range used in normal production and allocated to the sequence manager and clients. NOTE: The first 1024 sequence numbers in this range are reserved for system use.</p>
<blockquote>
<p>&#x8FD9;&#x4E2A;&#x8303;&#x56F4;&#x7684;&#x5E8F;&#x5217;&#xFF0C;&#x7528;&#x4E8E;&#x6B63;&#x5E38;&#x7684;&#x751F;&#x4EA7;&#x548C;&#x5206;&#x914D;&#x7ED9;&#x5E8F;&#x5217;&#x7BA1;&#x7406;&#x5668;&#x3001;&#x5BA2;&#x6237;&#x7AEF;&#x3002;&#x6CE8;&#x610F;&#xFF1A;&#x6700;&#x5F00;&#x59CB;&#x7684;1024&#x4E2A;&#x5E8F;&#x5217;&#x53F7;&#x4FDD;&#x7559;&#x7ED9;&#x7CFB;&#x7EDF;&#x4F7F;&#x7528;&#x3002;</p>
</blockquote>
</li>
</ul>
<p>The header file also contains some predefined object IDs that are used for local files such as user/group/project accounting logs, LFSCK checkpoints, etc. These are part of the local_oid enumeration, a portion of which is shown in Source Code 25.</p>
<blockquote>
<p>&#x5934;&#x6587;&#x4EF6;&#x8FD8;&#x5305;&#x542B;&#x4E00;&#x4E9B;&#x9884;&#x5B9A;&#x4E49;&#x7684;&#x5BF9;&#x8C61; ID&#xFF0C;&#x88AB;&#x7528;&#x4E8E;&#x5185;&#x90E8;&#x6587;&#x4EF6;&#xFF0C;&#x5982; user/group/project &#x8D26;&#x6237;&#x65E5;&#x5FD7;&#xFF0C;LFSCK &#x6821;&#x9A8C;&#x70B9;&#x3002;&#x5B83;&#x4EEC;&#x90FD;&#x5C5E;&#x4E8E; local_oid &#x679A;&#x4E3E;&#xFF0C;&#x6E90;&#x7801;25&#x5C55;&#x793A;&#x4E86;&#x5176;&#x4E2D;&#x7684;&#x4E00;&#x90E8;&#x5206;&#x3002;</p>
</blockquote>
<p>Source Code 25: Portion of local_oid enumeration (include/lustre_fid.h)</p>
<pre><code class="lang-c"><span class="hljs-keyword">enum</span> local_oid {
        FLD_INDEX_OID           = <span class="hljs-number">3U</span>L,
        FID_SEQ_CTL_OID         = <span class="hljs-number">4U</span>L,
        FID_SEQ_SRV_OID         = <span class="hljs-number">5U</span>L,
        ...
        ACCT_USER_OID           = <span class="hljs-number">15U</span>L,
        ACCT_GROUP_OID          = <span class="hljs-number">16U</span>L,
        LFSCK_BOOKMARK_OID      = <span class="hljs-number">17U</span>L,
        ...
        LFSCK_NAMESPACE_OID     = <span class="hljs-number">4122U</span>L,
        REMOTE_PARENT_DIR_OID   = <span class="hljs-number">4123U</span>L,
        BATCHID_COMMITTED_OID   = <span class="hljs-number">4125U</span>L,
};
</code></pre>
<p>Unless otherwise noted, the remainder of this chapter will focus on FIDs that use Normal Sequences or ones reserved for special internal objects. It will not deal with sequences reserved for compatibility reasons (IGIF, IDIF, etc).</p>
<blockquote>
<p>&#x9664;&#x975E;&#x6709;&#x5176;&#x4ED6;&#x8BF4;&#x660E;&#xFF0C;&#x5426;&#x5219;&#xFF0C;&#x5728;&#x672C;&#x7AE0;&#x7684;&#x5269;&#x4F59;&#x90E8;&#x5206;&#xFF0C;&#x4E0D;&#x4F1A;&#x6D89;&#x53CA;&#x5230;&#x517C;&#x5BB9;&#x6027;&#x7684;&#x4FDD;&#x7559;&#x5E8F;&#x5217;&#xFF0C;&#x4F46;&#x4F1A;&#x91CD;&#x70B9;&#x4ECB;&#x7ECD;&#x6B63;&#x5E38;&#x5E8F;&#x5217;&#x548C;&#x7528;&#x4E8E;&#x5185;&#x90E8;&#x5BF9;&#x8C61;&#x7684;&#x4FDD;&#x7559;&#x5E8F;&#x5217;&#xFF0C;</p>
</blockquote>
<h3 id="fid-kernel-module"><a name="fid-kernel-module" class="plugin-anchor" href="#fid-kernel-module"><i class="fa fa-link" aria-hidden="true"></i></a>fid Kernel Module</h3>
<p>FID-related functions are built into the fid kernel module. The source code for this module is located in the lustre/fid directory. For Lustre clients, two files are used to build this module: lproc_fid.c and fid_request.c. The lproc_fid.c file just contains functions needed to support debugfs and won&#x2019;t be discussed in detail here.</p>
<p>FID &#x76F8;&#x5173;&#x6E90;&#x4EE3;&#x7801;&#x5728; lustre/fid &#x76EE;&#x5F55;&#x4E2D;&#xFF0C;&#x79F0;&#x4E3A; fid &#x5185;&#x6838;&#x6A21;&#x5757;&#x3002;lustre &#x5BA2;&#x6237;&#x7AEF;&#x4F7F;&#x7528;
fid &#x5185;&#x6838;&#x6A21;&#x5757;&#x5185;&#x7F6E;&#x4E86; fid &#x76F8;&#x5173;&#x51FD;&#x6570;&#xFF0C;&#x4F4D;&#x4E8E; lustre/fid &#x76EE;&#x5F55;&#x4E2D;&#x3002;Lustre &#x5BA2;&#x6237;&#x7AEF;&#x4F7F;&#x7528; lproc_fid.c &#x548C; fid_request.c &#x6784;&#x5EFA; fid &#x5185;&#x6838;&#x6A21;&#x5757;&#x3002;&#x5176;&#x4E2D;&#xFF0C;lproc_fid.c &#x53EA;&#x5305;&#x542B;&#x8C03;&#x8BD5;&#x76F8;&#x5173;&#x7684;&#x4EE3;&#x7801;&#x3002;&#x6211;&#x4EEC;&#x4E0D;&#x4F1A;&#x5728;&#x672C;&#x6587;&#x4E2D;&#x6DF1;&#x5165;&#x63A2;&#x8BA8;&#x5B83;&#x3002;</p>
<p>The fid_request.c file contains the core functions needed to support the FID client functionality. The module entry/exit points are fid_init() and fid_exit(), but these functions just call debugfs_create_dir(...) and debugfs_remove_recursive(...) to add/remove the necessary debugfs entries. The real initialization starts in the client_fid_init function. This function is registered as part of the OBD operations (struct obd_ops) to be invoked by the MDC and OSP subsystems. The function&#x2019;s main responsibility is to allocate memory for a lu_client_seq structure which is then passed to seq_client_init(..) (an abbreviated version of which is shown in Source Code 26) where the structure is initialized. The cleanup routine starts in client_fid_fini(..) which then calls seq_client_fini(..). These two functions decrement the appropriate reference counts on other structures and free up the memory allocated to the lu_client_seq structure.</p>
<p>fid_request.c &#x5305;&#x542B; FID &#x5BA2;&#x6237;&#x7AEF;&#x529F;&#x80FD;&#x7684;&#x6838;&#x5FC3;&#x4EE3;&#x7801;&#x3002;&#x6A21;&#x5757;&#x7684;&#x5165;&#x53E3;&#x548C;&#x9000;&#x51FA;&#x51FD;&#x6570;&#x5206;&#x522B;&#x662F; fid_init() &#x548C; fid_exit()&#xFF0C;&#x4F46;&#x4E5F;&#x53EA;&#x662F;&#x8C03;&#x7528; debugfs_create_dir(...) &#x548C; debugfs_remove_recursive(...) &#x53BB;&#x6DFB;&#x52A0;&#x6216;&#x5220;&#x9664;&#x5FC5;&#x8981;&#x7684; debugfs &#x6761;&#x76EE;&#x3002;&#x771F;&#x6B63;&#x7684;&#x521D;&#x59CB;&#x5316;&#x662F; client_fid_init &#x51FD;&#x6570;&#x3002;&#x5B83;&#x6CE8;&#x518C;&#x5230; OBD &#x64CD;&#x4F5C;&#xFF0C;&#x4EE5;&#x4F9B; MDC &#x548C; OSP &#x5B50;&#x6A21;&#x5757;&#x8C03;&#x7528;&#x3002;&#x51FD;&#x6570;&#x7684;&#x4E3B;&#x8981;&#x8D1F;&#x8D23;&#x4E3A; lu_client_seq &#x7533;&#x8BF7;&#x5185;&#x5B58;&#xFF0C;&#x4E4B;&#x540E; seq_client_init(..) &#x521D;&#x59CB;&#x5316; lu_client_seq&#xFF08;&#x6E90;&#x7801;26&#xFF0C;&#x7B80;&#x5316;&#x4E86;&#x90E8;&#x5206;&#x4EE3;&#x7801;&#xFF09;&#x3002;&#x4E0A;&#x8FF0;&#x4E24;&#x4E2A;&#x51FD;&#x6570;&#x4F1A;&#x9002;&#x5F53;&#x9012;&#x51CF;&#x5176;&#x4ED6;&#x7ED3;&#x6784;&#x7684;&#x5F15;&#x7528;&#x8BA1;&#x6570;&#xFF0C;&#x5E76;&#x91CA;&#x653E;&#x5206;&#x914D;&#x7ED9; lu_client_seq &#x7684;&#x5185;&#x5B58;&#x3002;</p>
<p>Source Code 26: Function seq_client_init used in fid module initialization</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">seq_client_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lu_client_seq *seq, <span class="hljs-keyword">struct</span> obd_export *<span class="hljs-built_in">exp</span>,
                     <span class="hljs-keyword">enum</span> lu_cli_type type, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *prefix,
                     <span class="hljs-keyword">struct</span> lu_server_seq *srv)</span>
</span>{
    ...
        seq-&gt;lcs_srv = srv;
        seq-&gt;lcs_type = type;
        mutex_init(&amp;seq-&gt;lcs_mutex);
        <span class="hljs-keyword">if</span> (type == LUSTRE_SEQ_METADATA)
                seq-&gt;lcs_width = LUSTRE_METADATA_SEQ_MAX_WIDTH;
        <span class="hljs-keyword">else</span>
                seq-&gt;lcs_width = LUSTRE_DATA_SEQ_MAX_WIDTH;
        <span class="hljs-comment">/* Make sure that things are clear before work is started. */</span>
        seq_client_flush(seq);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>) seq-&gt;lcs_exp = class_export_get(<span class="hljs-built_in">exp</span>);
        <span class="hljs-built_in">snprintf</span>(seq-&gt;lcs_name, <span class="hljs-keyword">sizeof</span>(seq-&gt;lcs_name), <span class="hljs-string">&quot;cli-%s&quot;</span>, prefix);
    ...
}
</code></pre>
<p>There are only two other functions exported by the fid module: seq_client_get_seq and seq_client_alloc_fid. The seq_client_get_seq function is mainly used by the OSP subsystem when requesting a new sequence number that will be used for precreating objects. The seq_client_alloc_fid function is used to request a new FID from the client&#x2019;s currently allocated sequence. If the FID values in the current sequence are exhausted, a call is made to seq_client_alloc_seq to request a new sequence number.</p>
<blockquote>
<p>fid &#x6A21;&#x5757;&#x53EA;&#x5BFC;&#x51FA; seq_client_get_seq &#x548C; seq_client_alloc_fid &#x4E24;&#x4E2A;&#x51FD;&#x6570;&#x3002;OSP &#x5B50;&#x7CFB;&#x7EDF;&#x5728;&#x9884;&#x521B;&#x5EFA;&#x5BF9;&#x8C61;&#x65F6;&#xFF0C;&#x4F7F;&#x7528; seq_client_get_seq &#x8BF7;&#x6C42;&#x65B0;&#x7684;&#x5E8F;&#x5217;&#x53F7;&#xFF1B;seq_client_alloc_fid &#x7528;&#x4E8E;&#x4ECE;&#x5BA2;&#x6237;&#x7AEF;&#x5DF2;&#x5206;&#x914D;&#x5230;&#x7684;&#x5E8F;&#x5217;&#x4E2D;&#x8BF7;&#x6C42;&#x65B0;&#x7684; FID&#x3002;&#x5F53;&#x5E8F;&#x5217;&#x4E2D;&#x7684; FID &#x503C;&#x8017;&#x5C3D;&#xFF0C;&#x5C31;&#x8C03;&#x7528; seq_client_get_seq &#x8BF7;&#x6C42;&#x65B0;&#x7684;&#x5E8F;&#x5217;&#x53F7;&#x3002;</p>
</blockquote>
<p>For the sequence controller and sequence manager nodes, the fid kernel module includes code from three additional files: fid_handler.c, fid_store.c, and fid_lib.c. The fid_lib.c file defines some special sequence ranges and reserved FIDs. The fid_store.c file contains functions used to persist sequence information to backend storage. The functions defined in this file are not exported by the module and are just used internally by the code in fid_handler.c. The fid_handler.c file contains the functions used by FID servers to handle requests from FID clients for sequence number allocations. The fid module entry/exit points (fid_init() and fid_exit()) make calls to fid_server_mod_init() and fid_server_mod_exit() to handle server-specific initialization and cleanup. Server requests are handled by the functions seq_server_check_and_alloc_super() and seq_server_alloc_meta().</p>
<blockquote>
<p>&#x5728;&#x5E8F;&#x5217;&#x63A7;&#x5236;&#x5668;&#x548C;&#x5E8F;&#x5217;&#x7BA1;&#x7406;&#x5668;&#x8282;&#x70B9;&#x4E2D;&#xFF0C;fid &#x5185;&#x6838;&#x6A21;&#x5757;&#x989D;&#x5916;&#x5305;&#x542B; fid_handler.c&#x3001;fid_store.c&#x3001;and fid_lib.c &#x4E09;&#x4E2A;&#x4EE3;&#x7801;&#x6587;&#x4EF6;&#x3002;fid_lib.c &#x5B9A;&#x4E49;&#x4E00;&#x4E9B;&#x7279;&#x6B8A;&#x7684;&#x5E8F;&#x5217;&#x8303;&#x56F4;&#x548C;&#x4FDD;&#x7559;&#x7684; FID&#x3002;fid_store.c &#x5B9A;&#x4E49;&#x4E86;&#x6301;&#x4E45;&#x5316;&#x5E8F;&#x5217;&#x4FE1;&#x606F;&#x7684;&#x51FD;&#x6570;&#xFF0C;&#x8FD9;&#x4E9B;&#x51FD;&#x6570;&#x4E0D;&#x4F1A;&#x88AB;&#x6A21;&#x5757;&#x5BFC;&#x51FA;&#xFF0C;&#x5E76;&#x4E14;&#x53EA;&#x5728; fid_handler.c &#x4E2D;&#x4F7F;&#x7528;&#x3002;fid_handler.c &#x5B9A;&#x4E49;&#x4E86;&#x4E00;&#x4E9B;&#x88AB; FID &#x670D;&#x52A1;&#x7AEF;&#x4F7F;&#x7528;&#x7684;&#x51FD;&#x6570;&#xFF0C;&#x7528;&#x4E8E;&#x5904;&#x7406; FID &#x5BA2;&#x6237;&#x7AEF;&#x7533;&#x8BF7;&#x5E8F;&#x5217;&#x53F7;&#x7684;&#x8BF7;&#x6C42;&#x3002;fid &#x6A21;&#x5757;&#x7684;&#x5165;&#x53E3;&#x548C;&#x9000;&#x51FA;&#x51FD;&#x6570;&#xFF08;fid_init() and fid_exit()&#xFF09;&#x8C03;&#x7528; fid_server_mod_init() &#x548C; fid_server_mod_exit() &#x5904;&#x7406;&#x670D;&#x52A1;&#x7AEF;&#x7684;&#x521D;&#x59CB;&#x5316;&#x548C;&#x6E05;&#x7406;&#x6D41;&#x7A0B;&#x3002;seq_server_check_and_alloc_super() &#x548C; seq_server_alloc_meta() &#x5904;&#x7406;&#x670D;&#x52A1;&#x7AEF;&#x8BF7;&#x6C42;&#x3002;</p>
</blockquote>
<h2 id="fid-location-database-fld"><a name="fid-location-database-fld" class="plugin-anchor" href="#fid-location-database-fld"><i class="fa fa-link" aria-hidden="true"></i></a>FID Location Database (FLD)</h2>
<p>Since no two storage targets ever share the same sequence numbers, a client can determine the location of an object based on the sequence number in the object&apos;s FID. To do this, a lookup table that maps sequence numbers to storage targets must be maintained. This lookup table is called the FID Location Database. The full FLD is stored on MDT0, but each Lustre server will maintain a subset of the FLD for the sequences assigned to it. Clients can send queries to a server to request a FID lookup in the server FLD. The response is then added to the client&#x2019;s local FLD cache to speed future lookups.</p>
<blockquote>
<p>&#x56E0;&#x4E3A;&#x4E0D;&#x540C;&#x5BA2;&#x6237;&#x7AEF;&#x4ECE;&#x4E0D;&#x5171;&#x4EAB;&#x76F8;&#x540C;&#x7684;&#x5E8F;&#x5217;&#x53F7;&#xFF0C;&#x6240;&#x4EE5;&#x5BA2;&#x6237;&#x7AEF;&#x53EF;&#x4EE5;&#x57FA;&#x4E8E; FID &#x4E2D;&#x7684;&#x5E8F;&#x5217;&#x53F7;&#x786E;&#x5B9A;&#x5BF9;&#x8C61;&#x7684;&#x4F4D;&#x7F6E;&#x3002;&#x4E3A;&#x4E86;&#x5B9E;&#x73B0;&#x8BE5;&#x529F;&#x80FD;&#xFF0C;&#x9700;&#x8981;&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;&#x67E5;&#x8BE2;&#x8868;&#xFF0C;&#x8BE5;&#x8868;&#x4E5F;&#x79F0;&#x4E3A; FID &#x4F4D;&#x7F6E;&#x6570;&#x636E;&#x5E93;&#xFF0C;&#x7528;&#x4E8E;&#x6620;&#x5C04;&#x5E8F;&#x5217;&#x53F7;&#x548C;&#x5B58;&#x50A8;&#x76EE;&#x6807;&#x3002;MDT0 &#x5B58;&#x653E;&#x7740;&#x5B8C;&#x6574;&#x7684; FLD&#xFF0C;&#x800C; Lustre &#x670D;&#x52A1;&#x7AEF;&#x5219;&#x7EF4;&#x62A4; &#x5206;&#x914D;&#x7ED9;&#x5B83;&#x7684; FLD &#x5B50;&#x96C6;&#x3002;&#x5BA2;&#x6237;&#x7AEF;&#x53D1;&#x9001; FLD &#x67E5;&#x8BE2;&#x8BF7;&#x6C42;&#xFF0C;&#x5E76;&#x4E14;&#x5728;&#x5F97;&#x5230;&#x54CD;&#x5E94;&#x540E;&#xFF0C;&#x628A;&#x8BE5;&#x54CD;&#x5E94;&#x7F13;&#x5B58;&#x5728;&#x672C;&#x5730; FLD &#x7F13;&#x5B58;&#x4E2D;&#xFF0C;&#x7528;&#x4E8E;&#x52A0;&#x901F;&#x4E0B;&#x6B21;&#x67E5;&#x627E;&#x3002;</p>
</blockquote>
<p>The code related to FLD is contained in the lustre/fld directory. The fld kernel module is built from the following source files:</p>
<blockquote>
<p>FLD &#x76F8;&#x5173;&#x7684;&#x4EE3;&#x7801;&#x5728; lsutre/fld &#x76EE;&#x5F55;&#x4E2D;&#x3002;&#x4E0B;&#x5217;&#x4EE3;&#x7801;&#x6587;&#x4EF6;&#x7528;&#x4E8E;&#x6784;&#x5EFA; fld &#x5185;&#x6838;&#x6A21;&#x5757;&#xFF1A;</p>
</blockquote>
<ul>
<li><p>fld_internal.h - Contains structure definitions for FLD caching (as well as the function declarations used in the other *.c files.</p>
<blockquote>
<p>fld_internal.h&#xFF1A;&#x5B9A;&#x4E49; FLD cache &#x7ED3;&#x6784;&#x4F53;&#x548C;&#x76F8;&#x5173;&#x51FD;&#x6570;&#x58F0;&#x660E;</p>
</blockquote>
</li>
<li><p>lproc_fld.c - Defines functions for debugfs support.</p>
<blockquote>
<p>lproc_fld.c&#xFF1A;&#x5B9A;&#x4E49; debugfs &#x76F8;&#x5173;&#x51FD;&#x6570;&#x3002;</p>
</blockquote>
</li>
<li><p>fld_cache.c - Defines functions for caching results of FLD lookups on clients. These functions are only for internal use and are not exported by the module.</p>
<blockquote>
<p>fld_cache.c&#xFF1A;&#x7528;&#x4E8E;&#x7F13;&#x5B58; FLD &#x67E5;&#x8BE2;&#x7ED3;&#x679C;&#x51FD;&#x6570;&#x3002;&#x53EA;&#x5728;&#x6A21;&#x5757;&#x5185;&#x90E8;&#x4F7F;&#x7528;&#x3002;</p>
</blockquote>
</li>
<li><p>fld_request.c - Defines module entry/exit points (fld_init() and fld_exit()) as well as the function used for looking up FLD entries (fld_client_lookup()).</p>
<blockquote>
<p>fld_request.c&#xFF1A;&#x5B9A;&#x4E49;&#x6A21;&#x5757;&#x5165;&#x53E3;&#x548C;&#x9000;&#x51FA;&#x51FD;&#x6570;&#xFF0C;FLD &#x6761;&#x76EE;&#x67E5;&#x627E;&#x51FD;&#x6570;&#x3002;</p>
</blockquote>
</li>
<li><p>fld_index.c - Included only by FLD servers. Defines functions for managing the FLD database itself. Only the fld_insert_entry() function is exported for external use. All the other functions in this file are for internal use by the fld module.</p>
<blockquote>
<p>fld_index.c&#xFF1A;&#x4EC5;&#x7528;&#x4E8E; FLD &#x670D;&#x52A1;&#x7AEF;&#x3002;&#x5B9A;&#x4E49;&#x7BA1;&#x7406; FLD &#x51FD;&#x6570;&#x3002;&#x9664;&#x4E86; fld_insert_entry() &#x5728;&#x5916;&#x90E8;&#x4F7F;&#x7528;&#xFF0C;&#x5176;&#x4ED6;&#x5728;&#x8BE5;&#x6587;&#x4EF6;&#x4E2D;&#x7684;&#x51FD;&#x6570;&#x90FD;&#x5728; fld &#x6A21;&#x5757;&#x5185;&#x90E8;&#x4E2D;&#x4F7F;&#x7528;&#x3002;</p>
</blockquote>
</li>
<li><p>fld_handler.c - Included only by FLD servers. Defines the functions needed to handle FLD queries from clients.</p>
<blockquote>
<p>fld_handler.c&#xFF1A;&#x4EC5;&#x7528;&#x4E8E; FLD &#x670D;&#x52A1;&#x7AEF;&#x3002;&#x5B9A;&#x4E49;&#x5904;&#x7406;&#x5BA2;&#x6237;&#x7AEF;&#x7684; FLD &#x67E5;&#x8BE2;&#x8BF7;&#x6C42;&#x3002;</p>
</blockquote>
</li>
</ul>
<h2 id="object-index-oi"><a name="object-index-oi" class="plugin-anchor" href="#object-index-oi"><i class="fa fa-link" aria-hidden="true"></i></a>Object Index (OI)</h2>
<p>The Object Storage Device (OSD) layer acts as an abstraction between the MDT/OST layers and the underlying backend file system (ldiskfs or ZFS) used to store the actual objects. Although Lustre may use FIDs to reference all objects, the backend file system does not. It is the responsibility of the OSD abstraction layer to convert a Lustre FID into a storage cookie that can be used by the backend file system to locate the desired object. The term &#x201C;storage cookie&#x201D; is used to represent some identifier that is specific to the type of backend file system being used. In the case of ldiskfs, the storage cookie consists of the file system inode and generation number and is encapsulated in the osd_inode_id structure shown in Source Code 27.</p>
<blockquote>
<p>&#x867D;&#x7136; Lustre &#x4F7F;&#x7528; FID &#x5F15;&#x7528;&#x6240;&#x6709;&#x7684;&#x5BF9;&#x8C61;&#xFF0C;&#x4F46;&#x662F;&#x540E;&#x7AEF;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6CA1;&#x6709;&#x4F7F;&#x7528; FID&#x3002;&#x5BF9;&#x8C61;&#x5B58;&#x50A8;&#x8BBE;&#x5907;&#x5C42;&#xFF08;OSD&#xFF09;&#x4F5C;&#x4E3A; MDT &#x6216; OST &#x548C;&#x5B9E;&#x9645;&#x540E;&#x7AEF;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF08;ldiskfs &#x6216; ZFS&#xFF09;&#x4E4B;&#x95F4;&#x7684;&#x62BD;&#x8C61;&#x5C42;&#xFF0C;&#x4E3B;&#x8981;&#x8D1F;&#x8D23;&#x5C06; FID &#x8F6C;&#x6362;&#x4E3A; <code>storage cookie</code>&#x3002;&#x540E;&#x7AEF;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x4F7F;&#x7528; storage cookie &#x5B9A;&#x4F4D;&#x6240;&#x671F;&#x671B;&#x7684;&#x5BF9;&#x8C61;&#xFF0C;&#x5B83;&#x7528;&#x4E8E;&#x6807;&#x8BC6;&#x7279;&#x5B9A;&#x4E8E;&#x6240;&#x4F7F;&#x7528;&#x7684;&#x540E;&#x7AEF;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7C7B;&#x578B;&#x7684;&#x6807;&#x8BC6;&#x7B26;&#x3002;&#x4F8B;&#x5982; ldiskfs&#xFF0C;storage cookie &#x5305;&#x542B;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF; inode &#x548C; &#x751F;&#x6210;&#x53F7;&#xFF0C;&#x5E76;&#x5C01;&#x88C5;&#x5728; osd_inode_id &#x4E2D;&#xFF08;&#x89C1;&#x6E90;&#x7801;27&#xFF09;&#x3002;</p>
</blockquote>
<p>Source Code 27: osd_inode_id structure (osd-ldiskfs/osd_oi.h)</p>
<pre><code class="lang-c"><span class="hljs-comment">/*
 * Storage cookie. Datum uniquely identifying inode on the underlying file
 * system.
 *
 * osd_inode_id is the internal ldiskfs identifier for an object. It should
 * not be visible outside of the osd-ldiskfs. Other OSDs may have different
 * identifiers, so this cannot form any part of the OSD API.
 */</span>
<span class="hljs-keyword">struct</span> osd_inode_id {
        __u32 oii_ino; <span class="hljs-comment">/* inode number */</span>
        __u32 oii_gen; <span class="hljs-comment">/* inode generation */</span>
};
</code></pre>
<p>The OSD layer must maintain a mapping between Lustre FIDs and the corresponding storage cookie. This mapping is referred to as the Object Index (OI). For ldiskfs, OI-related functions are declared in the header file lustre/osd-ldiskfs/osd_oi.h as shown in Source Code 28. The functions themselves are defined in lustre/osd-ldiskfs/osd_oi.c. The OI is implemented using the Index Access Module (IAM) functions defined in the lustre/osd-ldiskfs/osd_iam.* source files. For the ZFS backend, similar functionality is provided by code in lustre/osd-zfs/osd_oi.c although the implementation details differ from osd-ldiskfs.</p>
<blockquote>
<p>OSD &#x5C42;&#x7EF4;&#x62A4; FID &#x548C; storage cookie &#x7684;&#x6620;&#x5C04;&#xFF0C;&#x79F0;&#x4E3A;&#x5BF9;&#x8C61;&#x7D22;&#x5F15;&#xFF08;OI&#xFF09;&#x3002;&#x5BF9;&#x4E8E; ldiskfs &#x7C7B;&#x578B;&#xFF0C;OI &#x76F8;&#x5173;&#x51FD;&#x6570;&#x5728; lustre/osd-ldiskfs/osd_oi.h &#x58F0;&#x660E;&#xFF08;&#x89C1;&#x6E90;&#x7801;28&#xFF09;&#xFF0C;&#x800C;&#x76F8;&#x5173;&#x5B9A;&#x4E49;&#x5728; lustre/osd-ldiskfs/osd_oi.c &#x4E2D;&#x3002;OI &#x4F7F;&#x7528; &#x7D22;&#x5F15;&#x8BBF;&#x95EE;&#x6A21;&#x578B;&#xFF08;IAM&#xFF09;&#x5B9E;&#x73B0;&#xFF0C;&#x89C1; lustre/osd-ldiskfs/osd_iam.* &#x6587;&#x4EF6;&#x3002;&#x5BF9;&#x4E8E; ZFS &#x7C7B;&#x578B;&#xFF0C;&#x76F8;&#x5173;&#x529F;&#x80FD;&#x5B9E;&#x73B0;&#x7EC6;&#x8282;&#x6709;&#x6240;&#x5DEE;&#x5F02;&#xFF0C;&#x53EF;&#x89C1;&#x4E8E; lustre/osd-zfs/osd_oi.c &#x6587;&#x4EF6;&#x3002;</p>
</blockquote>
<p>Source Code 28: Functions for interacting with the Object Index (OI)</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">osd_oi_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> osd_thread_info *info, <span class="hljs-keyword">struct</span> osd_device *osd,
                <span class="hljs-keyword">bool</span> restored)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">osd_oi_fini</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> osd_thread_info *info, <span class="hljs-keyword">struct</span> osd_device *osd)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">osd_oi_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> osd_thread_info *info, <span class="hljs-keyword">struct</span> osd_device *osd,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> lu_fid *fid, <span class="hljs-keyword">struct</span> osd_inode_id *id,
                   <span class="hljs-keyword">enum</span> oi_check_flags flags)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">osd_oi_insert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> osd_thread_info *info, <span class="hljs-keyword">struct</span> osd_device *osd,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> lu_fid *fid, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> osd_inode_id *id,
                   handle_t *th, <span class="hljs-keyword">enum</span> oi_check_flags flags, <span class="hljs-keyword">bool</span> *exist)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">osd_oi_delete</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> osd_thread_info *info,
                   <span class="hljs-keyword">struct</span> osd_device *osd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> lu_fid *fid,
                   handle_t *th, <span class="hljs-keyword">enum</span> oi_check_flags flags)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">osd_oi_update</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> osd_thread_info *info, <span class="hljs-keyword">struct</span> osd_device *osd,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> lu_fid *fid, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> osd_inode_id *id,
                   handle_t *th, <span class="hljs-keyword">enum</span> oi_check_flags flags)</span></span>;
</code></pre>
<blockquote id="fn_1">
<sup>1</sup>. <em>lustre &#x652F;&#x6301;&#x591A;&#x4E2A; MDT&#xFF08;DNE&#xFF09;&#xFF0C;&#x5B58;&#x5728;&#x591A;&#x4E2A; mdc</em><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#x21A9;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. <em>&#x4E25;&#x8C28;&#x4E00;&#x70B9;&#x5730;&#x8BF4;&#xFF0C;&#x662F;&#x5728; Lustre &#x5BA2;&#x6237;&#x7AEF;&#x4E0A;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x7EC4;&#x4EF6;</em><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#x21A9;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. <em>&#x597D;&#x50CF;&#x4E5F;&#x4E0D;&#x80FD;&#x7FFB;&#x8BD1;&#x4E3A;&#x52A0;&#x6CD5;&#xFF0C;&#x6211;&#x7684;&#x7406;&#x89E3;&#x662F;&#xFF0C;&#x8C03;&#x6574;&#x5185;&#x6838;&#x65F6;&#x95F4;&#xFF0C;&#x7528;&#x4E8E;&#x6D4B;&#x8BD5;&#x76EE;&#x7684;</em><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#x21A9;</a>
</blockquote>
<script type="text/javascript">var className='atoc';</script>
                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: Understanding Lustre Internals 中文翻译">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Understanding-Lustre-Internals-中文翻译.html#what-is-lustre" class="navigation navigation-next " aria-label="Next page: What is Lustre?">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Lustre Architecture","level":"1.2.1","depth":2,"next":{"title":"What is Lustre?","level":"1.2.1.1","depth":3,"anchor":"#what-is-lustre","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#what-is-lustre","articles":[]},"previous":{"title":"Understanding Lustre Internals 中文翻译","level":"1.2","depth":1,"path":"content/Understanding-Lustre-Internals-中文翻译/README.md","ref":"content/Understanding-Lustre-Internals-中文翻译/README.md","articles":[{"title":"Lustre Architecture","level":"1.2.1","depth":2,"anchor":"#lustre-architecture","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#lustre-architecture","articles":[{"title":"What is Lustre?","level":"1.2.1.1","depth":3,"anchor":"#what-is-lustre","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#what-is-lustre","articles":[]},{"title":"Lustre Features","level":"1.2.1.2","depth":3,"anchor":"#lustre-features","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#lustre-features","articles":[]},{"title":"Lustre Components","level":"1.2.1.3","depth":3,"anchor":"#lustre-components","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#lustre-components","articles":[]},{"title":"Lustre File Layouts","level":"1.2.1.4","depth":3,"anchor":"#lustre-file-layouts","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#lustre-file-layouts","articles":[{"title":"Normal (RAID0) Layouts","level":"1.2.1.4.1","depth":4,"anchor":"#normal-raid0-layouts","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#normal-raid0-layouts","articles":[]}]}]},{"title":"TEST","level":"1.2.2","depth":2,"anchor":"#test","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#test","articles":[]},{"title":"UTILS","level":"1.2.3","depth":2,"anchor":"#utils","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#utils","articles":[]},{"title":"MGC","level":"1.2.4","depth":2,"anchor":"#mgc","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#mgc","articles":[{"title":"Introduction","level":"1.2.4.1","depth":3,"anchor":"#mgc-introduction","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#mgc-introduction","articles":[]},{"title":"MGC Module Initialization","level":"1.2.4.2","depth":3,"anchor":"#mgc-module-initialization","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#mgc-module-initialization","articles":[]},{"title":"MGC obd Operations","level":"1.2.4.3","depth":3,"anchor":"#mgc-obd-operations","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#mgc-obd-operations","articles":[]},{"title":"mgc_setup()","level":"1.2.4.4","depth":3,"anchor":"#mgcsetup","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#mgcsetup","articles":[{"title":"Operation","level":"1.2.4.4.1","depth":4,"anchor":"#operation","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#operation","articles":[]}]},{"title":"Lustre Log Handling","level":"1.2.4.5","depth":3,"anchor":"#lustre-log-handling","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#lustre-log-handling","articles":[{"title":"Log Processing in MGC","level":"1.2.4.5.1","depth":4,"anchor":"#log-processing-in-mgc","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#log-processing-in-mgc","articles":[]}]},{"title":"mgc_precleanup() and mgc_cleanup()","level":"1.2.4.6","depth":3,"anchor":"#mgcprecleanup-and-mgccleanup","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#mgcprecleanup-and-mgccleanup","articles":[]},{"title":"mgc_import_event()","level":"1.2.4.7","depth":3,"anchor":"#mgcimportevent","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#mgcimportevent","articles":[]}]},{"title":"OBDCLASS","level":"1.2.5","depth":2,"anchor":"#obdclass","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#obdclass","articles":[{"title":"Introduction","level":"1.2.5.1","depth":3,"anchor":"#obdclass-introduction","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#obdclass-introduction","articles":[]},{"title":"obd_device Structure","level":"1.2.5.2","depth":3,"anchor":"#obddevice-structure","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#obddevice-structure","articles":[]},{"title":"MGC Life Cycle","level":"1.2.5.3","depth":3,"anchor":"#mgc-life-cycle","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#mgc-life-cycle","articles":[]},{"title":"Obd Device Life Cycle","level":"1.2.5.4","depth":3,"anchor":"#obd-device-life-cycle","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#obd-device-life-cycle","articles":[{"title":"class_attach()","level":"1.2.5.4.1","depth":4,"anchor":"#classattach","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#classattach","articles":[]},{"title":"obd_export Structure","level":"1.2.5.4.2","depth":4,"anchor":"#obdexport-structure","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#obdexport-structure","articles":[]},{"title":"class_setup()","level":"1.2.5.4.3","depth":4,"anchor":"#classsetup","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#classsetup","articles":[]},{"title":"class_precleanup() and class_cleanup()","level":"1.2.5.4.4","depth":4,"anchor":"#classprecleanup-and-classcleanup","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#classprecleanup-and-classcleanup","articles":[]}]},{"title":"Imports and Exports","level":"1.2.5.5","depth":3,"anchor":"#imports-and-exports","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#imports-and-exports","articles":[]},{"title":"Useful APIs in Obdclass","level":"1.2.5.6","depth":3,"anchor":"#useful-apis-in-obdclass","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#useful-apis-in-obdclass","articles":[]}]},{"title":"LIBCFS","level":"1.2.6","depth":2,"anchor":"#libcfs","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#libcfs","articles":[{"title":"Introduction","level":"1.2.6.1","depth":3,"anchor":"#libcfs-introduction","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#libcfs-introduction","articles":[]},{"title":"Data Encryption Support in Libcfs","level":"1.2.6.2","depth":3,"anchor":"#data-encryption-support-in-libcfs","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#data-encryption-support-in-libcfs","articles":[]},{"title":"CPU Partition Table Management","level":"1.2.6.3","depth":3,"anchor":"#cpu-partition-table-management","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#cpu-partition-table-management","articles":[]},{"title":"Debugging Support and Failure Injection","level":"1.2.6.4","depth":3,"anchor":"#debugging-support-and-failure-injection","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#debugging-support-and-failure-injection","articles":[]},{"title":"Additional Supporting Software in Libcfs","level":"1.2.6.5","depth":3,"anchor":"#additional-supporting-software-in-libcfs","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#additional-supporting-software-in-libcfs","articles":[]}]},{"title":"File Identifiers, FID Location Database, and Object Index","level":"1.2.7","depth":2,"anchor":"#file-identifiers-fid-location-database-and-object-index","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#file-identifiers-fid-location-database-and-object-index","articles":[{"title":"File Identifier (FID)","level":"1.2.7.1","depth":3,"anchor":"#file-identifier-fid","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#file-identifier-fid","articles":[{"title":"Reserved Sequence Numbers and Object IDs","level":"1.2.7.1.1","depth":4,"anchor":"#reserved-sequence-numbers-and-object-ids","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#reserved-sequence-numbers-and-object-ids","articles":[]},{"title":"fid Kernel Module","level":"1.2.7.1.2","depth":4,"anchor":"#fid-kernel-module","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#fid-kernel-module","articles":[]}]},{"title":"FID Location Database (FLD)","level":"1.2.7.2","depth":3,"anchor":"#fid-location-database-fld","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#fid-location-database-fld","articles":[]},{"title":"Object Index (OI)","level":"1.2.7.3","depth":3,"anchor":"#object-index-oi","path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","ref":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md#object-index-oi","articles":[]}]}]},"dir":"ltr"},"config":{"plugins":["code","pageview-count","-search","splitter","atoc","anchors","theme-default","expandable-chapters","theme-comscore","back-to-top-button","auto-scroll-table","katex"],"styles":{"ebook":"styles/ebook.css","epub":"styles/epub.css","mobi":"styles/mobi.css","pdf":"styles/pdf.css","print":"styles/print.css","website":"styles/website.css"},"pluginsConfig":{"atoc":{"addClass":true,"className":"atoc"},"splitter":{},"auto-scroll-table":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"code":{"copyButtons":true},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"fontSettings":{"theme":"white","family":"serif","size":4},"highlight":{},"theme-comscore":{},"back-to-top-button":{},"pageview-count":{},"ga":{"token":"UA-39088953-8"},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"showLevel":true,"styles":{"ebook":"styles/ebook.css","epub":"styles/epub.css","mobi":"styles/mobi.css","pdf":"styles/pdf.css","print":"styles/print.css","website":"styles/website.css"}},"anchors":{},"expandable-chapters":{}},"theme":"default","keywords":"Lustre，storage，filesystem","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":36,"bottom":36},"toc":true},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Lustre doc","language":"zh-hans","introduction":{"path":"README.md","title":"Lustre 文档收集概述"},"gitbook":"*","description":"收集一些 lustre 文档和笔记"},"file":{"path":"content/Understanding-Lustre-Internals-中文翻译/Understanding-Lustre-Internals-中文翻译.md","mtime":"2023-05-28T15:51:45.757Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2023-05-28T15:52:49.403Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-code/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-pageview-count/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-atoc/atoc.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-auto-scroll-table/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
        
    

    </body>
</html>

